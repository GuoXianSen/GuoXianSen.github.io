<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay_Guo的博客</title>
  
  
  <link href="https://guoxiansen.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoxiansen.github.io/"/>
  <updated>2024-01-19T04:22:21.477Z</updated>
  <id>https://guoxiansen.github.io/</id>
  
  <author>
    <name>Clay_Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单调栈</title>
    <link href="https://guoxiansen.github.io/2023/12/12/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://guoxiansen.github.io/2023/12/12/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-12-12T05:13:39.000Z</published>
    <updated>2024-01-19T04:22:21.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>通常针对一维数组的问题，如果需要寻找一个元素右边或者左边第一个比自己大或者小的元素的位置，就可以使用单调栈，时间复杂度为O(n)</p><p>单调栈的本质是空间换时间， 遍历的过程中需要使用一个栈记录右边第一个比当前元素高的值。优点是整个数组只需要遍历一次。</p><p>使用单调栈需要明确的几点：</p><ul><li>单调栈中存放的元素是什么？</li><li>单调栈里的元素是递增还是递减？</li></ul><p>单调栈中存放的元素最好是==<strong>下标</strong>==，这样具有更好的泛型</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="739、每日温度"><a href="#739、每日温度" class="headerlink" title="739、每日温度"></a>739、每日温度</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312121343526.png" alt="image-20231212134352911"></p><p>使用单调栈的方式==<strong>从前往后</strong>==进行遍历</p><p>栈中的元素从栈底到栈顶的顺序是递减的，直到找到一个比栈顶元素大的值，然后出栈。</p><p>栈中存放的是元素的下标，如果出现一个新的元素比栈中元素都要大的时候，就对栈中元素进行循环遍历，将其对应的res值修改为当前元素的下标和栈中存放的值的差值，这就是最终结果，到最后一个元素的时候，因为初始化结果列表中元素值都是0，姑不需要进行修改</p><p>初始化答案res为全0的列表，这样可以防止后面的元素没有下一个更大的元素，当然这一点要根据题目的要求来，因为有些题目会赋值为-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">0</span>]*<span class="built_in">len</span>(temperatures)</span><br><span class="line">        st = []</span><br><span class="line">        <span class="comment"># 从前往后进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> index,temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">            <span class="comment"># st不为空且温度大于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> temp&gt;temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                <span class="comment"># 题目中问的是下一个更高温度出现在几天之后 因此用下标之差表示即可</span></span><br><span class="line">                res[j] = index-j</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312121353512.png" alt="image-20231212135345977"></p><h2 id="496、下一个更大元素I"><a href="#496、下一个更大元素I" class="headerlink" title="496、下一个更大元素I"></a>496、下一个更大元素I</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051514436.png" alt="image-20240105151441966"></p><p>直接寻找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="comment"># 寻找下一个更大的元素</span></span><br><span class="line">        <span class="keyword">for</span> index,n1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1):</span><br><span class="line">            startindex = nums2.index(n1)</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums2[startindex+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> n&gt;n1:</span><br><span class="line">                    res[index] = n</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>使用单调栈</p><p>题目中有<strong>【需要寻找最近一个比其大的元素】</strong> 这样的字眼，就可以使用 <strong>【单调栈】</strong></p><p>本题需要注意的是题目中存在两个数组，寻找第一个数组在第二个数组元素中下一个比对应元素大的元素。题目中说了两个数组中是没有重复元素的，可以采用单调栈+哈希表的方式进行解决。</p><p>单调栈解决的是nums2中每个元素对应的下一个比其大的元素</p><p>哈希表解决的是用来存储每个元素对应的下一个元素值，这样方便对nums1进行遍历时的查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        st = []</span><br><span class="line">        res = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            <span class="comment"># print(index,num)</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> nums2[st[-<span class="number">1</span>]]&lt;num:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                res[j] = num</span><br><span class="line">            st.append(index)</span><br><span class="line">        myhash = <span class="built_in">dict</span>(<span class="built_in">zip</span>(nums2,res))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> n1 <span class="keyword">in</span> nums1:</span><br><span class="line">            ans.append(myhash[n1])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="1994、队列中可以看到的人数"><a href="#1994、队列中可以看到的人数" class="headerlink" title="1994、队列中可以看到的人数"></a>1994、队列中可以看到的人数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707266.png" alt="image-20240105170740011"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707699.png" alt="image-20240105170750651"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051708889.png" alt="image-20240105170804493"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canSeePersonsCount</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        ans = [<span class="number">0</span>]*n</span><br><span class="line">        st = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>]&lt;heights[i]:</span><br><span class="line">                st.pop()</span><br><span class="line">                ans[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[i]+=<span class="number">1</span></span><br><span class="line">            st.append(heights[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707618.png" alt="image-20240105170722984"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h1&gt;&lt;p&gt;通常针对一维数组的问题，如果需要寻找一个元素右边或者左边第一个比自己大或者小的元素的位置，就可以使用单调栈，时间复杂度为O(n)&lt;/</summary>
      
    
    
    
    
    <category term="单调栈" scheme="https://guoxiansen.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛20231210</title>
    <link href="https://guoxiansen.github.io/2023/12/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B20231210/"/>
    <id>https://guoxiansen.github.io/2023/12/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B20231210/</id>
    <published>2023-12-10T03:56:34.000Z</published>
    <updated>2023-12-10T04:00:15.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计已测试设备"><a href="#统计已测试设备" class="headerlink" title="统计已测试设备"></a>统计已测试设备</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101159415.png" alt="image-20231210115855304"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTestedDevices</span>(<span class="params">self, batteryPercentages: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(batteryPercentages)):</span><br><span class="line">            <span class="keyword">if</span> batteryPercentages[i] &gt; <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(batteryPercentages)):</span><br><span class="line">                    batteryPercentages[j] = <span class="built_in">max</span>(<span class="number">0</span>, batteryPercentages[j] - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># print(batteryPercentages)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="双模幂运算"><a href="#双模幂运算" class="headerlink" title="双模幂运算"></a>双模幂运算</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101159522.png" alt="image-20231210115921406"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGoodIndices</span>(<span class="params">self, variables: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(variables)):</span><br><span class="line">            <span class="keyword">if</span> ((variables[i][<span class="number">0</span>] ** variables[i][<span class="number">1</span>]) % <span class="number">10</span>) ** variables[i][<span class="number">2</span>] % variables[i][<span class="number">3</span>] == target:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统计最大元素出现至少-K-次的子数组"><a href="#统计最大元素出现至少-K-次的子数组" class="headerlink" title="统计最大元素出现至少 K 次的子数组"></a>统计最大元素出现至少 K 次的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个 <strong>正整数</strong> <code>k</code> 。</p><p>请你统计有多少满足 「 <code>nums</code> 中的 <strong>最大</strong> 元素」至少出现 <code>k</code> 次的子数组，并返回满足这一条件的子数组的数目。</p><p>子数组是数组中的一个连续元素序列。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101157791.png" alt="image-20231210115737423"></p><h2 id="统计好分割方案的数目"><a href="#统计好分割方案的数目" class="headerlink" title="统计好分割方案的数目"></a>统计好分割方案的数目</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101158793.png" alt="image-20231210115820635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;统计已测试设备&quot;&gt;&lt;a href=&quot;#统计已测试设备&quot; class=&quot;headerlink&quot; title=&quot;统计已测试设备&quot;&gt;&lt;/a&gt;统计已测试设备&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/p</summary>
      
    
    
    
    
    <category term="力扣" scheme="https://guoxiansen.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="https://guoxiansen.github.io/2023/12/01/%E5%9B%BE%E8%AE%BA/"/>
    <id>https://guoxiansen.github.io/2023/12/01/%E5%9B%BE%E8%AE%BA/</id>
    <published>2023-12-01T12:10:21.000Z</published>
    <updated>2023-12-01T13:37:19.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h2><h2 id="797、所有可能的路径"><a href="#797、所有可能的路径" class="headerlink" title="797、所有可能的路径"></a>797、所有可能的路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312012122713.png" alt="image-20231201212235456"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> graph:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph, path, x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="built_in">len</span>(graph)-<span class="number">1</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[x]:</span><br><span class="line">                path.append(node)</span><br><span class="line">                dfs(graph,path,node)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(graph,[<span class="number">0</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论&quot;&gt;&lt;a href=&quot;#图论&quot; class=&quot;headerlink&quot; title=&quot;图论&quot;&gt;&lt;/a&gt;图论&lt;/h1&gt;&lt;h2 id=&quot;深度优先搜索DFS&quot;&gt;&lt;a href=&quot;#深度优先搜索DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索D</summary>
      
    
    
    
    
    <category term="图" scheme="https://guoxiansen.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode散题集合</title>
    <link href="https://guoxiansen.github.io/2023/11/29/Leetcode%E6%95%A3%E9%A2%98%E9%9B%86%E5%90%88/"/>
    <id>https://guoxiansen.github.io/2023/11/29/Leetcode%E6%95%A3%E9%A2%98%E9%9B%86%E5%90%88/</id>
    <published>2023-11-29T04:12:27.000Z</published>
    <updated>2024-01-09T05:57:43.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣散题集合"><a href="#力扣散题集合" class="headerlink" title="力扣散题集合"></a>力扣散题集合</h1><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h2 id="1200、最小绝对差"><a href="#1200、最小绝对差" class="headerlink" title="1200、最小绝对差"></a>1200、最小绝对差</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291531976.png" alt="image-20231129153157717"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291532290.png" alt="image-20231129153213057"></p><p>提示中可以得知数据量在10^5^，如果使用两层for循环判断必定超时，因此本题不能使用双层for循环进行判断</p><p>思路：</p><ul><li>对arr进行排序</li><li>因为要判断最小绝对差，所以只需要对排序后的数字进行判断相邻两数的差值即可，如果小则更新否则不更新</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = []</span><br><span class="line">        arr.sort() <span class="comment"># 排序之后从前往后进行遍历 排序之后找最小差值 只需要在相邻的两个数之间进行寻找判断即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> min_ &gt; <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>]):</span><br><span class="line">                min_ = <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>])</span><br><span class="line">                res = [[arr[i-<span class="number">1</span>],arr[i]]]</span><br><span class="line">            <span class="keyword">elif</span> min_== <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>]):</span><br><span class="line">                res.append([arr[i-<span class="number">1</span>],arr[i]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291534649.png" alt="image-20231129153424458"></p><h2 id="2843、统计对称整数的数目"><a href="#2843、统计对称整数的数目" class="headerlink" title="2843、统计对称整数的数目"></a>2843、统计对称整数的数目</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291534085.png" alt="image-20231129153456810"></p><p>数字转化为字符串进行判断再求和 复杂度较高 可以进行优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSymmetricIntegers</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">num</span>):</span></span><br><span class="line">            num = <span class="built_in">str</span>(num)</span><br><span class="line">            a = <span class="built_in">list</span>(num[:<span class="built_in">len</span>(num)//<span class="number">2</span>])</span><br><span class="line">            b = <span class="built_in">list</span>(num[<span class="built_in">len</span>(num)//<span class="number">2</span>:])</span><br><span class="line">            a = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">            b = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(a)==<span class="built_in">sum</span>(b)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low,high+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>(i))%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> judge(i):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h1><h2 id="2661、找出叠涂元素"><a href="#2661、找出叠涂元素" class="headerlink" title="2661、找出叠涂元素"></a>2661、找出叠涂元素</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011328233.png" alt="image-20231201132821370"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011329085.png" alt="image-20231201132859711"></p><p>题目理解：</p><p>注意关键词：arr中在mat的某一行<strong>或者</strong>某一列都被涂色且下标最小的元素返回其在arr中的下标</p><p>首先通过哈希表来对矩阵mat进行遍历，记录所有数字的键和值，其中键为矩阵中的数字，值为(i,j)元组，i和j分别表示该数字在矩阵中的行列下标。</p><p>注意题目中的<code>len(mat)</code> 表示矩阵共有多少行，<code>len(mat[0])</code>表示矩阵共有多少列</p><p>构建好哈希表之后，还需要一个for循环对arr数组进行遍历，然后需要将其中每一个数字的行列下标</p><p>这里是行满了或者列满了，用一个变量来记录当前行列被涂色的数量。</p><p>下面的代码中 c1 记录某行有多少个元素被涂色，即一共有多少列，c2记录某列有多少个元素被涂色，即一共有多少行。</p><p>判断c1[i]==len(mat[0]) or c2[j]=len(mat) 即可返回最终arr中的下标ii，注意这里i已经被用了，不能再使用i作为循环变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstCompleteIndex</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], mat: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">tuple</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># print(&quot;mat[&#123;&#125;][&#123;&#125;]=&#123;&#125;&quot;.format(i,j,mat[i][j]))</span></span><br><span class="line">                myhash[mat[i][j]] = (i,j)</span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        c1 = defaultdict(<span class="built_in">int</span>) <span class="comment"># 记录某行有多少个元素被涂色  ==》列</span></span><br><span class="line">        c2 = defaultdict(<span class="built_in">int</span>) <span class="comment"># 记录某列有多少个元素被涂色  ==》行</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            i,j = myhash[arr[ii]]</span><br><span class="line">            <span class="comment"># print(i,j)</span></span><br><span class="line">        </span><br><span class="line">            c1[i] += <span class="number">1</span></span><br><span class="line">            c2[j] += <span class="number">1</span>  <span class="comment"># c2[j] 表示该列有多少个元素 即 多少行元素</span></span><br><span class="line">            <span class="comment"># len(mat[0])表示有多少行  len(mat) 表示有多少列</span></span><br><span class="line">            <span class="comment"># print(c1[i],c2[j], len(mat),len(mat[0]))</span></span><br><span class="line">            <span class="keyword">if</span> c1[i]==<span class="built_in">len</span>(mat[<span class="number">0</span>]) <span class="keyword">or</span> c2[j]==<span class="built_in">len</span>(mat):</span><br><span class="line">                <span class="keyword">return</span> ii</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>优化代码：</p><p>避免重复使用len(mat)这样的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstCompleteIndex</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], mat: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])   <span class="comment"># m表示行  n表示列</span></span><br><span class="line">        myhash = &#123;mat[i][j]:(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        c1,c2 = [<span class="number">0</span>]*m,[<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(m*n):</span><br><span class="line">            i,j = myhash[arr[ii]]</span><br><span class="line">            c1[i] += <span class="number">1</span></span><br><span class="line">            c2[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c1[i]==n <span class="keyword">or</span> c2[j]==m:</span><br><span class="line">                <span class="keyword">return</span> ii</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011534524.png" alt="image-20231201153403415"></p><h2 id="1094、拼车"><a href="#1094、拼车" class="headerlink" title="1094、拼车"></a>1094、拼车</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312022123053.png" alt="image-20231202212343674"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312022124364.png" alt="image-20231202212410014"></p><h2 id="241、为运算表达式设计优先级"><a href="#241、为运算表达式设计优先级" class="headerlink" title="241、为运算表达式设计优先级"></a>241、为运算表达式设计优先级</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401091357205.png" alt="image-20231206103039562"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401091357430.png" alt="image-20231206103054281"></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;力扣散题集合&quot;&gt;&lt;a href=&quot;#力扣散题集合&quot; class=&quot;headerlink&quot; title=&quot;力扣散题集合&quot;&gt;&lt;/a&gt;力扣散题集合&lt;/h1&gt;&lt;h1 id=&quot;简单&quot;&gt;&lt;a href=&quot;#简单&quot; class=&quot;headerlink&quot; title=&quot;简单&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="散题" scheme="https://guoxiansen.github.io/tags/%E6%95%A3%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://guoxiansen.github.io/2023/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://guoxiansen.github.io/2023/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-11-25T07:20:40.000Z</published>
    <updated>2024-01-19T03:41:06.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949273.jpg" alt="img"></p><p>如果某一个问题有重叠的子问题，则使用动态规划进行求解是最有效的。</p><p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点区别于贪心算法</p><p>动态规划五部曲</p><ul><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何进行初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><ul><li>01背包</li><li>完全背包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949940.png" alt="416.分割等和子集1"></p><h3 id="01背包-二维数组进行求解"><a href="#01背包-二维数组进行求解" class="headerlink" title="01背包 | 二维数组进行求解"></a>01背包 | 二维数组进行求解</h3><p>有n个物品和最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。==每件物品只能用一次==，求解将哪些物品装进背包里面价值总和最大。</p><p>递归五部曲</p><ul><li><h4 id="确定dp数组含义"><a href="#确定dp数组含义" class="headerlink" title="确定dp数组含义"></a>确定dp数组含义</h4></li></ul><p>dp[i][j]表示从下标0-i的物品中任意选取，放进容量为j的背包中，价值总和最大是多少</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949496.png" alt="动态规划-背包问题1"></p><ul><li><h4 id="确定递推公式"><a href="#确定递推公式" class="headerlink" title="确定递推公式"></a>确定递推公式</h4><ul><li>有两种情况：<ul><li>不放物品<ul><li>dp[i][j] = dp[i-1][j]   即当前dp数组的上一个的位置</li></ul></li><li>放物品<ul><li>dp[i][j] = dp[i-1][j-weight[i]] + value[i]     位于当前位置的左上方，不一定正好是左上角，有可能是左上角的前面的位置</li></ul></li></ul></li></ul></li></ul><p>当前的最大总价值应该取二者中的最大值</p><p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); </p><p>并且需要注意，如果j&lt;weight[i]的时候，是不能放物品的，</p><p>放物品时候的理解：当i放进去的时候，背包的总重量为j，前i-1个能放的物品剩余重量就只剩下j-weight[i]，前i-1个物品中能够获得的最大价值为dp[i-1][j-weight[i]]，再加上当前物品i放进去的价值value[i]。这是当前放物品能够获得的最大价值。</p><ul><li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br></pre></td></tr></table></figure><p>当<code>j=0</code>的时候，表示当前背包能够载重为0，此时不管选择几号物品，dp[i][j]都等于0</p><p>当<code>i=0</code>的时候，表示当前只取物品0，此时只有在j&gt;=weight[0]的时候，dp[i][j]=value[0]</p><ul><li><h4 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li></ul><p>先遍历物品或者先遍历背包都是可以的，为了和滚动数组一致，先遍历物品在遍历背包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m代表材料的数量，n代表背包载重</span></span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># M 代表研究材料的种类 N代表行李空间</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表重量</span></span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部初始化为0</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化dp数组第一列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># 初始化dp数组第一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], n + <span class="number">1</span>):</span><br><span class="line">    dp[<span class="number">0</span>][i] = value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(weight)</span></span><br><span class="line"><span class="comment"># print(value)</span></span><br><span class="line"><span class="comment"># for i in dp:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line">print(dp[m - <span class="number">1</span>][n])</span><br></pre></td></tr></table></figure><h3 id="滚动数组-01背包-二维降到一维"><a href="#滚动数组-01背包-二维降到一维" class="headerlink" title="滚动数组 | 01背包 二维降到一维"></a>滚动数组 | 01背包 二维降到一维</h3><ul><li><h4 id="dp数组含义"><a href="#dp数组含义" class="headerlink" title="dp数组含义"></a>dp数组含义</h4></li></ul><p>dp[j]表示当容量为j的时候背包所背的物品最大价值</p><ul><li><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4></li></ul><p>跟使用二维数组的时候一样，通过两种方式获得dp[j]：</p><p>放物品i</p><p>​    当放物品i的时候，dp[j] = dp[j-weight[i]] + value[i]</p><p>不放物品i</p><p>​    当不放物品i的时候dp[j] = dp[j-1]</p><p>递推公式为</p><p>dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</p><ul><li><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4></li></ul><p>dp[j]表示背包容量为j的时候所背物品的最大价值，则dp[0]表示物品容量为0，结果必然为0</p><p>其余的下标都是通过递推的方式从dp[0]推出，因此全部初始化为0即可</p><ul><li><h4 id="遍历顺序-1"><a href="#遍历顺序-1" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li><li><h5 id="为什么需要先遍历物品在遍历重量？"><a href="#为什么需要先遍历物品在遍历重量？" class="headerlink" title="==为什么需要先遍历物品在遍历重量？=="></a>==为什么需要先遍历物品在遍历重量？==</h5></li></ul><p>如果遍历背包容量放在外层，则每个dp[j]只会放一个物品，即背包里只放了一个物品。</p><p>如果先遍历背包重量的，</p><ul><li><h5 id="为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）"><a href="#为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）" class="headerlink" title="为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）"></a>为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）</h5></li></ul><p>假设现在背包的情况是这样的</p><table><thead><tr><th align="center"></th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">1</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">3</td><td align="center">20</td></tr><tr><td align="center">物品2</td><td align="center">4</td><td align="center">30</td></tr></tbody></table><p>遍历部分的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>dp数组初始化为全0，如果我们从后开始进行遍历的话，当遍历物品0时，weight[0] = 1，value[0] = 15</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111706802.png" alt="image-20231211170639827"></p><p>dp[1] = max(dp[1], dp[1-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[2] = max(dp[2], dp[2-weight[0]] + value[0]) = max(0, 15+15) = 30</p><p>此时重复往背包中放入物品0了</p><p>如果我们从后往前进行遍历的话，情况如下：</p><p>dp[4] = max(dp[4], dp[4-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[3] = max(dp[3], dp[3-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[2] = max(dp[2], dp[2-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[1] = max(dp[1], dp[1-weight[0]] + value[0]) = max(0, 15) = 15</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111711402.png" alt="image-20231211171139340"></p><p>这样循环往复就可以得到最终的dp数组，而dp[n]也就是最终结果</p><p>倒序进行遍历是因为每个背包只能放进去一次，正序遍历的时候会重复使用符合条件的背包价值。</p><p>遍历的代码部分中，倒序遍历的时候开始和结束的下标分别为n和weight[i]-1，n很好理解，就是dp数组中的元素个数，weight[i]-1表示什么含义呢？</p><p>因为题目中涉及到j-weight[i]这个操作，因此遍历到物品i的时候我们的结束下标j一定是等于weight[i]的</p><p>在Python的循环中，左闭右开，为了遍历到weight[i]这个重量，需要再减去1</p><p>例如当我们在遍历物品0的时候，即当前的i=0，此时weight[i]=1，为了能够用j模拟其能够开始推导递推公式，需要j-weight[i]&gt;=0，因此j最小下标应该就是weight[i]，又由于range()的范围是左闭右开，所以结束下标应该是weight[i]-1，此时结束下标就是0，即0的时候不会在进行循环体部分。</p><p>倒序遍历原因本质上还是对二维数组的遍历，右下角的值依赖于左上角的值，因此需要保证左边的值仍然是上一层的，从右往左进行覆盖</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111651393.png" alt="动态规划-背包问题9"></p><p><a href="https://kamacoder.com/problempage.php?pid=1046">题目链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111654000.png" alt="image-20231211165420367"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m代表材料的数量，n代表背包载重</span></span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># M 代表研究材料的种类 N代表行李空间</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表重量</span></span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部初始化为0   表示背包重量从0-n 共计n+1个数字</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包和01背包的区别就在于物品是否可以重复选取，如果每个物品只能取一次，则是01背包问题，否则是完全背包问题。他们两个的区别就在于内存循环背包重量的时候，01背包中需要从后往前进行遍历防止每个物品被重复选择，而重复选择恰好是完全背包所需要的，因此完全背包需要从前往后进行遍历。</p><p>==而对于完全背包问题而言，两个for循环的嵌套顺序是无所谓的==</p><p>先遍历物品再遍历背包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):  <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight[i], bagWeight + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>先遍历背包再遍历物品：</p><p>先遍历背包的时候，需要判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>): <span class="comment"># 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">            dp[j] += dp[j-num]</span><br></pre></td></tr></table></figure><p>==<strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。==</p><p>==<strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。==</p><p>爬楼梯进阶版：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142126656.png" alt="image-20231214212639400"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 背包容量为n, 物品为m</span></span><br><span class="line">dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):<span class="comment"># 遍历物品</span></span><br><span class="line">        dp[j] += dp[j-i]</span><br><span class="line">print(dp[n])</span><br></pre></td></tr></table></figure><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>多重背包的描述如下：</p><p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p><p>多重背包问题可以通过将物品数量大于1个的展开，这样就可以构成01背包问题，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191628062.png" alt="image-20231219162833785"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C为背包容量 N为类型</span></span><br><span class="line">C, N = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># weight = []</span></span><br><span class="line"><span class="comment"># price = []</span></span><br><span class="line"><span class="comment"># nums = []</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">price = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 构造01背包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nums[i] - <span class="number">1</span>):</span><br><span class="line">            weight.append(weight[i])</span><br><span class="line">            price.append(price[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(weight, price)</span></span><br><span class="line"></span><br><span class="line">dp = [<span class="number">0</span>] * (C + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">sum</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + price[i])</span><br><span class="line">print(dp[C])</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="509、斐波那契数列"><a href="#509、斐波那契数列" class="headerlink" title="509、斐波那契数列"></a>509、斐波那契数列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032022036.png" alt="image-20231203202205635"></p><p>递归解法（时间复杂度较高）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fib(n-<span class="number">1</span>)+ self.fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032030416.png" alt="image-20231203203047210"></p><p>动态规划解法</p><p>这里使用滚动数组的方式，定义了初始化值，然后进行递推，由于题目已经给出了递推公式，所以我们直接使用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dpn = dp0+dp1</span><br><span class="line">            dp0 = dp1</span><br><span class="line">            dp1 = dpn</span><br><span class="line">        <span class="keyword">return</span> dpn</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032030644.png" alt="image-20231203203032337"></p><h2 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">70、爬楼梯</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032033253.png" alt="image-20231203203303353"></p><ol><li><p><strong>确定dp数组及其下标含义</strong></p><p>dp[i]：爬到第i层楼梯，有dp[i]种方法</p></li><li><p><strong>确定递推公式</strong></p><p>dp[i]可以从两个方向进行递推</p><ul><li>从dp[i-1]跨 ==<strong>1</strong>== 步即可到达</li><li>从dp[i-2]跨 ==<strong>2</strong>== 步即可到达</li></ul><p>所以dp[i]=dp[i-1]+dp[i-2]，即爬到第i层的方法是爬到第i-1层的方法总数加上爬到第i-2层的方法总数之和。</p></li><li><p><strong>dp数组如何进行初始化</strong></p><p>题目给定了n的范围&gt;=1，初始化的时候只需要从1开始初始化即可</p><p>i=0时，dp[i]=0</p><p>i=1时，dp[1]=1</p><p>i=2时，dp[2]=2</p></li><li><p><strong>确定遍历顺序</strong></p><p>从前往后进行遍历</p></li><li><p><strong>举例推导dp数组</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp1 = <span class="number">1</span></span><br><span class="line">        dp2 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dpn = dp1+dp2</span><br><span class="line">            dp1 = dp2</span><br><span class="line">            dp2 = dpn</span><br><span class="line">        <span class="keyword">return</span> dpn</span><br></pre></td></tr></table></figure><p>本题和斐波那契数列递推公式一样。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032058657.png" alt="image-20231203205804580"></p><h2 id="746、使用最小花费爬楼梯"><a href="#746、使用最小花费爬楼梯" class="headerlink" title="746、使用最小花费爬楼梯"></a>746、使用最小花费爬楼梯</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032100542.png" alt="image-20231203210026019"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032100903.png" alt="image-20231203210050812"></p><ol><li><p><strong>确定dp数组及其下标含义</strong></p><p>dp[i]：爬到第i层的花费</p></li><li><p><strong>确定递推公式</strong></p><p>dp[i]可以从两个方向进行递推</p><ul><li>从dp[i-1]跨一步即可到达 dp[i] = dp[i-1]+cost[i-1]</li><li>从dp[i-2]跨两步即可到达 dp[i] = dp[i-2]+cost[i-2]</li></ul><p>因为需要最小的花销，所以取二者其中的最小值</p><p>dp[i] = min(dp[i-1]+cost[i-1],dp[i-1]+cost[i-2])</p></li><li><p><strong>dp数组如何进行初始化</strong></p><p>i=0时，dp[i]=0</p><p>i=1时，dp[i]=0</p><p>i=2时，dp[i]=2</p></li><li><p><strong>确定遍历顺序</strong></p><p>从前往后进行遍历</p></li><li><p><strong>举例推导dp数组</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp数组表示开销</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(<span class="built_in">len</span>(cost)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(cost)+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>])</span><br><span class="line">            <span class="comment"># print(dp[i])</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[i]</span><br></pre></td></tr></table></figure><h2 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、不同路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312050946038.png" alt="image-20231205094642112"></p><p>动态规划</p><p>从[0][0]到[m][n]共有多少条路径，其中机器人每次只能向下或者向右移动一步。</p><ul><li>确定dp数组</li></ul><p>dp[i][j]表示从0,0出发到i,j共有多少条路径</p><ul><li>确定递推公式</li></ul><p>dp[i][j]只能从其上方或者下方走过来，就可以写成累加的形式，表示可以从dp[i-1][j]这个位置走一步或者从dp[i][j-1]这个位置走一步过来</p><p>==dp[i][j] = dp[i-1][j] + dp[i][j-1]==</p><ul><li>dp数组初始化</li></ul><p>dp[i][0]和dp[0][j]都为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>确定遍历顺序</li></ul><p>都是从上方或者左方推导过来的，从左到右一层一层进行遍历即可</p><ul><li>举例推导dp数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp = [[0]*n]*m</span></span><br><span class="line">        <span class="comment"># 在Python中[[0]*n]*m表示使用相同的行列表示m次 这样实际所有行的引用都指向一个对象 </span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051015104.png" alt="image-20231205101538038"></p><h2 id="63、不同路径II"><a href="#63、不同路径II" class="headerlink" title="63、不同路径II"></a>63、不同路径II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051038974.png" alt="image-20231205102614842"></p><p>本题和上一题的区别就在于地图中有障碍物影响了行走，但是本题只需要保证障碍物的位置处，dp[i][j]始终保持为0即可。</p><ul><li>dp数组含义</li></ul><ul><li>递推公式</li><li>dp数组初始化</li></ul><p>本题在进行初始化的时候需要注意，在碰到障碍物之后，就没有路了，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051037536.png" alt="63.不同路径II"></p><ul><li>确定遍历顺序</li></ul><p>从左到右进行遍历</p><ul><li>举例推导dp数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051037165.png" alt="image-20231205103751967"></p><h2 id="343、整数拆分（-）"><a href="#343、整数拆分（-）" class="headerlink" title="343、整数拆分（*）"></a><a href="https://leetcode.cn/problems/integer-break/description/">343、整数拆分</a>（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051038256.png" alt="image-20231205103826968"></p><ul><li><p>dp数组表示什么含义</p><ul><li>dp[i] 表示i能拆分得到的最大乘积</li></ul></li><li><p>dp数组递推公式</p><ul><li>dp[i]可以由两个方向得到</li><li>j*（i-1)</li><li>j*dp[i-1]</li></ul></li><li><p>dp数组初始化</p><ul><li>dp[0]和dp[1]没有实际意义 题目也说了n&gt;=2</li><li>dp[2] = 1</li><li>循环i从3开始</li></ul></li><li><p>遍历遍历顺序</p><ul><li>从前往后进行遍历</li></ul></li><li><p>举例</p></li></ul><p>注意代码在进行拆分的时候j是从1到i//2+1范围的，python中for循环遍历的范围是前闭后开的所以要加上1，这里可以以4为例，4//2=2，取开区间只能取到1，不符合要求了。</p><p>假设正整数i拆分出来的第一个正整数为j  （1&lt;=j&lt;i）有下面两种方案</p><ul><li>将i拆分乘j和i-j的和，且i-j不再拆分成多个正整数 此时乘积是 *<em>j * (i-j)*</em></li><li>将i拆分成j和i-j的和，且i-j还需拆分成多个正整数 此时乘积是 *<em>j * dp[i-j]*</em></li></ul><p>代码中嵌套的max的外层max是为了防止在内层j为循环变量的循环过程中覆盖掉原本dp[i]</p><p>两层for循环是为了从前往后进行遍历</p><ul><li>外层for的循环变量i从3开始 一直到n+1（开区间）</li><li>内存for的循环变量j从1开始 一直到i//2+1<ul><li>j代表的是数字<code>i</code>可以从1开始进行拆分成j和i-j</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp =[<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># print(i,j)</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*dp[i-j],j*(i-j)))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071144917.png" alt="image-20231207114438394"></p><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;(<span class="keyword">int</span>)i/<span class="number">2</span>+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="96、不同的二叉搜索树（-）"><a href="#96、不同的二叉搜索树（-）" class="headerlink" title="96、不同的二叉搜索树（*）"></a>96、不同的二叉搜索树（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071203005.png" alt="image-20231207120330823"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949898.png" alt="96.不同的二叉搜索树"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949699.png" alt="96.不同的二叉搜索树1"></p><p>dp[3] 表示1-3节点组成的二叉搜索树的个数，可以分成下面三种情况</p><p>元素1作为根结点的数量 = 右子树有2个元素的搜索树的个数 + 左子树有0个元素的搜索树的个数</p><p>元素2作为根节点的数量 = 右子树有1个元素的搜索树的个数 + 左子树有1个元素的搜索树的个数</p><p>元素3作为根节点的数量 = 右子树有0个元素的搜索树的个数 + 左子树有2个元素的搜索树的个数</p><ul><li><h4 id="确定dp数组含义-1"><a href="#确定dp数组含义-1" class="headerlink" title="确定dp数组含义"></a>确定dp数组含义</h4></li></ul><p>dp[i] 表示1到<code>i</code>结点组成的二叉搜索树的个数为dp[i]</p><ul><li><h4 id="确定递推公式-1"><a href="#确定递推公式-1" class="headerlink" title="确定递推公式"></a>确定递推公式</h4></li></ul><p>*<em>dp[i] += dp[j - 1] * dp[i - j];*</em></p><p>j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><p>j相当于是头结点的元素，从1遍历到i结束（题目中说了这个二叉搜索树由n个节点1-n组成）</p><ul><li><h4 id="dp数组如何进行初始化"><a href="#dp数组如何进行初始化" class="headerlink" title="dp数组如何进行初始化"></a>dp数组如何进行初始化</h4></li></ul><p>dp[0] = 1    不能为0 否则在乘法运算中结果就是0了</p><p>空节点的二叉树也是一颗二叉搜索树</p><ul><li><h4 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312072115635.png" alt="image-20231207211554597"></p><h2 id="416、分割等和子集（-）"><a href="#416、分割等和子集（-）" class="headerlink" title="416、分割等和子集（*）"></a>416、分割等和子集（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112023767.png" alt="image-20231211202314677"></p><p>本题需要判断数组中是否能够出现总和为sum/2的子集。这里需要有一个前提条件，如果数组的和为奇数是无法分成两个子集的，只有在数组和为偶数的情况下才能够划分两个子集。</p><p>所以可以根据这个条件先进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line"><span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>转换为01背包问题，每个元素只能放入一次的问题是01背包，如果可以多次放入的话，属于完全背包问题。</p><ul><li>背包的体积为<strong>sum/2</strong>，Python中是sum//2【取整】</li><li>背包放入的商品重量就是元素值，价值也是元素值</li><li>背包如果刚好装满，则找到总和为sum/2的子集</li><li>背包中的每一个元素是不可以重复放入的</li></ul><p>背包容量是多少？本题中背包最大容量为sum//2</p><ul><li><h4 id="dp数组含义-1"><a href="#dp数组含义-1" class="headerlink" title="dp数组含义"></a>dp数组含义</h4></li></ul><p>dp[j]表示容量为j的背包所能背的物品最大价值，这里的价值就是元素对应的值</p><p><strong>本题中每个元素的元素值既是价值又是重量</strong></p><p>dp[j]表示背包总容量是j，放进物品之后背的最大重量为dp[j]</p><p>如果最后的<code>dp[-1] == target</code> 则满足题意</p><ul><li><h4 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h4></li></ul><p>01背包问题中，遍历到某个元素的时候，有两个原则，放与不放，递推公式是一致的。</p><p>dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</p><ul><li><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4></li></ul><p>dp[0] = 0，因为在容量为0的时候是无法放物品的</p><ul><li><h4 id="遍历顺序-2"><a href="#遍历顺序-2" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li></ul><p>外层循环遍历物品，遍历下标从1-n-1【Python范围1-n】，n为物品数量，本题中指数组长度len(nums)</p><p>内存循环遍历重量，遍历下标从target-nums[i]【【Python范围target-nums[i]-1】】，target为背包最大容量</p><p>如何将问题转换为01背包问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 满足条件  背包重量设为 sum_//2</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)  <span class="comment"># 物品数量</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target,nums[i]-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i])</span><br><span class="line">                <span class="keyword">if</span> dp[-<span class="number">1</span>]==target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]==target</span><br></pre></td></tr></table></figure><p>01背包相对于本题，主要要理解，题目中物品是<code>nums[i]</code>，重量是<code>nums[i]</code>，价值也是<code>nums[i]</code>，背包体积是<code>sum//2</code>。</p><p>==本题主要判断的是背包是否能够装满target==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141705462.png" alt="image-20231214170551121"></p><h2 id="1049、最后一块石头的重量II（-）"><a href="#1049、最后一块石头的重量II（-）" class="headerlink" title="1049、最后一块石头的重量II（*）"></a>1049、最后一块石头的重量II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112053463.png" alt="image-20231211205340977"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112054401.png" alt="image-20231211205350848"></p><p>题目含义是：尽量让石头分成重量相等的两堆，相撞之后剩下的石头最小。</p><p>本题中，物品重量为stones[i]，物品价值为stones[i]</p><p>最终需要返回的事剩余石头的最小重量，如果来可以分成相等的两堆，则说明没有返回值为0</p><ul><li><h4 id="dp数组含义是什么？"><a href="#dp数组含义是什么？" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[j]表示容量为j的背包可以背的最大重量是多少</p><ul><li><h4 id="递推公式是什么？"><a href="#递推公式是什么？" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</p><ul><li><h4 id="如何进行初始化？"><a href="#如何进行初始化？" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>背包的最大容量为sum(stones)//2</p><ul><li><h4 id="遍历顺序是什么？"><a href="#遍历顺序是什么？" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层循环遍历背包（即石头数组）</span></span><br><span class="line"><span class="comment"># 内存循环遍历重量</span></span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span>(<span class="params">self, stones: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(stones)</span><br><span class="line">        target = sum_//<span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stones)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target,stones[i]-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i])</span><br><span class="line">                <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> sum_ - dp[target] * <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141726082.png" alt="image-20231214172626040"></p><h2 id="494、目标和（-）"><a href="#494、目标和（-）" class="headerlink" title="494、目标和（*）"></a>494、目标和（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131947748.png" alt="image-20231213194712596"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131947502.png" alt="image-20231213194725271"></p><p>分割等和子集 就是判断背包是否能装满</p><p>最后一块石头的重量II 就是看背包最大能装多少</p><p>本题就是看装满背包我们总共有多少种方式</p><p>本题中有几个先决条件，如果target大于nums数组的总和（当然target可能为负数所以这里加上绝对值），则没有这样的组合方式</p><p>本题中，我们假设全部为正的表达式为left，全部为负的表达式为right，则left+right=target，其中right=sum-left，可以得出left=(sum+target)/2，如果sum+target不为偶数则也没有这样的组合方式。</p><p>这里的背包容量大小是left大小，因为这里只需要计算组合方式，只需要算出left有多少种方式即可</p><p>问题转换为 装满容量为left的背包最多有多少种方法</p><ul><li><h4 id="dp数组含义是什么？-1"><a href="#dp数组含义是什么？-1" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>装满容量为j的背包最多有dp[j]种方法</p><ul><li><h4 id="递推公式是什么？-1"><a href="#递推公式是什么？-1" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[j] += dp[j-nums[i]]</p><ul><li><h4 id="如何进行初始化？-1"><a href="#如何进行初始化？-1" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[0] = 1</p><ul><li><h4 id="遍历顺序是什么？-1"><a href="#遍历顺序是什么？-1" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>背包模板 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target)&gt;sum_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (sum_+target)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        bagSize = (sum_+target)//<span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (bagSize+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bagSize,num-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j]+=dp[j-num]</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141740352.png" alt="image-20231214174054274"></p><h2 id="474、一和零（-）"><a href="#474、一和零（-）" class="headerlink" title="474、一和零（*）"></a>474、一和零（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131948691.png" alt="image-20231213194842864"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131949442.png" alt="image-20231213194906205"></p><p>strs中的元素就是物品，m和n相当于两个背包，二维的01背包。</p><p>题目要求找出strs中的最大子集长度</p><ul><li><h4 id="dp数组含义是什么？-2"><a href="#dp数组含义是什么？-2" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>有两个维度  m代表0  n代表1</p><p>dp[i][j]表示最多有i个0和j个1的strs的最大子集的大小为dp[i][j]</p><ul><li><h4 id="递推公式是什么？-2"><a href="#递推公式是什么？-2" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[i][j]可以由前一个字符串推出</p><p>dp[i][j] = dp[i-zeroNum][j-oneNum] + 1</p><p>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</p><p>递推公式中的==+1==，加的是物品的数量</p><ul><li><h4 id="如何进行初始化？-2"><a href="#如何进行初始化？-2" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>如果物品的价格不会出现负数，就初始化为0即可，保证在后面递推的过程中不会出现覆盖</p><ul><li><h4 id="遍历顺序是什么？-2"><a href="#遍历顺序是什么？-2" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历物品再遍历背包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            zero = s.count(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 计算0的个数</span></span><br><span class="line">            one = <span class="built_in">len</span>(s)-zero    <span class="comment"># 相减得到1的个数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,one-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m,zero-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-one][j-zero]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142003630.png" alt="image-20231214200339571"></p><p>本题是给定背包容量，看装满背包之后有多少物品，求的是最大的物品数量，所以这里在递推公式中+1是加的物品数量</p><h2 id="518、零钱兑换II"><a href="#518、零钱兑换II" class="headerlink" title="518、零钱兑换II"></a>518、零钱兑换II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142039614.png" alt="image-20231214203043800"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 如何转换为完全背包问题 物品是可以重复使用的</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin,amount+<span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142039502.png" alt="image-20231214203913852"></p><h2 id="377、组合总数IV"><a href="#377、组合总数IV" class="headerlink" title="377、组合总数IV"></a>377、组合总数IV</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142113377.png" alt="image-20231214211310288"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142113461.png" alt="image-20231214211325922"></p><p>这里需要注意顺序不同的序列也被看做是不同的组合，所以这属于排列问题。</p><p>对于排列问题，for循环的嵌套顺序就有说法了</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 背包容量为target</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:  <span class="comment"># 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> j&lt;num:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">                    dp[j] += dp[j-num]</span><br><span class="line">                <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142112373.png" alt="image-20231214211254723"></p><h2 id="322、零钱兑换"><a href="#322、零钱兑换" class="headerlink" title="322、零钱兑换"></a>322、零钱兑换</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142140878.png" alt="image-20231214214057266"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080950430.png" alt="image-20231214214109014"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 计算最少的硬币个数</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> j&lt;coin:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount]!=<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="139、单词拆分"><a href="#139、单词拆分" class="headerlink" title="139、单词拆分"></a>139、单词拆分</h2><ul><li><h4 id="dp数组含义是什么？-3"><a href="#dp数组含义是什么？-3" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i] 表示字符串长度为i的话，dp[i]=true，表示可以拆分为一个或多个在字典中出现的单词</p><ul><li><h4 id="递推公式是什么？-3"><a href="#递推公式是什么？-3" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><ul><li><h4 id="如何进行初始化？-3"><a href="#如何进行初始化？-3" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li><li><h4 id="遍历顺序是什么？-3"><a href="#遍历顺序是什么？-3" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><h2 id="198、打家劫舍"><a href="#198、打家劫舍" class="headerlink" title="198、打家劫舍"></a>198、打家劫舍</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191852126.png" alt="image-20231219185241808"></p><p>一层for循环往后进行遍历</p><ul><li><h4 id="dp数组含义是什么？-4"><a href="#dp数组含义是什么？-4" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示当前到第i家的为止，最多可以偷的最大的价值</p><ul><li><h4 id="递推公式是什么？-4"><a href="#递推公式是什么？-4" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4><ul><li><p>偷第i家 dp[i] = dp[i-2]+nums[i]</p></li><li><p>不偷第i家 dp[i] = dp[i-1]</p></li></ul></li><li><h4 id="如何进行初始化？-4"><a href="#如何进行初始化？-4" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4><ul><li><p>第1位dp[0]初始值为nums[0]</p></li><li><p>第2位dp[1]初始值为前两个数字中的最大值</p></li></ul></li><li><h4 id="遍历顺序是什么？-4"><a href="#遍历顺序是什么？-4" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp数组更新方式 前一个偷或者不偷 两种方式  初始化的时候就</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>优化版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 如果没有房屋，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        prev_max = <span class="number">0</span>  <span class="comment"># 上一个房屋的最大金额</span></span><br><span class="line">        curr_max = <span class="number">0</span>  <span class="comment"># 当前房屋的最大金额</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            temp = curr_max  <span class="comment"># 临时变量保存当前房屋的最大金额</span></span><br><span class="line">            curr_max = <span class="built_in">max</span>(prev_max + num, curr_max)  <span class="comment"># 更新当前房屋的最大金额</span></span><br><span class="line">            prev_max = temp  <span class="comment"># 更新上一个房屋的最大金额</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr_max  <span class="comment"># 返回最后一个房屋中可抢劫的最大金额</span></span><br></pre></td></tr></table></figure><h2 id="213、打家劫舍II"><a href="#213、打家劫舍II" class="headerlink" title="213、打家劫舍II"></a>213、打家劫舍II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191907068.png" alt="image-20231219190730068"></p><p>本题的关键在于如何处理==<strong>圆环问题</strong>==，可以将1-n分成1-n-1和2-n这两个区间，然后在对应的区间使用打家劫舍中的方法去找到最大值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1-n-1 和2-n</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        nums1 = nums[:n-<span class="number">1</span>]</span><br><span class="line">        nums2 = nums[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># print(nums2)</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        dp1 = [<span class="number">0</span>]*n1</span><br><span class="line">        dp1[<span class="number">0</span>] = nums1[<span class="number">0</span>]</span><br><span class="line">        dp1[<span class="number">1</span>] = <span class="built_in">max</span>(nums1[<span class="number">0</span>],nums1[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n1):</span><br><span class="line">            dp1[i] = <span class="built_in">max</span>(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums1[i])</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp2 = [<span class="number">0</span>]*n2</span><br><span class="line">        dp2[<span class="number">0</span>] = nums2[<span class="number">0</span>]</span><br><span class="line">        dp2[<span class="number">1</span>] = <span class="built_in">max</span>(nums2[<span class="number">0</span>],nums2[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n2):</span><br><span class="line">            dp2[i] = <span class="built_in">max</span>(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums2[i])</span><br><span class="line">        <span class="comment"># print(dp1,dp2)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[n1-<span class="number">1</span>],dp2[n2-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 优化重复代码</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">robHouse</span>(<span class="params">nums</span>):</span></span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            pre_max = <span class="number">0</span></span><br><span class="line">            cur_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                tmp = cur_max</span><br><span class="line">                cur_max = <span class="built_in">max</span>(pre_max+num,cur_max)</span><br><span class="line">                pre_max = tmp</span><br><span class="line">            <span class="keyword">return</span> cur_max</span><br><span class="line">        <span class="comment"># 1-n-1 和2-n</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># elif n==2:</span></span><br><span class="line">        <span class="comment">#     return max(nums)</span></span><br><span class="line">        nums1 = nums[:n-<span class="number">1</span>]</span><br><span class="line">        nums2 = nums[<span class="number">1</span>:]</span><br><span class="line">        dp1 = robHouse(nums1)</span><br><span class="line">        <span class="comment"># print(dp1)</span></span><br><span class="line">        dp2 = robHouse(nums2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1,dp2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191907170.png" alt="image-20231219190719927"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201142738.png" alt="image-20231220114200545"></p><h2 id="337、打家劫舍III"><a href="#337、打家劫舍III" class="headerlink" title="337、打家劫舍III"></a>337、打家劫舍III</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201143760.png" alt="image-20231220114356451"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201144470.png" alt="image-20231220114414309"></p><p>本题可以使用暴力算法进行求解，但求解的时候需要使用到<strong>后序遍历</strong></p><p>动态规划解法：</p><p>dp数组表示的含义 下标为0表示不偷该节点得到的最大金钱，下标为1表示偷该节点得到的最大金钱</p><p><strong>dp数组是一个长度为2的数组</strong></p><p>递归三部曲</p><ul><li><h4 id="确定递归的参数和返回值"><a href="#确定递归的参数和返回值" class="headerlink" title="确定递归的参数和返回值"></a>确定递归的参数和返回值</h4></li></ul><p>递归的参数是当前所遍历到的节点</p><p>返回值是长度为2的dp数组</p><ul><li><h4 id="确定终止条件"><a href="#确定终止条件" class="headerlink" title="确定终止条件"></a>确定终止条件</h4></li></ul><p>如果遍历到空节点，则返回{0,0}</p><p>这也相当于dp数组的初始化</p><ul><li><h4 id="确定遍历顺序-1"><a href="#确定遍历顺序-1" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4></li></ul><p>后序遍历</p><p>通过递归左节点获得左节点偷与不偷的金钱</p><p>通过递归右节点获得右节点偷与不偷的金钱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 下标<span class="number">0</span>：不偷，下标<span class="number">1</span>：偷</span><br><span class="line">left = robTree(cur.left) // 左</span><br><span class="line">right = robTree(cur.right) // 右</span><br><span class="line">// 中</span><br></pre></td></tr></table></figure><ul><li><h4 id="单层递归逻辑"><a href="#单层递归逻辑" class="headerlink" title="单层递归逻辑"></a>单层递归逻辑</h4></li></ul><p>如果偷当前结点的话，左右孩子结点就不能偷</p><p>val1 = cur.val + left[0] + right[0]</p><p>如果不偷当前结点的话，左右孩子结点就可以偷</p><p>val2 = max(left[0],left[1])+max(right[0], right[1])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            left = traverse(node.left)</span><br><span class="line">            right = traverse(node.right)</span><br><span class="line">            <span class="comment"># 不偷当前节点</span></span><br><span class="line">            val1 = <span class="built_in">max</span>(left[<span class="number">0</span>],left[<span class="number">1</span>])+<span class="built_in">max</span>(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 偷当前节点</span></span><br><span class="line">            val2 = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> [val1,val2]</span><br><span class="line">        dp = traverse(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312220943201.png" alt="image-20231222094326982"></p><h2 id="121、买卖股票的最佳时机（-）"><a href="#121、买卖股票的最佳时机（-）" class="headerlink" title="121、买卖股票的最佳时机（*）"></a>121、买卖股票的最佳时机（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312220946679.png" alt="image-20231222094618700"></p><p>贪心算法</p><p>贪心算法的思路就是<strong>取左边的最小值</strong>，然后每次计算当前值与当前最小值的差值，然后再取差值和res本身的最大值作为res值，直到循环结束，即得出最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 贪心算法  左边最小 右边最大</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_ = <span class="built_in">min</span>(min_,p)</span><br><span class="line">            res = <span class="built_in">max</span>(res,p-min_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>动态规划</p><ul><li><h4 id="dp数组含义是什么？-5"><a href="#dp数组含义是什么？-5" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>和打家劫舍III一样，本题中的dp数组只有两列，所代表的含义如下：   二维dp数组</p><p>dp[i][0]表示第<code>i</code>天持有股票所得最多现金</p><p>dp[i][1]表示第<code>i</code>天不再持有股票最多现金</p><ul><li><h4 id="递推公式是什么？-5"><a href="#递推公式是什么？-5" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[i][0]表示如果第i天持有股票，可以由两个状态推导出来：</p><ul><li><p>第i-1天就持有股票，则维持现状，即dp[i-1][0]</p></li><li><p>第i-1天没有持有股票，第i天需要买入，所得现金就是买入今天股票的现金：==-price[i]==</p></li></ul><p>那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);</p><p>dp[i][1]表示：第i天不再持有股票，可以由两个状态推导出来：</p><ul><li>第i-1天已经出售股票，维持现状，dp[i][1] = dp[i-1][1]</li><li>第i天出售股票，就按照今天的价格卖出股票后得到的现金，也就是第i-1天持有股票的现金加上i天卖出股票的价格，dp[i][1] = dp[i-1][0]+prices[i]    </li></ul><p>dp[i][1]也应该选择现金大的，所以dp[i][1] = max(dp[i - 1][1], dp[i-1][0]+prices[i]); </p><ul><li><h4 id="如何进行初始化？-5"><a href="#如何进行初始化？-5" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化的时候，dp[0][0]=-prices[0]表示第0天持有股票的现金，dp[0][1] = 0，股票还没卖所以为0</p><ul><li><h4 id="遍历顺序是什么？-5"><a href="#遍历顺序是什么？-5" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>因为后面的状态依赖于前面的状态，所以便利的顺序是从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用滚动数组来节省空间（上面的二维数组其实有很多空间都是浪费的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp0 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0, -prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312221610187.png" alt="image-20231222161015785"></p><h2 id="122、买卖股票的最佳时机II（-）"><a href="#122、买卖股票的最佳时机II（-）" class="headerlink" title="122、买卖股票的最佳时机II（*）"></a>122、买卖股票的最佳时机II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312221611651.png" alt="image-20231222161107215"></p><p>这道题在贪心算法章节已经使用贪心算法解决问题，贪心算法的核心思想就是将差值中的正值作为利润累加起来，出现负值则不作更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 贪心算法</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            res += <span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这里使用动态规划进行求解</p><p>本题中的股票是可以多次买入和出售的，在第i天买入股票的时候，所持有的现金可能会包含之前买卖过的利润。</p><p>第i天如果买入股票，所的现金就是昨天不持有股票所得的现金今天的股票价格</p><p>dp[i-1][0] - prices[i]</p><p>本题可以多次进行股票的买卖，但是最多持有一只股票</p><ul><li><h4 id="dp数组含义是什么？-6"><a href="#dp数组含义是什么？-6" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp数组的含义与上一题一致</p><p>dp[i][0]表示第<code>i</code>天持有股票的最多现金</p><p>dp[i][1]表示第<code>i</code>天不持有股票所得最多现金</p><ul><li><h4 id="递推公式是什么？-6"><a href="#递推公式是什么？-6" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>**==dp[i][0] 如果在第i天买入股票，所得现金就是昨天不持有股票的金额减去今天股票的价格==**（这是本题的核心）</p><p>在上一个问题中，买入股票的时候因为只能进行一次交易，所以等价于用0-prices[i]，而在本题中实际上是用第i-1天手中不持有现金的情况下减去今天的股票价格，就是当前持有股票的现金。</p><p>dp[i][0] = max(dp[i-1][1], dp[i-1][0]-prices[i])</p><p>dp[i][1]的递推公式同上题 从两个状态得出，第i-1天就不持有股票以及第i天卖出股票即前一天持有股票拥有的最大现金加上当天的股票价格</p><p>dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</p><ul><li><h4 id="如何进行初始化？-6"><a href="#如何进行初始化？-6" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[0][0]表示持有股票拥有的现金 初始化为-prices[0]</p><p>dp[0][1]表示不持有股票拥有的现金 初始化为0  即一开始啥都没有</p><ul><li><h4 id="遍历顺序是什么？-6"><a href="#遍历顺序是什么？-6" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用滚动数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用滚动数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp0 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0,dp1-prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1,dp0+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080948042.png" alt="image-20231222165532772"></p><h2 id="123、买卖股票的最佳时机III（-）"><a href="#123、买卖股票的最佳时机III（-）" class="headerlink" title="123、买卖股票的最佳时机III（*）"></a>123、买卖股票的最佳时机III（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949668.png" alt="image-20240102210539304"></p><p> 题目中说了最多可以完成两笔交易，即可以只交易一次，或者交易两次</p><p>同时不能同时参与多笔交易，即最多手里只能有持有一次股票</p><ul><li><h4 id="dp数组含义是什么？-7"><a href="#dp数组含义是什么？-7" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>共有五个状态：尚未进行操作的状态、第一次持有股票、第一次卖出股票、第二次持有股票、第二次卖出股票</p><p>dp[i][0]-dp[i][4] 分别表示</p><table><thead><tr><th align="center">下标</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">dp[i][0]</td><td align="center">不进行操作持有的最大现金（该状态不设置也可以）</td></tr><tr><td align="center">dp[i][1]</td><td align="center">第一次持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][2]</td><td align="center">第一次不再持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][3]</td><td align="center">第二次持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][4]</td><td align="center">第二次不再持有股票拥有的最大现金</td></tr></tbody></table><p>dp[i][j] 表示第i天在状态j下所拥有的最大现金</p><ul><li><h4 id="递推公式是什么？-7"><a href="#递推公式是什么？-7" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[i][1]可以从两个方面推导出来：</p><p>第i天买入股票，dp[i][1] = dp[i-1][0] - prices[i]</p><p>第i天没有操作（即第i-1天已经持有股票了），dp[i][1] = dp[i-1][1]</p><p>根据上一题的经验，我们需要在这两者中选取最大值，即dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</p><p>dp[i][2] 表示第i天第一次不再持有股票拥有的最大现金，同样可以从两个方向推导：</p><p>第i天卖出股票，dp[i][2] = dp[i-1][1] + prices[i]</p><p>第i-1天卖出股票，dp[i][2] = dp[i-1][2]</p><p>dp[i][2] = max(dp[i-1][1]+prices[i],dp[i-1][2])</p><p>同理当j=3和j=4的时候的递推公式如下</p><p>dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i])</p><p>dp[i][4] = max(dp[i-1][4], dp[i-1][3]+prices[i])</p><ul><li><h4 id="如何进行初始化？-7"><a href="#如何进行初始化？-7" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;</p><p>第0天做第一次买入的操作，dp[0][1] = -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0][3] = -prices[0];</p><p>同理第二次卖出初始化dp[0][4] = 0;</p><ul><li><h4 id="递推公式是什么？-8"><a href="#递推公式是什么？-8" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li><li><h4 id="如何进行初始化？-8"><a href="#如何进行初始化？-8" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li><li><h4 id="遍历顺序是什么？-7"><a href="#遍历顺序是什么？-7" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>以输入[1,2,3,4,5]为例</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401112212116.png" alt="123.买卖股票的最佳时机III"></p><p>最后我们应该选择第二次卖出股票持有的最大现金作为我们的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 五个状态 0 1 2 3 4分别表示</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用滚动数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 4个状态0、1、2、3分别表示</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,-prices[<span class="number">0</span>],<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>],-prices[i])</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+prices[i])</span><br><span class="line">            dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">            dp[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>],dp[<span class="number">2</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121055714.png" alt="image-20240112105500207"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121059960.png" alt="image-20240112105938758"></p><h2 id="188、买卖股票的最佳时机IV（-）"><a href="#188、买卖股票的最佳时机IV（-）" class="headerlink" title="188、买卖股票的最佳时机IV（*）"></a>188、买卖股票的最佳时机IV（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121057284.png" alt="image-20240112105746724"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121057256.png" alt="image-20240112105757067"></p><ul><li><h4 id="dp数组含义是什么？-8"><a href="#dp数组含义是什么？-8" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>0表示不操作</p><p>1表示第一次买入股票持有的最大现金</p><p>2表示第一次卖出股票持有的最大现金</p><p>3表示第二次买入股票持有的最大现金</p><p>4表示第二次卖出股票持有的最大现金</p><p>以此类推，即i为奇数表示买入股票持有的最大现金，i为偶数表示卖出股票持有的最大现金</p><ul><li><h4 id="递推公式是什么？-9"><a href="#递推公式是什么？-9" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>用for循环代替掉上一题的最多两次买卖，也就是说上一题中最多两次买卖其实本质上也就是本题中k=2</p><ul><li><h4 id="如何进行初始化？-9"><a href="#如何进行初始化？-9" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>在进行初始化的时候，只需要设置</p><ul><li><h4 id="遍历顺序是什么？-8"><a href="#遍历顺序是什么？-8" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(<span class="number">2</span>*k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 奇数买入 偶数卖出</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>*k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="comment"># 对dp数组进行递推</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):  <span class="comment"># 股票价格</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k*<span class="number">2</span>+<span class="number">1</span>):  <span class="comment"># 第k次买入卖出</span></span><br><span class="line">                <span class="keyword">if</span> j%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121129234.png" alt="image-20240112112920032"></p><h2 id="309、买卖股票的最佳时机含冷冻期"><a href="#309、买卖股票的最佳时机含冷冻期" class="headerlink" title="309、买卖股票的最佳时机含冷冻期"></a>309、买卖股票的最佳时机含冷冻期</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121133995.png" alt="image-20240112113340008"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121133998.png" alt="image-20240112113350820"></p><p>本题和之前的区别==卖出股票之后==，无法再第二天立即购买股票（中间有一个冷冻期1天）</p><p>确认共计多少种状态：</p><ul><li>状态1：持有股票状态（今天买入股票或者前几天就已经持有股票了）</li><li>不持有股票的状态（分成两种情况）<ul><li>状态2：保持卖出股票的状态（两天之前就已经卖出股票了并且度过了一天的冷冻期。或者前一天就卖出股票一直没有操作） 区别于冷冻期，即非冷冻期</li><li>状态3：今天卖出股票</li></ul></li><li>状态4：今天为冷冻期，冷冻期只有一天，冷冻期进行单独处理</li></ul><p>这里状态对应数组的下标为0123</p><ul><li><h4 id="dp数组含义是什么？-9"><a href="#dp数组含义是什么？-9" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j] 其中i表示第几天，j表示状态（即状态1-状态4）</p><ul><li><h4 id="递推公式是什么？-10"><a href="#递推公式是什么？-10" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>对于==<strong>状态1</strong>==，即dp[i][0]，表示持有股票状态</p><p>其值涉及到两个操作</p><p>操作1：前一天就已经持有股票了，dp[i][0] = dp[i-1][0]</p><p>操作2：今天买入股票 </p><ul><li>前一天是冷静期 dp[i][0] = dp[i-1][3] - prices[i]</li><li>前一天是保持卖出股票状态  dp[i][0] =dp[i-1][1] -prices[i]</li></ul><p>所以dp[i][0] = max(dp[i-1][0], dp[i][0] = dp[i-1][0], dp[i-1][1] -prices[i])</p><p>对于==<strong>状态2</strong>==，即dp[i][1]  表示保持卖出股票的状态</p><ul><li>前一天为冷冻期 dp[i][1] =  dp[i-1][3]</li><li>仍然是保持卖出股票状态dp[i][1] = dp[i-1][1]</li></ul><p>dp[i][1] = max(dp[i-1][1], dp[i-1][3])</p><p>对于==<strong>状态3</strong>==，即dp[i][2]  表示今天卖出股票的状态</p><p>可以从1个方向推导出来 即前一天持有股票</p><p>dp[i][2] = dp[i-1][0] + prices[i]</p><p>对于==<strong>状态4</strong>==，即dp[i][3] 表示今天是冷冻期，即前一天刚卖出股票</p><p>dp[i][3] = dp[i-1][2]</p><ul><li><h4 id="如何进行初始化？-10"><a href="#如何进行初始化？-10" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>对于第0天，如果是持有股票状态即当天买入股票</p><p>如果是保持卖出股票状态，dp[0][1] = 0</p><p>如果是今天卖出股票状态</p><ul><li><h4 id="遍历顺序是什么？-9"><a href="#遍历顺序是什么？-9" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>后面的状态依赖于前面的状态，因此需要从前往后进行遍历</p><p>使用二维数组的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态 ①前一天就持有 ②前一天为冷冻期购入 ③前一天是不持有股票状态购入</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：不持有股票状态 （区别于冷冻期 表示2天前卖出股票或者更久）</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票状态 前一天持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i-<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>使用一维数组的错误版本：在下面这份代码中，有个错误就是在状态3（下标为2）和状态4（下标为3）的时候，使用的dp[0]和dp[2]已经被修改成本轮的最新值了，而实际上我们应该使用尚未修改的版本，因此需要使用两个变量来记录之前的dp[0]和dp[2]就可以得到正确的结果了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态</span></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">3</span>]-prices[i],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：保持卖出股票状态</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>],dp[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票</span></span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态</span></span><br><span class="line">            tmp_dp0 = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">3</span>]-prices[i],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：保持卖出股票状态</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>],dp[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票</span></span><br><span class="line">            tmp_dp2 = dp[<span class="number">2</span>]</span><br><span class="line">            dp[<span class="number">2</span>] = tmp_dp0+prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[<span class="number">3</span>] = tmp_dp2</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131319093.png" alt="image-20240113131915634"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320924.png" alt="image-20240113132000021"></p><h2 id="714、买卖股票的最佳时机含手续费"><a href="#714、买卖股票的最佳时机含手续费" class="headerlink" title="714、买卖股票的最佳时机含手续费"></a>714、买卖股票的最佳时机含手续费</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320533.png" alt="image-20240113132038334"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320242.png" alt="image-20240113132052422"></p><p>本题与买卖股票的最佳时机II的区别就在于每次在进行卖出股票的时候需要一笔手续费，所以只需要在交易的时候减去fee即可，其余的内容不需要做任何修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 动态规划（滚动数组）</span></span><br><span class="line">        dp0 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 持有股票的最大现金</span></span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0,dp1-prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1,dp0+prices[i]-fee)</span><br><span class="line">        <span class="keyword">return</span> dp1</span><br></pre></td></tr></table></figure><h2 id="300、最长递增子序列"><a href="#300、最长递增子序列" class="headerlink" title="300、最长递增子序列"></a>300、最长递增子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131344403.png" alt="image-20240113134442405"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131344874.png" alt="image-20240113134456062"></p><p>在回溯算法章节，有一题==<strong>递增子序列</strong>==的题目，但是的相关题目中有本题，我也尝试采用回溯算法解决该题，测试用例AC了，但是全部测试用例超时了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startindex, path</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> startindex&gt;<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;=<span class="number">1</span>:</span><br><span class="line">                res=<span class="built_in">max</span>(res,<span class="built_in">len</span>(path))</span><br><span class="line">            uset = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> (path <span class="keyword">and</span> path[-<span class="number">1</span>]&gt;=nums[i]) <span class="keyword">or</span> nums[i] <span class="keyword">in</span> uset:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                uset.add(nums[i])</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题实际上应该采用动态规划算法进行求解。</p><p>这里的递增子序列的含义就是说可以从这个数组中抽出来一些数字组成一个递增的子序列即可。不要求这个子序列一定是连续的</p><p>对于子序列问题，我们通常是可以采用动态规划来解决的</p><ul><li><h4 id="dp数组含义是什么？-10"><a href="#dp数组含义是什么？-10" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示下标i之前包括<code>i</code>在内的以nums[i]结尾的最长递增子序列的长度</p><ul><li><h4 id="递推公式是什么？-11"><a href="#递推公式是什么？-11" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>位置<code>i</code>的最长上升子序列等于j从0到i-1各个位置上的最长上升子序列+1的最大值。只有在值递增的情况下才会进行最大值的更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[j]):</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在进行比较的时候需要和前面所有的进行对比，也就是要取<code>0</code>到<code>i-1</code>中的全部最大值</p><ul><li><h4 id="如何进行初始化？-11"><a href="#如何进行初始化？-11" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[i]的初始值大小至少都是1，所以初始化一个全为1的一维数组即可，数组长度为<code>n</code>，如果全部初始化为0的话，会导致最终结果不对，初始化为1的含义也表示从当前下标nums[i]为结尾的递增子序列长度为1</p><ul><li><h4 id="遍历顺序是什么？-10"><a href="#遍历顺序是什么？-10" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>dp[i] 是0到i-1各个位置的最长递增子序列推导出来的，所以从前往后进行遍历</p><p>j从0遍历到i-1，遍历i在外层循环，遍历j在内层循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141242422.png" alt="image-20240114124246835"></p><h2 id="674、最长连续递增序列"><a href="#674、最长连续递增序列" class="headerlink" title="674、最长连续递增序列"></a>674、最长连续递增序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141244981.png" alt="image-20240114124444735"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141245538.png" alt="image-20240114124459176"></p><p>这题与上一题的区别就在于要求这个序列必须在原来的数组中是<strong>连续</strong>的。连续的情况下，子序列只跟前一个状态有关。如果是不连续的话，状态就会跟前面的最大值有关（即前i-1个状态）</p><ul><li><h4 id="dp数组含义是什么？-11"><a href="#dp数组含义是什么？-11" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示下标i之前包括i在内的以nums[i]结尾的最长递增子序列的长度</p><ul><li><h4 id="递推公式是什么？-12"><a href="#递推公式是什么？-12" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>这里的区别就是，如果出现隔断了，那么就需要重置临时的最大长度为1重新进行统计</p><p>本题不需要进行两层循环，一层循环即可，如果nums[i] &gt; nums[i-1] 那么dp[i] = dp[i-1]+1，否则dp[i] = 1</p><ul><li><h4 id="如何进行初始化？-12"><a href="#如何进行初始化？-12" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>跟上一题一样，初始化都为1。表示从自己开始的话最长连续子序列为1</p><ul><li><h4 id="遍历顺序是什么？-11"><a href="#遍历顺序是什么？-11" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>后面的状态依赖于前面的，所以是从前往后进行遍历，因为这里下标处理的时候涉及到<code>i-1</code>，所以需要从1开始进行循环，到<code>len(nums)</code>为止</p><p>方法1: 贪心算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 用来记录最大值</span></span><br><span class="line">        tmp = <span class="number">1</span>  <span class="comment"># 临时变量 如果出现不连续的情况tmp重置为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">1</span>  <span class="comment"># 重新开始进行计算</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141305663.png" alt="image-20240114130517584"></p><h2 id="718、最长重复子数组"><a href="#718、最长重复子数组" class="headerlink" title="718、最长重复子数组"></a>718、最长重复子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141420532.png" alt="image-20240114142007244"></p><p>本题的含义就是找出两个数组中重复部分的最大长度，数组子序列的问题，采用动态规划算法进行求解。本题中的子数组是要求<strong>连续</strong>的</p><ul><li><h4 id="dp数组含义是什么？-12"><a href="#dp数组含义是什么？-12" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示nums1数组下标<code>1</code>到<code>i-1</code>和nums2数组下标<code>1</code>到<code>j-1</code>的重复部分的最大长度（必须是连续的）</p><ul><li><h4 id="递推公式是什么？-13"><a href="#递推公式是什么？-13" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>本题中，dp[i][j]只能通过其状态的左上方的值获取，即dp[i][j] = dp[i-1][j-1] + 1   这里为什么只能从左上方递推过来？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="如何进行初始化？-13"><a href="#如何进行初始化？-13" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><ul><li><h4 id="遍历顺序是什么？-12"><a href="#遍历顺序是什么？-12" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历nums1后遍历num2，其实顺序是无所谓的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401142120937.jpg" alt="718.最长重复子数组"></p><p>二维DP代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题中所有的状态都是从左上角推导出来的，因此可以进行状态压缩，同时其中只保存一个数据，不会发生覆盖的情况。另外需要注意，如果nums2依旧从前往后进行遍历的时候可能会因为过程中的更新导致答案错误，所以nums2需要从后往前进行遍历。</p><p>这里需要注意的是，最大值的答案很可能是在遍历过程中产生的，后续会将其进行覆盖，所以需要在比较的过程中记录下最大值最终返回</p><p>一维DP代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 创建一个一维数组 dp，用于存储最长公共子数组的长度</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums2) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 记录最长公共子数组的长度</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历数组 nums1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums1) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 用于保存上一个位置的值</span></span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历数组 nums2</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums2) + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 保存当前位置的值，因为会在后面被更新</span></span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="comment"># 如果 nums1[i-1] 和 nums2[j-1] 相等</span></span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 在当前位置上的最长公共子数组长度为上一个位置的长度加一</span></span><br><span class="line">                    dp[j] = prev + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新最长公共子数组的长度</span></span><br><span class="line">                    result = <span class="built_in">max</span>(result,dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不相等，将当前位置的值置为零</span></span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 更新 prev 变量为当前位置的值，供下一次迭代使用</span></span><br><span class="line">                prev = current</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最长公共子数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="number">1</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res,dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                prev = current</span><br><span class="line">            <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401142153127.png" alt="image-20240114215344867"></p><p>拓展</p><p>本题我们下标统一规定了从1开始，这样的目的是方便我们进行后续的递推，省去了一步初始化的步骤。如果需要从0开始，就需要对第一行和第一列进行特殊的初始化，这样比较麻烦。相等的地方需要赋值为1。</p><h2 id="114、最长公共子序列"><a href="#114、最长公共子序列" class="headerlink" title="114、最长公共子序列"></a>114、最长公共子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141331637.png" alt="image-20240114133105420"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141331863.png" alt="image-20240114133119498"></p><p>本题与上一题最长重复子数组的区别就在于，这里不需要连续，只需要是==相对连续==的即可</p><ul><li><h4 id="dp数组含义是什么？-13"><a href="#dp数组含义是什么？-13" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]   表示字符串text1下标从0到<code>i-1</code>和字符串text2下标从0到<code>j-1</code>的最长公共子序列的长度</p><ul><li><h4 id="递推公式是什么？-14"><a href="#递推公式是什么？-14" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>从三个方向递推过来</p><p>如果text1[i-1]和text2[j-1]相等，则dp[i][j]=dp[i-1][j-1] + 1 在二维dp中可以看做是从左上角递推过来的</p><p>如果两者不相等，则需要考虑从其左侧或者正上方递推过来。即dp[i][j] = max(dp[i][j-1], dp[i-1][j])</p><p>不相等的情况是使用前面字符的最长公共子序列  假装删除其中一个字符 可以是i-1位置的也可能是j-1位置上的</p><ul><li><h4 id="如何进行初始化？-14"><a href="#如何进行初始化？-14" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化为0</p><ul><li><h4 id="遍历顺序是什么？-13"><a href="#遍历顺序是什么？-13" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历，总共有三个方向可以推导出dp[i][j]</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141510074.jpg" alt="1143.最长公共子序列"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        t1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        t2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(t2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t1+<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141512224.png" alt="image-20240114151211048"></p><p>一维dp数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        t1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        t2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(t2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t1+<span class="number">1</span>):</span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t2+<span class="number">1</span>):</span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="comment"># print(current)</span></span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="number">1</span>  <span class="comment"># 0+1   保留上一行的值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-<span class="number">1</span>])</span><br><span class="line">                prev = current</span><br><span class="line">            <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161041397.png" alt="image-20240116104126073"></p><h2 id="1035、不相交的线"><a href="#1035、不相交的线" class="headerlink" title="1035、不相交的线"></a>1035、不相交的线</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151638482.png" alt="image-20240115163854290"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151639706.png" alt="image-20240115163909055"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151639145.png" alt="image-20240115163922980"></p><p>本题的本质和最长公共子序列是一样的，代码可以原封不动不做修改，仅需修改变量</p><p>题目给出的连线的条件是nums1[i-1]==nums2[j-1]则可以进行连线，必须要保持相对的顺序，否则会出现线的交叉导致出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxUncrossedLines</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151640625.png" alt="image-20240115164012706"></p><h2 id="53、最大子数组和"><a href="#53、最大子数组和" class="headerlink" title="53、最大子数组和"></a>53、最大子数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151735038.png" alt="image-20240115173510067"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151735949.png" alt="image-20240115173520886"></p><p>法一：贪心算法</p><p>贪心的思路就是不断进行累加，如果出现负值了，就重新开始记数，同时在每一轮进行最大值的更新，出现比当前最大值大了才进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tmp+=num</span><br><span class="line">            res = <span class="built_in">max</span>(res,tmp)</span><br><span class="line">            <span class="keyword">if</span> tmp&lt;<span class="number">0</span>:</span><br><span class="line">                tmp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>法二：动态规划</p><p>动规五部曲：</p><ul><li><h4 id="dp数组含义是什么？-14"><a href="#dp数组含义是什么？-14" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示到当前下标i位置的最大子数组和是多少</p><ul><li><h4 id="递推公式是什么？-15"><a href="#递推公式是什么？-15" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>有两个方向可以推导出最终结果</p><p>一个是dp[i-1]+nums[i]  表示当前值和前面的累加</p><p>一个是当前值大于前面值的累加和，赋值为nums[i]</p><ul><li><h4 id="如何进行初始化？-15"><a href="#如何进行初始化？-15" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>将dp[0]赋值为nums[0]即可</p><ul><li><h4 id="遍历顺序是什么？-14"><a href="#遍历顺序是什么？-14" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 两个状态   累加前面的和或者当前值从新开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><h2 id="392、判断子序列"><a href="#392、判断子序列" class="headerlink" title="392、判断子序列"></a>392、判断子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152127112.png" alt="image-20240115212747069"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152128613.png" alt="image-20240115212801437"></p><p>解法一：双指针法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 使用双指针来解决</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s_ = t_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s_ &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> t_ &lt; <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[s_]==t[t_]:</span><br><span class="line">                s_+=<span class="number">1</span></span><br><span class="line">            t_+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s_ == <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><p>解法二：动态规划</p><p>本题中只需要考虑删除元素的情况，不需要考虑添加元素的情况因此还是比较简单的 【编辑距离的入门题目】</p><p>只需要判断二者的公共子序列长度是否为s的长度即可</p><ul><li><h4 id="dp数组含义是什么？-15"><a href="#dp数组含义是什么？-15" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示以下标为<code>i-1</code>为结尾的字符串s，和以下标为<code>j-1</code>结尾的字符串t，相同子序列的长度</p><ul><li><h4 id="递推公式是什么？-16"><a href="#递推公式是什么？-16" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>分为两种情况：</p><p>一、s[i-1]==t[j-1]   即t中找到了一个字符在s中出现了</p><p>二、s[i-1]!=t[j-1]    相当于t要删除元素，并继续进行匹配</p><p>对于情况一，dp[i][j] = dp[i-1][j-1] + 1  找到了相同子序列 长度加1</p><p>对于情况二，dp[i][j] = dp[i][j-1]     ==删掉一个字符串==</p><ul><li><h4 id="如何进行初始化？-16"><a href="#如何进行初始化？-16" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化还和之前一样赋值为0即可</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161057463.png" alt="392.判断子序列"></p><ul><li><h4 id="遍历顺序是什么？-15"><a href="#遍历顺序是什么？-15" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161058636.jpg" alt="392.判断子序列1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> n1==dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="115、不同的子序列"><a href="#115、不同的子序列" class="headerlink" title="115、不同的子序列(*)"></a>115、不同的子序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152149493.png" alt="image-20240115214907337"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152149120.png" alt="image-20240115214922997"></p><ul><li><h4 id="dp数组含义是什么？-16"><a href="#dp数组含义是什么？-16" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]的含义是字符串s以<code>i-1</code>结尾的子序列出现在以<code>j-1</code>为结尾的字符串t的个数为dp[i][j] </p><ul><li><h4 id="递推公式是什么？-17"><a href="#递推公式是什么？-17" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>这里的递推公式是这样的（分为两种情况）：</p><p>如果两个字符相等 则，dp[i][j]由两个部分组成：<strong>dp[i-1][j-1]</strong> 和 <strong>dp[i-1][j]</strong>   </p><p>dp[i-1][j-1]表示使用s[i-1]和t[j-1]进行比较或者不使用s[i-1]而使用s[i-2]进行比较</p><p>模拟把这个s[i-1]这个元素给删除了</p><p>如果s[i-1]和t[j-1]相等，dp[i][j] = dp[i-1][j-1] + dp[i-1][j]  前一个有多少种方式+s删掉s[i-1]这个字符再进行比较出现的次数。因为题目问的是s的子序列中有多少个t，所以t不需要删除元素而s可以删除</p><p>如果s[i-1]和t[j-1]不相等，dp[i][j] = dp[i-1][j]，表示删除s中的j-1字符，用s[i-2]进行比较</p><ul><li><h4 id="如何进行初始化？-17"><a href="#如何进行初始化？-17" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>在dp数组初始化的时候我们赋值为全0数组</p><p>但是在j=0的时候，也就是t为空字符串的时候，s删除所有的字符就可以构成t了，此时dp[i][0]=1，即有s有一个子字符串为t</p><ul><li><h4 id="遍历顺序是什么？-16"><a href="#遍历顺序是什么？-16" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历，但是需要注意，需要保证j大于1。有递推公式可以得出dp[i][j]是从左上方和正上方推出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181251366.png" alt="img"></p><ul><li><h4 id="距离推导dp数组"><a href="#距离推导dp数组" class="headerlink" title="距离推导dp数组"></a>距离推导dp数组</h4></li></ul><p>以s：”baegg”，t：”bag”为例，推导dp数组状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181251573.jpg" alt="115.不同的子序列"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 模拟删除字符串s[i-1] 用s[i-2]进行比较</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401191112796.png" alt="image-20240119111203386"></p><h2 id="583、两个字符串的删除操作"><a href="#583、两个字符串的删除操作" class="headerlink" title="583、两个字符串的删除操作"></a>583、两个字符串的删除操作</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161514033.png" alt="image-20240116151456778"></p><p>本题不同于上一题不同的子序列，两个单词word1和word2都可以进行删除操作</p><ul><li><h4 id="dp数组含义是什么？-17"><a href="#dp数组含义是什么？-17" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j] 表示以i-1为结尾的字符串word1和以j-1为结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><ul><li><h4 id="递推公式是什么？-18"><a href="#递推公式是什么？-18" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li><li><p>word[i-1]与word[i-1]相等  则不需要删除字符维持不变即可</p><ul><li>dp[i][j] = dp[i-1][j-1]</li></ul></li><li><p>word[i-1]与word[i-1]不相等，有如下 几种情况</p><ul><li>删除word1[i-1]，最少操作次数为dp[i-1][j] + 1</li><li>删除word2[j-1]，最少操作次数为dp[i][j-1] + 1</li><li>删除word1[i-1]和word2[i-1]，最少操作次数为dp[i-1][j-1] + 2</li></ul></li></ul><p>本题求的是最少的操作次数，因此需要取这三者中的最小值，即min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 2)。</p><p>但是dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2</p><ul><li><h4 id="如何进行初始化？-18"><a href="#如何进行初始化？-18" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[i][0]表示以i-1结尾的word1要想变成空字符串，需要删除的字符串个数 为i，所以dp[i][0] = i</p><p>dp[0][j] 同理  dp[0][j] = j</p><ul><li><h4 id="遍历顺序是什么？-17"><a href="#遍历顺序是什么？-17" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181411569.png" alt="583.两个字符串的删除操作1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i  <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181412689.png" alt="image-20240118141213816"></p><p>本题的另一个思路是求两个字符串的最长公共子序列，然后用长度之和减去两倍的最长公共子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> n1+n2-<span class="number">2</span>*dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181418579.png" alt="image-20240118141834808"></p><h2 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离(*)"></a>72、编辑距离(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181419849.png" alt="image-20240118141908484"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181419025.png" alt="image-20240118141921213"></p><p>本题跟之前的题目相比，多了两个操作（插入和替换单词）</p><ul><li><h4 id="dp数组含义是什么？-18"><a href="#dp数组含义是什么？-18" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示以i-1结尾的word1和以i-1结尾的word2，如果想要变成一样的字符需要的最少操作次数</p><ul><li><h4 id="递推公式是什么？-19"><a href="#递推公式是什么？-19" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果word[i-1]和word[j-1]相等，则不需要进行操作，即dp[i][j]=dp[i-1][j-1]</p><p>如果word[i-1]和word[j-1]不相等，需要进行的操作有</p><ul><li>增<ul><li>选择增加的时候，本质上和删除的操作次数是一样的</li></ul></li><li>删<ul><li>如果删除的是word1的第i-1位置，则dp[i][j] = dp[i-1][j] + 1</li><li>如果删除的是word2的第j-1位置，则dp[i][j] = dp[i][j-1] + 1</li></ul></li><li>替换位置<ul><li>替换的时候，即替换word1[i-1]和word2[j-1]其中之一使其相等，dp[i][j] = dp[i-1][j-1] + 1</li></ul></li></ul><p>所以最终的代码如下：</p><ul><li><h4 id="如何进行初始化？-19"><a href="#如何进行初始化？-19" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化的时候需要注意dp[0][j]和dp[i][0]的含义</p><p>dp[0][j] 表示word2要变成word1空字符串需要操作的次数，即为j次</p><p>dp[i][0] 表示word1要变成word2空字符串需要操作的次数，即为i次</p><ul><li><h4 id="遍历顺序是什么？-18"><a href="#遍历顺序是什么？-18" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401191128328.png" alt="image-20240119112827281"></p><h2 id="647、回文子串"><a href="#647、回文子串" class="headerlink" title="647、回文子串(*)"></a>647、回文子串(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181506634.png" alt="image-20240118150631224"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181506107.png" alt="image-20240118150641764"></p><p>子串：连续的字符串组成的一个序列</p><p>统计字符串<code>s</code>中的回文子串的数目</p><ul><li><h4 id="dp数组含义是什么？-19"><a href="#dp数组含义是什么？-19" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]如果表示到下标<code>i</code>位置字符串s的子串有多少个回文子串，那么就很难找到递推关系 </p><p>所以dp数组初始化为dp[i][j]  字符串从i到j的子串是否是回文子串  这里用bool类型的元素来进行表示即可</p><ul><li><h4 id="递推公式是什么？-20"><a href="#递推公式是什么？-20" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果s[i]和s[j]相等，则分成三种情况讨论</p><ul><li><p>i==j，单个字符，是回文子串</p></li><li><p>j-i=1，即j和i相差1个字符，也是回文子串</p></li><li><p>j-i≥1，相差多个字符，就需要看中间的字符是否也是回文子串，即dp[i+1][j-1]</p></li><li><h4 id="如何进行初始化？-20"><a href="#如何进行初始化？-20" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化全部的dp数组为false，表示不是回文子串</p><ul><li><h4 id="遍历顺序是什么？-19"><a href="#遍历顺序是什么？-19" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从dp左下角往右上角递推，注意j是从i开始进行遍历一直到len(s)的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;=<span class="number">1</span>:</span><br><span class="line">                        res+=<span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                            res+=<span class="number">1</span></span><br><span class="line">                            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181606400.png" alt="image-20240118160615948"></p><p>简化版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j] <span class="keyword">and</span> (j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401182208861.png" alt="image-20240118220833731"></p><h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串(*)"></a>5、最长回文子串(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623627.png" alt="image-20240118161552594"></p><p>本题只需要在上一题遍历的过程中进行长度的判断即可</p><p>递推的顺序依旧是从左下角到左上角</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;=<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> j-i&gt;=length:</span><br><span class="line">                            ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                            length = j-i</span><br><span class="line">                        res+=<span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                            <span class="keyword">if</span> j-i&gt;=length:</span><br><span class="line">                                ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                                length = j-i</span><br><span class="line">                            res+=<span class="number">1</span></span><br><span class="line">                            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623317.png" alt="image-20240118161626038"></p><p>简化版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        length = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j] <span class="keyword">and</span> (j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">if</span> length&lt;j-i:</span><br><span class="line">                        ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                        length = j-i</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401182209437.png" alt="image-20240118220904814"></p><h2 id="516、最长回文子序列"><a href="#516、最长回文子序列" class="headerlink" title="516、最长回文子序列(*)"></a>516、最长回文子序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623228.png" alt="image-20240118162341066"></p><p>本题的子序列和子串的区别就在于，子序列可以是原本的字符删除其中一部分得到的一个序列，子串必须是连续的。</p><ul><li><h4 id="dp数组含义是什么？-20"><a href="#dp数组含义是什么？-20" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示字符串s在[i,j]范围内最长的回文子序列的长度为dp[i][j]</p><ul><li><h4 id="递推公式是什么？-21"><a href="#递推公式是什么？-21" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果s[i]和s[j]相等，则dp[i][j] = dp[i+1][j-1] + 2</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181626930.jpg" alt="516.最长回文子序列"></p><p>如果s[i]和s[j]不相等，则可以判断二者其中的一个加入到子序列中的时候，能够得到的最大值，也就是：</p><p>dp[i][j] = max(dp[i][j-1], dp[i-1][j])</p><ul><li><h4 id="如何进行初始化？-21"><a href="#如何进行初始化？-21" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>对角线部分初始化为1，因为对角线已经初始化过了，所以j的遍历顺序需要从i+1开始</p><ul><li><h4 id="遍历顺序是什么？-20"><a href="#遍历顺序是什么？-20" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>==从左下到右上方，i从len(s)到0，j从i+1到len(s)，不从i开始的原因是因为对角线部分即ij的时候我们已经初始化过了，这一点也是本题与前两题不同之处。==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181707879.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp表示的是i到j之间回文子序列的最大长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment"># 为什么j从i+1开始，跟之前不一样？</span></span><br><span class="line">                <span class="keyword">if</span> s[j]==s[i]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181647610.png" alt="image-20240118164712517"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板：</p><ul><li><h4 id="dp数组含义是什么？-21"><a href="#dp数组含义是什么？-21" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li><li><h4 id="递推公式是什么？-22"><a href="#递推公式是什么？-22" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li><li><h4 id="如何进行初始化？-22"><a href="#如何进行初始化？-22" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li><li><h4 id="遍历顺序是什么？-21"><a href="#遍历顺序是什么？-21" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><h2 id="01背包问题总结"><a href="#01背包问题总结" class="headerlink" title="01背包问题总结"></a>01背包问题总结</h2><h2 id="完全背包问题总结"><a href="#完全背包问题总结" class="headerlink" title="完全背包问题总结"></a>完全背包问题总结</h2><h2 id="股票问题总结"><a href="#股票问题总结" class="headerlink" title="股票问题总结"></a>股票问题总结</h2><ul><li><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">动态规划：121.买卖股票的最佳时机</a></li><li><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II</a></li><li><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a></li><li><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">动态规划：188.买卖股票的最佳时机IV</a></li><li><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">动态规划：309.最佳买卖股票时机含冷冻期</a></li><li><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：714.买卖股票的最佳时机含手续费</a></li></ul><p>第一题：股票只能买卖一次，求最大利润</p><p>第二题：股票可以买卖多次，求最大利润</p><p>第三题：最多只能买卖两次，求最大利润</p><p>第四题：最多能够买卖k次，求最大利润，这题是上一题的扩展版本，总结出规律即可，状态j为奇数时，卖出股票，为偶数时，为卖出股票</p><p>第五题：冷冻期导致问题多出了两个状态，一个是冷冻期，一个是不持有股票的状态（今天卖出股票和前2天卖出股票区别于冷冻期）</p><p>第六题：本质上是第二题，只是多了一笔手续费，只需要在卖出股票的递推公式中减去fee即可，其余代码不需要改动</p><h2 id="子序列问题总结"><a href="#子序列问题总结" class="headerlink" title="子序列问题总结"></a>子序列问题总结</h2><ul><li>最长上升子序列</li><li>最长连续递增子序列</li><li>最长重复子数组</li><li>最长公共子序列</li><li>不相交的线</li><li>最大子序和</li></ul><h2 id="编辑距离问题总结"><a href="#编辑距离问题总结" class="headerlink" title="编辑距离问题总结"></a>编辑距离问题总结</h2><ul><li>判断子序列</li><li>不同的子序列</li><li>两个字符串的删除操作</li><li>编辑距离</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;问题分类&quot;&gt;&lt;a href=&quot;#问题分类&quot; class=&quot;headerlink&quot; title=&quot;问题分类&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="动态规划" scheme="https://guoxiansen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-11-25T07:09:53.000Z</published>
    <updated>2023-12-09T13:46:19.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>题目分类大纲：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252041388.png" alt="贪心算法大纲"></p><h2 id="什么是贪心算法？"><a href="#什么是贪心算法？" class="headerlink" title="什么是贪心算法？"></a>什么是贪心算法？</h2><p>贪心算法就是在每个阶段都选择局部最优解，从而达到全局最优。</p><h2 id="贪心算法解题步骤"><a href="#贪心算法解题步骤" class="headerlink" title="贪心算法解题步骤"></a>贪心算法解题步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出合适的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="455、分发饼干"><a href="#455、分发饼干" class="headerlink" title="455、分发饼干"></a>455、分发饼干</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252045681.png" alt="image-20231125204525836"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252045154.png" alt="image-20231125204541221"></p><p><strong>思路</strong></p><p>遍历胃口和饼干列表，但是需要注意的是饼干列表不是每次都在移动，而是匹配了一个才会移动，因此这里不需要进行两层for循环，只需要一层for循环来遍历胃口列表即可。然后饼干列表可以使用一个指针index进行遍历，只有在能够进行匹配的情况下才需要将index进行移动。同时使用index来保存返回的结果。==index可以直接用来当做最终的结果进行返回==</p><p>利用贪心算法，每次都尽量喂饱胃口最大的，如果满足不了则往后移动判断能否满足下一个胃口最大的。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先满足大胃口 | 此时胃口在移动</span></span><br><span class="line">        g.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        s.sort(reverse=<span class="literal">True</span>) <span class="comment"># 从大到小</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g)):</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> s[index]&gt;=g[i]:</span><br><span class="line">                index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252104655.png" alt="image-20231125210434577"></p><p>本题不能先移动饼干，如果先移动饼干的话，就会出现下面的情况，导致最终没有满足条件的答案。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252123926.png" alt="img"></p><p>当然本题也可以先满足胃口小的，做法是类似的。但是如果是满足小胃口的话，就需要注意循环的顺序，这时候就是先遍历饼干，然后使用index对胃口列表进行遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(g) <span class="keyword">and</span> s[i]&gt;=g[index]:</span><br><span class="line">                index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure><h2 id="376、摆动序列"><a href="#376、摆动序列" class="headerlink" title="376、摆动序列(*)"></a>376、摆动序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271458628.png" alt="image-20231127145825546"></p><p>计算峰值</p><p>prediff = nums[i] - nums[i-1]</p><p>curdiff = nums[i+1] - nums[i]</p><p>如果prediff&gt;0 and curdiff &lt; 0 或者 prediff &lt; 0 and curdiff &gt; 0，就需要统计波动</p><p>有三种特殊情况需要考虑：</p><ul><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ul><p><strong>情况一：上下坡中有平坡</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271510146.png" alt="img"></p><p>可以统一规则，删除左边的3个2</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271511303.png" alt="img"></p><p><strong>情况二：数组首尾两端</strong></p><p>如果数组中只包含两个元素，如果这两个元素不相同则摆动序列也为2</p><p>例如序列[2, 5]，如果靠统计差值计算峰值，需要有三个数才能进行统计，这时候，我们可以假定这个序列为[2,2,5]，这样<code>preDiff=0 and curDiff=3</code>，满足我们的条件，<code>res+=1</code>，就可以统一写法，不需要单独把<code>len(nums)==2</code>的情况单独拎出来了。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271525974.png" alt="376.摆动序列1"></p><p>针对上述情况，我们可以假设res = 1，默认最右边有一个峰值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (preDiff&gt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>) <span class="keyword">or</span> (preDiff&lt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            preDiff = curDiff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这样的代码已经可以AC掉力扣中给出的测试用例，但是提交之后还是会有报错，这是因为这个代码忽略了<code>情况三</code>。</p><p><strong>情况三：单调坡中有平坡</strong></p><p>如果这时候的序列是[1, 2, 2, 2, 5]这样的，在上面的代码中得到的答案是3而不是2，这是因为程序的执行会按照情况一进行了。此时我们只需要进行的改动是只有在满足情况的条件下才会去修改<code>preDiff</code>指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (preDiff&gt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>) <span class="keyword">or</span> (preDiff&lt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                preDiff = curDiff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271530437.png" alt="image-20231127153052502"></p><h2 id="53、最大子数组和（-）"><a href="#53、最大子数组和（-）" class="headerlink" title="53、最大子数组和（*）"></a>53、最大子数组和（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271548474.png" alt="image-20231127154858508"></p><p>初次尝试：</p><p>两层for循环进行遍历，计算所有子序列的和，碰到最大的就修改max_。这里需要注意<strong>max_</strong>在进行初始化的时候需要初始化为最小值<code>float(&quot;-inf&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># print(i,j)</span></span><br><span class="line">                <span class="comment"># print(nums[i:j+1])</span></span><br><span class="line">                max_ = <span class="built_in">max</span>(max_,<span class="built_in">sum</span>(nums[i:j+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure><p>力扣中Python代码超时200/210</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271555768.png" alt="image-20231127155543817"></p><p>使用==贪心算法==</p><p>使用count进行和计算，如果碰到一个负数使得当前的count值小于0，则将count赋值为0重新进行子序列寻找，也设置一个max_初始化为最小值，当count&gt;max_时，就进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            count+=nums[i]</span><br><span class="line">            <span class="keyword">if</span> count&gt;max_:</span><br><span class="line">                max_ = count</span><br><span class="line">            <span class="keyword">if</span> count&lt;<span class="number">0</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271556201.png" alt="image-20231127155602214"></p><h2 id="122、买卖股票的最佳时机II"><a href="#122、买卖股票的最佳时机II" class="headerlink" title="122、买卖股票的最佳时机II"></a>122、买卖股票的最佳时机II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272129099.png" alt="image-20231127212916141"></p><p>题目中提到只能购买或者出售股票，并且最多持有一支股票。</p><p>只统计利润为正的即可得到最大收益。</p><p>贪心算法进行求解时，需要对利润进行拆解：以下面这个例子为例，我们只需要收集正利润的区间，就是股票买卖的区间。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272133164.png" alt="122.买卖股票的最佳时机II"></p><p>贪心算法就体现在每天只取正利润的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            profit += <span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><h2 id="55、跳跃游戏"><a href="#55、跳跃游戏" class="headerlink" title="55、跳跃游戏"></a>55、跳跃游戏</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272143796.png" alt="image-20231127214313444"></p><p>本题思路：通过查看当前结点能够跳跃的最远范围进行校验</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272206381.png" alt="img"></p><p>这里nums中的元素所表示的含义是能够跳跃的最远范围，我们只需要判断其能够覆盖的范围，然后用其与len(nums)-1进行比较，如果大于等于则返回True，否则循环结束也无法到达最后一个下标的话，则返回False。</p><p>注意这里需要判断<code>i</code>的范围不能超过当前最远能够到达的区域，如果<code>i</code>超过了<code>max_reach</code>则直接break。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        max_reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; max_reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            max_reach = <span class="built_in">max</span>(nums[i]+i, max_reach)</span><br><span class="line">            <span class="keyword">if</span> max_reach &gt;= <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272209796.png" alt="image-20231127220956157"></p><p>在Python中无法动态修改for循环中的循环变量，可以改用while循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= reach:</span><br><span class="line">            reach = <span class="built_in">max</span>(reach, nums[i]+i)</span><br><span class="line">            <span class="keyword">if</span> reach&gt;=<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="45、跳跃游戏II"><a href="#45、跳跃游戏II" class="headerlink" title="45、跳跃游戏II"></a>45、跳跃游戏II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281000659.png" alt="image-20231128100052826"></p><p>跳跃游戏中，需要我们判断是否能够到达最后一个下标，本题需要我们计算从第一个元素开始到最后一个下标的最小跳跃次数。</p><p>贪心的思路</p><ul><li>局部最优<ul><li>当前尽可能走更多，如果还没到达终点，步数+1</li></ul></li><li>整体最优<ul><li>一步尽可能走更多，从而达到步数最少</li></ul></li></ul><p>记录当前可以覆盖的最远距离和下一步可以覆盖的最远距离</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281017722.png" alt="45.跳跃游戏II"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        cur_reach = <span class="number">0</span> <span class="comment"># 当前能够到达的最远距离</span></span><br><span class="line">        next_reach = <span class="number">0</span> <span class="comment"># 下一步能够到达的最远距离</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment"># 记录走的步数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            next_reach = <span class="built_in">max</span>(next_reach, nums[i]+i)</span><br><span class="line">            <span class="keyword">if</span> i == cur_reach:</span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                cur_reach = next_reach</span><br><span class="line">                <span class="keyword">if</span> next_reach&gt;=<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h2 id="1005、K次取反后最大化数组和"><a href="#1005、K次取反后最大化数组和" class="headerlink" title="1005、K次取反后最大化数组和"></a>1005、K次取反后最大化数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281030036.png" alt="image-20231128103034570"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281030159.png" alt="image-20231128103050303"></p><p>局部最优解：让绝对值最大的负数变为正数，刚好可以利用Python中排序的<code>key</code>关键字，使用<code>lambda</code>表达式。如果。</p><p>如果数组内全部为正数，那么只需要将最小值也就是排序过后的数组中的最后一个元素在k为奇数的时候将其值修改为-1倍。</p><p>先按照绝对值大小进行排序，排序后再进行遍历的过程中寻找小于0且此时k大于0，然后将其值修改为-1倍，直到循环结束。如果循环结束之后k==1的话，就让nums中绝对值最小的数×(-1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">abs</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        print(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果nums都大于0呢？？？ 都大于0 不进入循环</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">0</span> <span class="keyword">and</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                nums[i]*=-<span class="number">1</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果nums都大于0 只需要修改最小的那个值 修改其为负数即可</span></span><br><span class="line">        <span class="comment"># 如果k为偶数的话，也可以不修改</span></span><br><span class="line">        <span class="keyword">if</span> k%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281047717.png" alt="image-20231128104748129"></p><h2 id="134、加油站（-）"><a href="#134、加油站（-）" class="headerlink" title="134、加油站（*）"></a>134、加油站（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281513600.png" alt="image-20231128151314321"></p><p><strong>暴力算法</strong></p><p>暴力算法就是通过两层循环嵌套，外层循环表示从哪个加油站出发，内存循环进行判断是否能够绕一周回到当前位置，设置一个index表示当前所到达的加油站位置，经过内层循环如果能够绕一周到原来的位置，即<code>index==i</code>并且剩余的油量还大于等于0的话，返回当前外层循环的循环变量<code>i</code>。</p><p>这里index进行增加的时候因为是环形，类似于循环队列，需要除以<code>len(gas)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 绕环路行驶一周</span></span><br><span class="line">        <span class="comment"># 模拟从各个加油站出发是否还能到达当前加油站</span></span><br><span class="line">        mygas = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从编号为i的加油站出发</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            mygas = gas[i]-cost[i] <span class="comment"># 剩余的汽油</span></span><br><span class="line">            index = (i+<span class="number">1</span>)%<span class="built_in">len</span>(gas)</span><br><span class="line">            <span class="keyword">while</span> mygas&gt;=<span class="number">0</span> <span class="keyword">and</span> index!=i:</span><br><span class="line">                mygas += gas[index]</span><br><span class="line">                mygas -= cost[index]</span><br><span class="line">                index = (index+<span class="number">1</span>)%<span class="built_in">len</span>(gas)</span><br><span class="line">            <span class="keyword">if</span> mygas&gt;=<span class="number">0</span> <span class="keyword">and</span> index==i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>算法分析</p><ul><li>时间复杂度 O(n^2^)</li><li>空间复杂度 O(1)</li></ul><p>暴力算法会超时</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281338161.png" alt="image-20231128133810328"></p><p><strong>贪心算法（1）</strong></p><p>分情况讨论：</p><ul><li>情况1：如果gas总量小于cost总量，则无论从哪里出发都无法绕一圈回到起点</li><li>情况2：rest[i]=gas[i]-cost[i]为一天剩下的油，i从0开始累加到最后一个加油站， 如果累加没有出现负数，那么就从0开始，0号为起点</li><li>情况3：如果累加的值为负数，说明不是从0开始，从后向前，看哪个节点可以把这个负数填平，如果能把负数填平的节点就是出发点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(gas)&lt;<span class="built_in">sum</span>(cost):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest+=gas[i]-cost[i]</span><br><span class="line">            min_ = <span class="built_in">min</span>(min_,rest)</span><br><span class="line">        print(rest,min_)</span><br><span class="line">        <span class="comment"># 如果min_&gt;=0 说明从0开始出发即可</span></span><br><span class="line">        <span class="keyword">if</span> min_&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果min_&lt;0  说明需要从非0出发点出发</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># ？</span></span><br><span class="line">            rest = gas[i]-cost[i]</span><br><span class="line">            min_ += rest</span><br><span class="line">            <span class="keyword">if</span> min_&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>贪心算法2</strong></p><p>首先判断gas总和是否小于cost，小于则直接返回-1</p><p>然后通过累加gas[i]-cost[i]，如果差值小于0，出发的起点一定不在[0,i]这个区间范围内，需要从i+1开始进行判断。同时如果计算到某个节点rest&lt;0，还需要将rest置为0重新计算。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281855770.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281855126.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(gas)&lt;<span class="built_in">sum</span>(cost):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>        </span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        rest = <span class="number">0</span> <span class="comment"># 用于计算差值的累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest += gas[i]-cost[i]</span><br><span class="line">            <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 下标要从i+1开始</span></span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281853030.png" alt="加油站-贪心算法"></p><ul><li>时间复杂度O(n) 只有单层for循环</li><li>空间复杂度O(1)</li></ul><h2 id="135、分发糖果（-）"><a href="#135、分发糖果（-）" class="headerlink" title="135、分发糖果（*）"></a>135、分发糖果（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281859707.png" alt="image-20231128185903873"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281859282.png" alt="image-20231128185919854"></p><p>题目中说到相邻的两个孩子评分更高的孩子会获得更多的糖果，需要迭代的去进行比较，及时更新每一步。</p><p>这里需要注意，如果需要<strong>判断右孩子比左孩子大的话需要从前往后进行遍历</strong>，因为后面的值需要前面的结果，如果是<strong>判断左孩子比右孩子的大的话需要从后往前进行遍历</strong>，因为前面的结果需要依靠后面的结果进行累加，但是需要注意的是，有的结果已经已经比左边大了，同时有比右边大，这时候需要判断当前<code>res[i]</code>和<code>res[i+1]+1</code>哪个值更大就赋值为哪个值避免测试用例的错误。</p><p>出错的测试用例 ratings = [1,3,4,5,2]，错误的地方就在于在从后往前进行遍历的时候，ratings[3]&gt;ratings[4]，res[3] = res[4]+1 = 2，但是2小于从左往右进行遍历的结果4，这里我们应该选择的是两者的最大值。因此这里使用res[i] = max(res[i],res[i+1]+1)进行赋值。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290955837.png" alt="image-20231129095508509"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]*<span class="built_in">len</span>(ratings)</span><br><span class="line">        <span class="comment"># 从前向后 判断右孩子如果比左孩子大的话，就需要进行ratings[i] = ratings[i-1]+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i-<span class="number">1</span>]:</span><br><span class="line">                res[i] = res[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 从后向前 判断如果左孩子比右孩子大的话，就需要进行ratings[i] = ratings[i+1]+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i+<span class="number">1</span>]:</span><br><span class="line">                res[i] = <span class="built_in">max</span>(res[i],res[i+<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(res)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282040660.png" alt="image-20231128204029877"></p><p>本题中用到了两次贪心算法</p><ul><li>一次从前往后进行遍历的贪心算法</li><li>一次从后往前进行遍历的贪心算法</li></ul><h2 id="860、柠檬水找零"><a href="#860、柠檬水找零" class="headerlink" title="860、柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/description/">860、柠檬水找零</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282044821.png" alt="image-20231128204410801"></p><p>如果付款金额为20美元，优先找1张10美元1张5美元，如果没有才找3张5美元的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 判断除了五美元以外的钞票是否能找开</span></span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># myhash = defaultdict(int)</span></span><br><span class="line">        myhash = &#123;<span class="number">20</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">5</span>:<span class="number">0</span>&#125;</span><br><span class="line">        now = []</span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            myhash[bill]+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 超过5块就进行找零</span></span><br><span class="line">            <span class="comment"># print(bill,myhash)</span></span><br><span class="line">            <span class="keyword">if</span> bill==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> myhash[<span class="number">5</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> bill==<span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> (myhash[<span class="number">10</span>]&gt;<span class="number">0</span> <span class="keyword">and</span> myhash[<span class="number">5</span>]&gt;<span class="number">0</span>):</span><br><span class="line">                    myhash[<span class="number">10</span>]-=<span class="number">1</span></span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> myhash[<span class="number">5</span>]&gt;<span class="number">2</span>:</span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282110049.png" alt="image-20231128211003521"></p><h2 id="406、根据身高重建队列（-）"><a href="#406、根据身高重建队列（-）" class="headerlink" title="406、根据身高重建队列（*）"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406、根据身高重建队列（*）</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282203221.png" alt="image-20231128211340233"></p><p>题目理解：</p><p>本题中需要注意的地方在于列表中的第二个元素是排在其前面总共有多少个人，矮个子排在高个子前面是没有影响的，但是高个子排在矮个子前面是有影响的。另外如果是身高一样的人，第二个数字越大的人排序越靠后，这是第一个排序的因素，第二个排序的因素是如果数字相同，身高越低的人越靠后。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290933096.png" alt="406.根据身高重建队列"></p><p>两个维度进行比较的时候会顾此失彼，类似于<strong>分发糖果</strong>的题目！！！</p><p>先确定一个维度，贪心另一个维度</p><p>做法：</p><p>先按照身高逆序排序再按照前面有几个人正序排序。然后通过构建新的列表往其中按照第二个元素位置顺序添加元素来实现最终的答案。</p><p>[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</p><p>局部最优：优先按照身高people的k进行插入。插入操作后的people满足队列属性</p><p>全局最优：全部插入完成后，整个队列满足题目要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># print(people)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> po <span class="keyword">in</span> people:</span><br><span class="line">            pos = po[<span class="number">1</span>]</span><br><span class="line">            res.insert(pos,po)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282213282.png" alt="image-20231128221313071"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290942417.png" alt="image-20231129094227112"></p><h2 id="452、用最少数量的箭引爆气球"><a href="#452、用最少数量的箭引爆气球" class="headerlink" title="452、用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452、用最少数量的箭引爆气球</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291013788.png" alt="image-20231129101311418"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291235167.png" alt="image-20231129123511474"></p><p>本题属于==区间问题==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291027692.png" alt="image-20231129102701369"></p><p>思路如上，首先对points依据其第一个元素进行排序，得到[[1, 6], [2, 8], [7, 12], [10, 16]]的结果，然后列表进行遍历。遍历的过程中我们队右边界进行更新，每次更新最小的右边界。</p><ul><li>如果左边界大于右边界<ul><li>res = res + 1</li></ul></li><li>左边界小于等于有边界<ul><li>更新当前的最小右边界</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 判断是否有重叠的区间？</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(points)</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="comment"># 左边界大于右边界</span></span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新最小右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i][<span class="number">1</span>], points[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>优化思路：</p><p>这个优化后的算法使用贪心策略，先将气球按右边界进行排序，然后遍历气球列表，如果发现当前气球的起始位置大于当前箭的结束位置，说明需要增加箭的数量，并更新箭的结束位置。这样可以有效减少时间复杂度，避免了多次合并区间的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按照气球的右边界进行排序</span></span><br><span class="line">        arrows = <span class="number">1</span></span><br><span class="line">        end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> start, point_end <span class="keyword">in</span> points:</span><br><span class="line">            <span class="comment"># 如果当前气球的起始位置大于当前箭的结束位置，则增加箭的数量，并更新箭的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                arrows += <span class="number">1</span></span><br><span class="line">                end = point_end</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arrows</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311302159946.png" alt="image-20231130215910639"></p><h2 id="435、无重叠区间"><a href="#435、无重叠区间" class="headerlink" title="435、无重叠区间"></a>435、无重叠区间</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291555833.png" alt="image-20231129155501224"></p><p><strong>贪心算法基于左边界</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291610038.png" alt="image-20231129161034940"></p><p>首先对列表进行排序，然后对其进行循环遍历（从列表中的第二个元素开始，即下标为1），如果当前的左边界要小于前一个区间的右边界则说明发生重叠，将res+1，然后看当前结点的右边界是否大于上一个结点的右边界，如果大于则更新，如果小于则不进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题计算的是如果构造没有重叠区间的话，需要去掉几个区间。</p><p>上一题引爆气球是计算的最少需要多少个箭，本题中需要判断的不重叠的区间，只需要用总区间数减去射箭的次数即可。因为在气球爆炸问题中如果是相邻边界，则使用一支箭即可，但在本题中如果相邻不算重叠，所以本题如果采用上一题的思路则条件需要修改为&gt;=，其余的做法都是一致的，修改最终返回值为len(intervals)-res</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>]&gt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新右边界</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals)-res</span><br></pre></td></tr></table></figure><h2 id="763、划分字母区间（-）"><a href="#763、划分字母区间（-）" class="headerlink" title="763、划分字母区间（*）"></a>763、划分字母区间（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291652057.png" alt="image-20231129165215770"></p><p>右指针一直取所走过的最大的下标范围，如果当前循环变量的值刚好等于当前的最大右指针则将切割点加入res，切割点的值为right-left+1，同时更新left为i+1</p><p>本题难点就在于如何进行遍历过程中的right修改，用哈希表来存放下标并不难。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311292233307.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            myhash[s[i]] = i</span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        res = []</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span> <span class="comment"># 右指针 结果是切割点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            right = <span class="built_in">max</span>(right,myhash[s[i]])</span><br><span class="line">            <span class="keyword">if</span> right==i:</span><br><span class="line">                res.append(right-left+<span class="number">1</span>)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311300930178.png" alt="image-20231130093057946"></p><h2 id="56、合并区间（-）"><a href="#56、合并区间（-）" class="headerlink" title="56、合并区间（*）"></a>56、合并区间（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301912613.png" alt="image-20231130191256419"></p><p>思路：首先对区间进行排序，然后对其进行比较</p><p>这里需要注意的是，比较res[-1]的时候，用其右边界和当前区间的左边界进行比较，比较的时候是&gt;=，因为[1,2]和[2,3]区间是被视为重叠的区间的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="comment"># print(intervals)</span></span><br><span class="line">        res = [intervals[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> res[-<span class="number">1</span>][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 合并</span></span><br><span class="line">                res[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], res[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 加入结果集</span></span><br><span class="line">                res.append(intervals[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301917690.png" alt="image-20231130191723043"></p><h2 id="区间问题的复盘"><a href="#区间问题的复盘" class="headerlink" title="区间问题的复盘"></a>区间问题的复盘</h2><ol><li>用最少数量的箭引爆气球</li><li>无重叠区间</li><li>划分字母区间</li><li>合并区间</li></ol><h2 id="57、插入区间"><a href="#57、插入区间" class="headerlink" title="57、插入区间"></a>57、插入区间</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922699.png" alt="image-20231130192222475"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922303.png" alt="image-20231130192239982"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922614.png" alt="image-20231130192252618"></p><h2 id="738、单调递增的数字"><a href="#738、单调递增的数字" class="headerlink" title="738、单调递增的数字"></a>738、单调递增的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311302145958.png" alt="image-20231130214520514"></p><p>暴力解法（超时）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">num</span>):</span></span><br><span class="line">            <span class="comment"># 判断一个数是否是递增的数</span></span><br><span class="line">            nums = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">            nums_sort = <span class="built_in">sorted</span>(nums)</span><br><span class="line">            <span class="comment"># nums_set = list(set(nums))</span></span><br><span class="line">            <span class="comment"># print(nums,nums_sort)</span></span><br><span class="line">            <span class="keyword">return</span> nums==nums_sort</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> judge(i):</span><br><span class="line">                res = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>贪心算法</p><p>从后往前进行比较，另外每次修改后都需要将后面的数修改为9，避免类似100这样的问题</p><p>从后往前进行遍历 332–&gt; 329 –&gt; 299</p><p>从前往后比较会出现问题，例如332，从前往后比较332–&gt;329，此时第二个2小于3了。</p><p>从前往后遍历使得后面修改导致数字并不是递增的，从后往前遍历就可以避免这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># num = list(str(n))</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(n)))</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># nums[i+1] = 9</span></span><br><span class="line">                nums[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                    nums[j] = <span class="number">9</span></span><br><span class="line">        <span class="comment"># 如何快速把[1,2,3,4]合并成1234数字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,nums)))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011719641.png" alt="image-20231201171906141"></p><h2 id="968、监控二叉树"><a href="#968、监控二叉树" class="headerlink" title="968、监控二叉树(*)"></a>968、监控二叉树(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011659177.png" alt="image-20231201165920904"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011719864.png" alt="image-20231201171951677"></p><p>思路：</p><h1 id="贪心总结"><a href="#贪心总结" class="headerlink" title="贪心总结"></a>贪心总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h1&gt;&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h</summary>
      
    
    
    
    
    <category term="贪心" scheme="https://guoxiansen.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://guoxiansen.github.io/2023/11/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://guoxiansen.github.io/2023/11/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2023-11-22T02:20:34.000Z</published>
    <updated>2024-01-09T05:57:16.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法是一种搜索的方法，在二叉树总结当中，经常使用到递归去解决相关的问题，在二叉树的<strong>所有路径</strong>问题中，我们就使用到了回溯算法来找到所有的路径。</p><p>回溯算法本质就是去穷举，性能并不是那么高效。一般为了提高效率，往往回溯算法会跟剪枝操作相结合。</p><p>回溯算法通常可以用来解决一些问题，这也是为什么会有回溯算法的原因</p><ul><li>组合问题<ul><li>N个数里面按照一定规则找出k个数的集合。<strong>组合不强调元素的顺序</strong></li></ul></li><li>切割问题<ul><li>一个字符串按一定规则有几种切割方式<ul><li>分割回文串</li><li>复原IP地址</li></ul></li></ul></li><li>子集问题<ul><li>一个N个数的集合里有多少符合条件的子集</li></ul></li><li>排列问题<ul><li>N个数按照一定规则全排列，有几种排列方式。<strong>排列强调元素的顺序</strong></li></ul></li><li>棋盘问题<ul><li>N皇后、解数独问题</li></ul></li></ul><h2 id="理解回溯"><a href="#理解回溯" class="headerlink" title="理解回溯"></a>理解回溯</h2><p>回溯法解决的问题都可以抽象为树形结构，回溯算法解决问题都是在集合中递归查找子集，<strong>集合的大小构成了树的宽度</strong>，<strong>递归的深度构成了树的深度</strong>。</p><p>递归必须要有终止条件，所以一定是一个高度有限的N叉树。</p><h2 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h2><p>递归三部曲：</p><ul><li>返回值及参数<ul><li>void backtracking(参数)</li></ul></li><li>回溯函数的终止条件<br>+ </li><li>回溯搜索的遍历过程<ul><li><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221034861.png" alt="回溯算法理论基础"></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="77、组合"><a href="#77、组合" class="headerlink" title="77、组合"></a>77、组合</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221036587.png" alt="image-20231122103657483"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n,k,startindex,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)==k:</span><br><span class="line">                <span class="comment"># 这里需要注意，因为列表在Python中是可变数据类型，后面的修改会导致path变为[]</span></span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 这里的startindex代表的是在单层递归中需要遍历的次数 从startindex一直到n寻找符合条件的数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtracking(n,k,i+<span class="number">1</span>,path)</span><br><span class="line">                a = path.pop()</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221040604.png" alt="image-20231122104026446"></p><p><strong>回溯+剪枝</strong></p><p>使用剪枝的原理就在于如果剩余的元素个数已经小于k-len(path)的时候，我们就不再往下继续了。</p><ol><li>已经选择过的元素个数：<code>len(path)</code></li><li>还需要选择的个数<code>k-len(path)</code>  </li><li>在集合中更需要从最多要从下标为<code>n-(k-len(path))+1</code>开始遍历，在python中因为range循环的时候是左闭右开，所以还需要<code>+1</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221105316.png" alt="77.组合4"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n,k,startindex,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)==k:</span><br><span class="line">                <span class="comment"># print(path)</span></span><br><span class="line">                <span class="comment"># 这里需要注意，因为列表在Python中是可变数据类型，后面的修改会导致path变为[]</span></span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">           </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n-(k-<span class="built_in">len</span>(path))+<span class="number">1</span>+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtracking(n,k,i+<span class="number">1</span>,path)</span><br><span class="line">                <span class="comment"># 回溯 退出上一个元素</span></span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251425543.png" alt="image-20231125142534496"></p><h2 id="216、组合总数III"><a href="#216、组合总数III" class="headerlink" title="216、组合总数III"></a>216、组合总数III</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221749859.png" alt="image-20231122174951944"></p><p>利用回溯代码模板。其中需要注意的是，如果path列表的和已经超过n，那么可以直接进行剪枝，除此之外，如果剩余的数字长度小于k-len(path)的话，就可以不用继续循环了，这一点也方便我们进行剪枝。</p><p>递归的三要素</p><ul><li>返回值和参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n,k,startindex,path</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>(path)&gt;n:</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path)==k <span class="keyword">and</span> <span class="built_in">sum</span>(path)==n:</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>递归体部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="number">9</span> - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span> + <span class="number">1</span>):</span><br><span class="line">    path.append(i)</span><br><span class="line">    backtracking(n,k,i+<span class="number">1</span>,path)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n,k,startindex,path</span>):</span></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path)&gt;n:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)==k <span class="keyword">and</span> <span class="built_in">sum</span>(path)==n:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="number">9</span> - (k - <span class="built_in">len</span>(path))+<span class="number">1</span>+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtracking(n,k,i+<span class="number">1</span>,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221514238.png" alt="image-20231122151406020"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221514355.png" alt="image-20231122151443212"></p><p>思路</p><p>本题类似于组合问题，需要根据输入的数字对其能够涵盖的字母进行组合，需要解决下面几个问题：</p><ul><li>数字和字母如何进行映射</li><li>两个字母两个for循环，三个字母三个for循环，多个字母多个for循环</li><li>输入异常字母如何进行处理？</li></ul><p>递归三要素</p><ul><li>递归的参数</li></ul><p>参数是<code>digits</code>和<code>index</code>，其中<code>digits</code>是题目给出的字符串，如“23”，而<code>index</code>是记录当前已经遍历到第几个数字了。</p><ul><li>递归结束的条件</li></ul><p>如果index的长度和digits长度一样的话，直接return</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index==<span class="built_in">len</span>(digits):</span><br><span class="line">    res.append(path) <span class="comment"># 这里的path被定义为字符串 而字符串在python中是不可变数据类型，因此可以直接用</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>递归体部分</li></ul><p>需要注意的是，回溯的时候对于字符串要想去掉最后一个字符的方法是直接<code>s=s[:-1]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取字符串中的数字</span></span><br><span class="line">mynum = <span class="built_in">int</span>(digits[index])</span><br><span class="line"><span class="comment"># 获取电话号码对应的字符组合</span></span><br><span class="line">char = myhash[mynum]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(char)):</span><br><span class="line">    path+=char[i]</span><br><span class="line">    backtracking(digits, index+<span class="number">1</span>, path)</span><br><span class="line">    path = path[:-<span class="number">1</span>] <span class="comment"># 刨去字符串的最后一个字符</span></span><br></pre></td></tr></table></figure><p>本题是不需要<code>startindex</code>的，因为遍历的不是同一个集合，而是不同的集合。在回溯问题中，如果是遍历同一个集合就需要传递一个参数<code>startindex</code>，用来表示的当前遍历到集合中的第几位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        myhash = [<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        res = []</span><br><span class="line">        s = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">digits, index</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> s</span><br><span class="line">            <span class="keyword">if</span> index==<span class="built_in">len</span>(digits):</span><br><span class="line">                res.append(s)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># digit表示digits中的数字</span></span><br><span class="line">            digit = <span class="built_in">int</span>(digits[index])</span><br><span class="line">            <span class="comment"># letters表示digit所代表的数字对应的字母有哪些</span></span><br><span class="line">            letters = myhash[digit]</span><br><span class="line">            <span class="comment"># for循环遍历这些字母 </span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(letters)):</span><br><span class="line">                s+=letters[i]</span><br><span class="line">                <span class="comment"># 进行回溯</span></span><br><span class="line">                backtracking(digits,index+<span class="number">1</span>)</span><br><span class="line">                s = s[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        backtracking(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题有一个需要特殊处理的地方，如果digits为空字符串的话，直接返回空列表，不需要在进行递归回溯了。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311221755946.png" alt="image-20231122151431566"></p><h2 id="39、组合总数"><a href="#39、组合总数" class="headerlink" title="39、组合总数"></a>39、组合总数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311222227480.png" alt="image-20231122222712060"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311222227170.png" alt="image-20231122222723187"></p><p>本题中说了candidates中的同一个数字可以无限制重复被选取，所以我们在进行递归的时候，传递的<code>startindex</code>就是<code>i</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401091357019.png" alt="39.组合总和"></p><p>本题中需要注意及时剪枝（即当sum_&gt;target之后就可以不用往下进行回溯了），并且可以使用一个累加的<code>sum_</code>代替掉使用内置的sum方法，节省时间开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 记录总和</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">path,candidates,target,startindex</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> sum_</span><br><span class="line">            <span class="keyword">if</span> sum_&gt;target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> sum_==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                sum_+=candidates[i]</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                <span class="comment"># 这里传入的startindex为i 这样可以重复选择相同的数</span></span><br><span class="line">                backtracking(path,candidates,target,i)</span><br><span class="line">                sum_-=candidates[i]</span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking([],candidates,target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311222227186.png" alt="image-20231122222739974"></p><h2 id="40、组合总数II（-）"><a href="#40、组合总数II（-）" class="headerlink" title="40、组合总数II（*）"></a>40、组合总数II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311231100042.png" alt="image-20231123110032934"></p><p>本题需要注意的是，跟前面不同的地方在于每个数字在每个组合中只能使用一次，同时在解集中不能包含重复的组合。<strong>因此想到设置一个used数组来表示每个元素是否已经被访问过。</strong></p><p>==其中candidates数组需要进行排序==，这样能够保证如果数字相同的情况下，只会使用一次。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311240905249.png" alt="40.组合总和II"></p><p>要去重的是同一层上是否使用过，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241828604.png" alt="40.组合总和II1"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241829158.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []  <span class="comment"># 用于记录返回结果</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">candidates,target,path,startindex,used</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> sum_</span><br><span class="line">            <span class="keyword">if</span> sum_&gt;target:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> sum_==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;startindex <span class="keyword">and</span> candidates[i]==candidates[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                sum_+=candidates[i]</span><br><span class="line">                used[i]=<span class="literal">True</span></span><br><span class="line">                backtracking(candidates,target,path,i+<span class="number">1</span>,used)</span><br><span class="line">                sum_-=candidates[i]</span><br><span class="line">                used[i]=<span class="literal">False</span></span><br><span class="line">                path.pop()</span><br><span class="line">        <span class="comment"># candidates需要进行排序，否则相同的数字可能不会连续</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtracking(candidates,target,[],<span class="number">0</span>,[<span class="literal">False</span>]*<span class="built_in">len</span>(candidates))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311231102774.png" alt="image-20231123110223652"></p><p>优化 + 不适用<code>used</code>数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">candidates,target,startindex,sum_,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> sum_==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;startindex <span class="keyword">and</span> candidates[i]==candidates[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                sum_+=candidates[i]</span><br><span class="line">                <span class="comment"># 这里进行判断，如果超过target则直接break 免去了后面的循环 节省时间开销</span></span><br><span class="line">                <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                backtracking(candidates,target,i+<span class="number">1</span>,sum_,path)</span><br><span class="line">                sum_-=candidates[i]</span><br><span class="line">                path.pop()</span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271001830.png" alt="image-20231127100152702"></p><h2 id="131、分割回文串（-）"><a href="#131、分割回文串（-）" class="headerlink" title="131、分割回文串（*）"></a>131、分割回文串（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311231517950.png" alt="image-20231123151758868"></p><p>本题递归结束的条件是当startindex==字符串s 的长度时，往结果集中添加数据并返回。</p><p>递归的参数是<code>startindex</code>，<code>s</code>和<code>path</code>，需要进行递归的字符串为s[startindex:i+1]进行切片，同时本题要求是回文子串，所以还需要加上判断是否是回文数字，如果是回文数字才进行回溯，不是回文数字的话不进行任何操作。</p><p>在递归体部分，需要一个for循环，其遍历范围是startindex到len(s)，然后往path列表中添加的元素是s[startindex:i+1]，这里注意字符串的切片是左闭右开的，因此这里区间是i+1，然后递归进行遍历backtracking(s,i+1,path)，注意这里的startindex需要从i+1开始，这是因为根据题目的要求，不会有重复出现的子串。在39、组合总数一题中，题目说明candidates中的元素是可以重复出现的，因此我们在进行递归的时候传入的startindex就为for循环遍历的层数i，这样就可以一直递归下去找到符合条件的答案。</p><p>递归三要素</p><ul><li>参数和返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">s, startindex, path</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> startindex==<span class="built_in">len</span>(s):</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>递归体 单层搜索过程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> huiwen(s[startindex:i+<span class="number">1</span>]):</span><br><span class="line">        path.append(s[startindex:i+<span class="number">1</span>])</span><br><span class="line">        backtracking(s,i+<span class="number">1</span>,path)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure><p>全部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">s,startindex,path</span>):</span></span><br><span class="line">            <span class="comment"># print(startindex)</span></span><br><span class="line">            <span class="comment"># 如果分割到字符串末尾，则该轮结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s)==startindex:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># print(s[startindex:i+1])</span></span><br><span class="line">                <span class="comment"># 如果不是回文子串 不往path中添加</span></span><br><span class="line">                <span class="keyword">if</span> huiwen(s[startindex:i+<span class="number">1</span>]):</span><br><span class="line">                    path.append(s[startindex:i+<span class="number">1</span>])</span><br><span class="line">                    backtracking(s,i+<span class="number">1</span>,path)</span><br><span class="line">                    path.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">huiwen</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> s==s[::-<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># i = 0</span></span><br><span class="line">            <span class="comment"># j = len(s)-1</span></span><br><span class="line">            <span class="comment"># while i&lt;j:</span></span><br><span class="line">            <span class="comment">#     if s[i]!=s[j]:</span></span><br><span class="line">            <span class="comment">#         return False</span></span><br><span class="line">            <span class="comment">#     i+=1</span></span><br><span class="line">            <span class="comment">#     j-=1</span></span><br><span class="line">            <span class="comment"># return True</span></span><br><span class="line">        </span><br><span class="line">        backtracking(s,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251702558.png" alt="image-20231125170244551"></p><h2 id="93、复原IP地址（-）"><a href="#93、复原IP地址（-）" class="headerlink" title="93、复原IP地址（*）"></a>93、复原IP地址（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311232157722.png" alt="image-20231123215751666"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311232158813.png" alt="image-20231123215802814"></p><p>本题与分割字符串有几分相似，也属于分割问题。</p><p>递归三要素</p><ul><li>递归参数</li></ul><p>字符串s，startindex和pointNum</p><p>pointNum表示IP地址中的<code>.</code>，如果有三个<code>.</code>的话，就说明当前的IP地址已经被分成四段了。</p><ul><li>递归结束的条件</li></ul><p>根据本题要求，只要我们当前的字符串已经被分割成四段，即pointNum==3的时候，往res列表中添加结果并返回</p><ul><li>单层递归体中的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="comment"># IP 地址合法性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> isValid(s[startindex:i+<span class="number">1</span>]):</span><br><span class="line">        sub = s[startindex:i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 这里不能直接修改 path，而是使用一个副本进行传参</span></span><br><span class="line">        backtracking(i + <span class="number">1</span>, path + sub + <span class="string">&quot;.&quot;</span>, pointNum + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251654603.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">startindex, path, pointNum</span>):</span></span><br><span class="line">            <span class="comment"># 长度剪枝</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) - startindex &gt; (<span class="number">4</span> - pointNum) * <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) - startindex &lt; (<span class="number">4</span> - pointNum):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pointNum == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> isValid(s[startindex:]):</span><br><span class="line">                    res.append(path + s[startindex:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># IP 地址合法性剪枝</span></span><br><span class="line">                <span class="keyword">if</span> isValid(s[startindex:i+<span class="number">1</span>]):</span><br><span class="line">                    sub = s[startindex:i+<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 这里不能直接修改 path，而是使用一个副本进行传参</span></span><br><span class="line">                    backtracking(i + <span class="number">1</span>, path + sub + <span class="string">&quot;.&quot;</span>, pointNum + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> (s[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span>) <span class="keyword">or</span> <span class="built_in">int</span>(s) &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        backtracking(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="78、子集"><a href="#78、子集" class="headerlink" title="78、子集"></a>78、子集</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241002663.png" alt="image-20231124100225029"></p><p>思路：</p><p>如果把子集问题抽象成一颗树的话，组合问题和分割问题都是收集树的叶子结点，子集问题是找树的所有结点。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251351905.png" alt="78.子集"></p><p>子集是无序的，{1,2}和{2,1}是等价的，也就是说之前取过的元素后面不会再取，因此在递归的过程中还需要传递一个参数startindex，每次都是从startindex继续往后进行搜索，而不是从0开始，如果是排列问题的话，for循环就要从0开始了，因为在排列中{1,2}和{2,1}是两个不一样的排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,startindex,path</span>):</span></span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="comment"># 这里不需要加递归结束的条件，当startindex达到len(nums)的时候程序也就自动返回了</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="90、子集II（-）"><a href="#90、子集II（-）" class="headerlink" title="90、子集II（*）"></a>90、子集II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241018069.png" alt="image-20231124101803120"></p><p>本题和上一题的区别在于nums数组中可能包含重复元素，我们首先将其进行==排序==，然后在往res列表中添加数据的时候，进行判断只有不在res列表中的结果才能添加进去。其余部分和上一题一样。</p><ul><li>使用<code>in</code>操作去重</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># nums = list(set(nums))</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startindex, path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            <span class="keyword">if</span> startindex&gt;<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题是树层去重，在同一层重复出现的需要去除重复值。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241804501.png" alt="90.子集II"></p><ul><li>直接判断去重</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,startindex,path</span>):</span></span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;startindex <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums, i+<span class="number">1</span>, path)</span><br><span class="line">                path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>使用==used数组==去重（推荐）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,startindex,path,used</span>):</span></span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">if</span> startindex &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>,path,used)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[],used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311241804501.png" alt="90.子集II"></p><h2 id="491、递增子序列（-）"><a href="#491、递增子序列（-）" class="headerlink" title="491、递增子序列（*）"></a>491、递增子序列（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311242113731.png" alt="image-20231124211319729"></p><p>本题需要再输入的序列中找到全部的递增子序列，同时需要注意的是题目中输入的数组会包含重复的元素，并且说明如果出现两个整数相等也会看作是递增序列的一种特殊情况。</p><p>利用回溯的思路，我们写出递归的三要素：</p><ul><li>参数和返回值</li></ul><p>参数有：nums 、 startindex用于记录下一层遍历的起始位置 path 结果列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startindex, path</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>题目中要求递增子序列中至少2个元素，因此可以判断如果len(path)&gt;1则往res列表中添加结果并返回</p><p>这里需要注意，不能加return，加上了return的话，就会导致同一个树枝上的其他结果不能得到保存，这点类似于子集问题，子集问题是需要寻找叶子上的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;<span class="number">1</span>:</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="comment"># return </span></span><br></pre></td></tr></table></figure><ul><li>单层搜索逻辑</li></ul><p>本题需要寻找递增子序列，不像之前的题目可以直接通过排序解决去重问题，因此需要使用另一种去重的方式，使用python中的集合，在Python中集合也是一个哈希表，可以在O(1)时间复杂度查询到想要的结果。</p><p>这里注意条件是和递增是并列的，即如果该数字已经在uset中，说明已经使用过了，需要跳过该数字。</p><p>同时uset是在每一层都会重新进行定义的，uset只会负责本层的结果。同一个父节点下的一层内如果出现重复数字则直接跳过</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301837303.png" alt="491. 递增子序列1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uset = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> (path <span class="keyword">and</span> path[-<span class="number">1</span>]&gt;=nums[i]) <span class="keyword">or</span> nums[i] <span class="keyword">in</span> uset:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        uset.add(nums[i])</span><br><span class="line">        path.append(nums[i])</span><br><span class="line">        backtracking(nums,i+<span class="number">1</span>,path)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubsequences</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,path,startindex</span>):</span></span><br><span class="line">            <span class="keyword">if</span> startindex&gt;<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;<span class="number">1</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            uset = <span class="built_in">set</span>()  <span class="comment"># 使用集合对本层元素进行去重</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> (path <span class="keyword">and</span> path[-<span class="number">1</span>]&gt;nums[i]) <span class="keyword">or</span> nums[i] <span class="keyword">in</span> uset:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                uset.add(nums[i])</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,path,i+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">                </span><br><span class="line">        backtracking(nums,[],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311242134495.png" alt="image-20231124213406251"></p><h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、全排列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311242145906.png" alt="image-20231124214516935"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,path,used</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)==<span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                used[i]=<span class="literal">True</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,path,used)</span><br><span class="line">                used[i]=<span class="literal">False</span></span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking(nums,[],used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>全排列和组合问题、切割问题以及子集问题的区别就在于每次遍历都需要==从0开始==，而不是传进来的startindex，也就是说全排列问题中是不需要startindex的。</p><p>另外在之前的几种问题中，有几个我们传入参数不是i+1而是i的，这是因为题目中说明可以出现重复元素。如果要求是不能出现重复元素的话，只能传入i+1。</p><p>递归三部曲</p><ul><li>参数和返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,path,used</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path)==<span class="built_in">len</span>(nums):</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><ul><li>单层搜索逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> used[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    used[i]=<span class="literal">True</span></span><br><span class="line">    path.append(nums[i])</span><br><span class="line">    backtracking(nums,path)</span><br><span class="line">    used[i]=<span class="literal">False</span></span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251123623.png" alt="image-20231125112358453"></p><h2 id="47、全排列II（-）"><a href="#47、全排列II（-）" class="headerlink" title="47、全排列II（*）"></a>47、全排列II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311242158725.png" alt="image-20231124215605773"></p><p>本题因为nums中包含重复的数字，因此需要去重，去重的时候因为需要判断相邻的两个数是否相等，所以在一开始需要对nums进行<strong>排序</strong>。之后本题的和全排列的区别就在于需要判断相邻的两数是否相等并且前一个数是否没有用过。</p><p>除此之外，如果层内使用过我们也应该</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums,path,used</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)==<span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 这里的used[i-1] 如果等于False 说明在同一层已经使用过了</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 在同一个树枝上 如果used[i]==False可以继续使用</span></span><br><span class="line">                <span class="keyword">if</span> used[i]==<span class="literal">False</span>:</span><br><span class="line">                    used[i]=<span class="literal">True</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    backtracking(nums,path,used)</span><br><span class="line">                    used[i]=<span class="literal">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtracking(nums,[],used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>组合问题</strong>和<strong>排列问题</strong>是在树形结构的叶子结点上收集结果，而子集问题就是取树上所有结点的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311251128085.png" alt="image-20231125112843814"></p><h2 id="784、字母大小写全排列"><a href="#784、字母大小写全排列" class="headerlink" title="784、字母大小写全排列"></a>784、字母大小写全排列</h2><h2 id="322、重新安排行程（hard"><a href="#322、重新安排行程（hard" class="headerlink" title="322、重新安排行程（hard)"></a>322、重新安排行程（hard)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271037450.png" alt="image-20231127103728274"></p><h2 id="51、N皇后"><a href="#51、N皇后" class="headerlink" title="51、N皇后"></a>51、N皇后</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271114531.png" alt="image-20231127111457348"></p><p><strong>递归参数</strong></p><p>定义res来存放最终的结果，n棋盘大小，row记录当前遍历到棋盘的第几层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>递归终止条件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271119405.jpg" alt="51.N皇后"></p><p>当递归到叶子结点的时候就可以收集结果了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> row==n:</span><br><span class="line">    res.append(chessboard)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p><strong>单层递归逻辑</strong></p><p>遍历这个棋盘的每一行，在python中，二维数组的表示就用嵌套列表表示即可。</p><p>验证棋盘是否合法</p><ul><li>皇后不能同行</li><li>皇后不能同列</li><li>皇后不能斜对角线（45度和135度）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, chessboard</span>):</span></span><br><span class="line">            <span class="comment"># 列检查</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 45°角检查 这里的检查是从row col往前找</span></span><br><span class="line">            i,j = row-<span class="number">1</span>,col-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 135°角检查</span></span><br><span class="line">            i,j = row-<span class="number">1</span>, col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(chessboard):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j]==<span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span>    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n,row,chessboard</span>):</span></span><br><span class="line">            <span class="comment"># 递归终止的条件 当递归参数row==n时就进行发返回 并将结果添加到res中</span></span><br><span class="line">            <span class="keyword">if</span> row==n:</span><br><span class="line">                res.append(chessboard[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 对棋盘的每一行进行操作 判断是否合法</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> isValid(row,col,chessboard):</span><br><span class="line">                    chessboard[row] = chessboard[row][:col] + <span class="string">&quot;Q&quot;</span> + chessboard[row][col+<span class="number">1</span>:]</span><br><span class="line">                    backtracking(n,row+<span class="number">1</span>,chessboard)</span><br><span class="line">                    chessboard[row] = chessboard[row][:col] + <span class="string">&quot;.&quot;</span> + chessboard[row][col+<span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, chessboard</span>):</span></span><br><span class="line">            <span class="comment"># 列检查</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 45°角检查 这里的检查是从row col往前找</span></span><br><span class="line">            i,j = row-<span class="number">1</span>,col-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 135°角检查</span></span><br><span class="line">            i,j = row-<span class="number">1</span>, col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(chessboard):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j]==<span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        chessboard = [<span class="string">&quot;.&quot;</span>*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n) ]</span><br><span class="line">        print(chessboard)</span><br><span class="line">        backtracking(n,<span class="number">0</span>,chessboard)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><h1 id="回溯总结"><a href="#回溯总结" class="headerlink" title="回溯总结"></a>回溯总结</h1><p>一般情况下，如果题目中要求不能出现重复的数据，需要搭配这used数组进行使用，除此之外还需要对集合进行一个排序，这样可以在值相同的情况下进行判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><code>used[i-1]==False</code> 说明在同一层的前面结点已经使用过该数据了，后面不需要重复进行操作。</p><p>如果集合中存在重复的数字序列，则需要对其进行排序</p><ul><li>组合总数II</li><li>子集II</li><li>全排列II</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot; class=&quot;headerlink&quot; title=&quot;回溯算法&quot;&gt;&lt;/a&gt;回溯算法&lt;/h1&gt;&lt;p&gt;回溯算法是一种搜索的方法，在二叉树总结当中，经常使用到递归去解决相关的问题，在二叉树的&lt;strong&gt;所有路径&lt;/stron</summary>
      
    
    
    
    
    <category term="回溯" scheme="https://guoxiansen.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树相关总结</title>
    <link href="https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</id>
    <published>2023-11-02T11:30:47.000Z</published>
    <updated>2023-12-23T11:21:41.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021939061.png" alt="image-20231102193927953"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的理论基础"><a href="#二叉树的理论基础" class="headerlink" title="二叉树的理论基础"></a>二叉树的理论基础</h2><p>二叉树是结点的度数之和不超过2的树，二叉树总共有五种基本形态</p><p>二叉树的种类主要有</p><ul><li>满二叉树</li><li>完全二叉树</li></ul><p>二叉树的存储方式</p><ul><li>顺序存储</li><li>链式存储</li></ul><p>二叉树的遍历方式</p><ul><li>先序遍历（深度优先搜索）</li><li>中序遍历（深度优先搜索）</li><li>后序遍历（深度优先搜索）</li><li>层次遍历（广度优先搜索）</li></ul><p>对于二叉树结点的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val] </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311022036965.png" alt="image-20231102203600726"></p><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>方法1：利用栈先进后出的性质，先把右孩子结点放入栈中，再将左孩子结点放入栈中，这样就可以先访问根节点， 在访问左孩子，最后访问右孩子了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># print(node)</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2：按照中序遍历的算法，只需要将添加<code>append</code>操作放到前面去即可。但需要控制两个指针。</p><p>思路：沿着左子树一直往左下方走，左孩子不为空就一直进栈，同时将其值添加到res列表中。如果左孩子为空，则弹出栈顶元素，然后再访问该结点的右孩子，再重复上述的操作直到遍历结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历参考先序遍历<strong>思路2</strong>，区别就是只需要<code>append</code>语句放到当<code>cur</code>指针为空的时候里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311022035056.png" alt="image-20231102203511759"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>思路：在进行先序遍历的时候，我们的思路是利用栈，首先访问根结点，然后将右子树添加到栈中，再将左子树添加到栈中，实现的效果是<strong>根左右</strong>的效果，而在进行后序遍历的时候，我们需要的的顺序是<strong>左右根</strong>，如果我们先序遍历算法中左右子树进栈的顺序修改之后，刚好可以得到我们后续遍历结果的逆序结果，最终的返回值设置为<code>res[::-1]</code>即为最终答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.left &#x3D; left</span><br><span class="line">#         self.right &#x3D; right</span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        stack &#x3D; [root]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while stack:</span><br><span class="line">            node &#x3D; stack.pop()</span><br><span class="line">            # 根 右 左</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        # 左 右 根</span><br><span class="line">        return res[::-1]</span><br></pre></td></tr></table></figure><h2 id="二叉树三种遍历算法的统一非递归算法"><a href="#二叉树三种遍历算法的统一非递归算法" class="headerlink" title="二叉树三种遍历算法的统一非递归算法"></a>二叉树三种遍历算法的统一非递归算法</h2><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>层次遍历需要借助队列来实现，队列先进先出的特点可以很好的满足层次遍历按层遍历的需要。</p><p>代码模板（以力扣为标准）</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021933135.png" alt="image-20231102193339525"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021936728.png" alt="image-20231102193628125"></p><p>上面的代码还可以进行优化，Python中列表在进行pop(0)的时候，需要移动后面的元素，会导致时间复杂度变高，可以在用<code>collections</code>类中提供的双端队列<code>deque</code>来方便在队头队尾进行元素的插入和删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><code>list</code>：和添加操作类似，从<code>list</code>尾部移除（<code>pop</code>）元素是很快的，时间复杂度为O(1)。但从头部移除（<code>pop(0)</code>）元素则时间复杂度为O(n)。</li><li><code>deque</code>：<code>deque</code>同样能够在两端移除元素，无论是<code>popleft</code>还是<code>pop</code>，时间复杂度都是O(1)。</li></ul><p>这点在进行N叉树的层次遍历的时候可以体现的比较明显</p><h3 id="429、N叉树的层次遍历"><a href="#429、N叉树的层次遍历" class="headerlink" title="429、N叉树的层次遍历"></a>429、N叉树的层次遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081705777.png" alt="image-20231208170548739"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 使用双端队列存放</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="comment"># N叉树 遍历孩子结点 ，孩子结点是一个可以迭代的对象</span></span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">                    queue.append(child)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081705911.png" alt="image-20231208170444573"></p><h3 id="1609、奇偶数"><a href="#1609、奇偶数" class="headerlink" title="1609、奇偶数"></a>1609、奇偶数</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081717865.png" alt="image-20231208171744921"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081717454.png" alt="image-20231208171756572"></p><p>本题可以直接使用层次遍历，在遍历的过程中使用pre记录前一个结点，然后两个结点相减如果不满足题目的要求则返回false，在层次遍历的过程中用tag记录当前遍历的层数，如果层数和对应的数字奇偶不符，也返回False，直到程序运行结束返回True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEvenOddTree</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 树中节点数至少为1  不用判断树为空的情况</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        tag = <span class="number">0</span>  <span class="comment"># 用于判断层数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="keyword">if</span> tag%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> tag%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.val%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">or</span> node.val-pre&lt;=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.val%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">or</span> node.val-pre&gt;=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre = node.val</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            tag+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>本题中，使用list和使用deque的性能差别是非常明显的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081720054.png" alt="image-20231208172036534"></p><p>二叉树的层次遍历可以衍生出非常多的变种题目。</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II(opens new window)</a><ul><li>本题和层次遍历的区别就是只需要返回res列表的逆序即可。</li></ul></li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图(opens new window)</a></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II(opens new window)</a></li><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度</a></li></ul><h3 id="199、二叉树的右视图"><a href="#199、二叉树的右视图" class="headerlink" title="199、二叉树的右视图"></a>199、二叉树的右视图</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031016316.png" alt="image-20231103101656058"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># tmp.append(node.val)</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                tmp = node.val</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031016068.png" alt="image-20231103101640796"></p><h3 id="111、二叉树的最小深度"><a href="#111、二叉树的最小深度" class="headerlink" title="111、二叉树的最小深度"></a>111、二叉树的最小深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311060955485.png" alt="image-20231106095458959"></p><p>本题的解题思路与二叉树的最大深度大同小异，唯一的区别就是在循环中进行判断当前节点的左右孩子结点是否为空，如果为空，则直接返回depth即可，如果不为空就一直进行循环，最后再返回depth，代码的主体框架与层次遍历是一致的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311060957166.png" alt="层次遍历时间"></p><h2 id="二叉树的深度与高度"><a href="#二叉树的深度与高度" class="headerlink" title="二叉树的深度与高度"></a>二叉树的深度与高度</h2><p>二叉树的深度与高度有一些区别，其中二叉树中的深度是指从根结点到该节点的路径长度。高度是指从叶子结点到当前结点的路径长度。</p><p>结点的<strong>深度</strong>是从根结点开始<strong>自顶向下</strong>逐层累加的。</p><p>结点的<strong>高度</strong>是从叶子结点开始<strong>自底向上</strong>逐层累加的。</p><p>在力扣中有几道题目是与二叉树的深度相关，一般而言如果是需要求深度的，都采用先序遍历的方法，因为先序遍历先遍历根结点，然后遍历孩子结点就可以得出其深度。满足其自顶向下的特点。一般而言可以采用递归方法。</p><p>深度：先序遍历 | 层次遍历</p><p>高度：后续遍历</p><ul><li>104.二叉树的最大深度</li><li>559.n叉树的最大深度</li><li>111.二叉树的最小深度</li></ul><p>根结点的高度就是二叉树的最大深度。</p><h3 id="104、二叉树的最大深度"><a href="#104、二叉树的最大深度" class="headerlink" title="104、二叉树的最大深度"></a>104、二叉树的最大深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131941621.png" alt="image-20231113191706720"></p><p>求最大深度，需要从根结点开始自定向下进行深度优先搜索DFS，因此采用先序遍历，采用递归的实现方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先序遍历求最大深度 根左右   深度是从根节点到最后  高度是从叶子结点到当前节点的高度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line">        height = <span class="number">1</span> + <span class="built_in">max</span>(left_height,right_height)</span><br><span class="line">        <span class="keyword">return</span> height</span><br></pre></td></tr></table></figure><p>其中代码还可以精简为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(self.maxDepth(root.left),self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940044.png" alt="image-20231113192723426"></p><h3 id="559、n叉树的最大深度"><a href="#559、n叉树的最大深度" class="headerlink" title="559、n叉树的最大深度"></a>559、n叉树的最大深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940525.png" alt="image-20231113192558344"></p><p>解题思路与二叉树的最大深度一致，唯一的区别就是通过for循环去遍历孩子结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> root.children:</span><br><span class="line">            max_depth = <span class="built_in">max</span>(max_depth,self.maxDepth(ch))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max_depth</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940106.png" alt="image-20231113192704871"></p><h3 id="111、二叉树的最小深度-1"><a href="#111、二叉树的最小深度-1" class="headerlink" title="111、二叉树的最小深度"></a>111、二叉树的最小深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940290.png" alt="image-20231113192853117"></p><p>解题思路和求最大深度差不多，但是又有一个特殊情况，就是当二叉树为单分支的情况，即当出现某个节点的左孩子或者右孩子其中之一为空的时候，深度就要取最右孩子中的最大值了，否则就会结果为0+1。其余的情况就取最小值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_depth = self.minDepth(root.left)</span><br><span class="line">        right_depth = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left_depth,right_depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">min</span>(left_depth,right_depth)</span><br></pre></td></tr></table></figure><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><h3 id="110、平衡二叉树"><a href="#110、平衡二叉树" class="headerlink" title="110、平衡二叉树"></a>110、平衡二叉树</h3><p>平衡二叉树的定义是左右子树的高度之差不超过1的二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940948.png" alt="image-20231113193458877"></p><p>代码</p><p>定义一个获取结点高度的函数<code>get_height()</code>，如果当前结点为空，则返回0，然后分别获取该结点左孩子和右孩子的高度，如果左右孩子高度返回值是-1，则也返回-1，否则在判断左右子树高度之差是否大于1，如果大于1则也返回-1，如果左右子树高度之差小于1，则返回<code>1+max(left_height, right_height)</code>。主程序中，只需要判断对根节点进行判断<code>get_height(root)</code>是否为-1即可判断该二叉树是否是平衡二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_height</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_height = get_height(root.left)</span><br><span class="line">            <span class="keyword">if</span> left_height==-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            right_height = get_height(root.right)</span><br><span class="line">            <span class="keyword">if</span> right_height==-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(left_height-right_height)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left_height,right_height)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> get_height(root)!=-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141931314.png" alt="image-20231114193151177"></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="116、翻转二叉树"><a href="#116、翻转二叉树" class="headerlink" title="116、翻转二叉树"></a>116、翻转二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141348128.png" alt="image-20231114134848424"></p><p>由示例可以看出，本题实际上需要实现的功能是沿着中间的一个轴翻转这颗二叉树，其本质实际只需要将二叉树每个结点的左右子树进行翻转即可。</p><p>翻转二叉树的核心思想就是：==<strong>将二叉树中的每个节点的左右孩子进行交换即可。</strong>==</p><p>需要注意的是，本题不能采用中序遍历的方法，可以采用先序遍历或者后序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>中序遍历的时候可能会对一些节点重复的调换导致错误。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141442054.png" alt="image-20231114144227076"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 采用后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        root.left,root.right = right,left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231920040.png" alt="image-20231223191938312"></p><h2 id="101、对称二叉树"><a href="#101、对称二叉树" class="headerlink" title="101、对称二叉树"></a>101、对称二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031112657.png" alt="image-20231103111251882"></p><p>本题思路与翻转二叉树有点区别，翻转二叉树是直接对比左右孩子结点的值是否相等即可判断，而本题需要判断的是（例如在第三层中，判断根节点左孩子2的左孩子是否与根结点右孩子2的右孩子是否相等）对比的其实是外侧与外侧，内侧与内侧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">left,right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            out = compare(left.left,right.right)</span><br><span class="line">            inner = compare(left.right,right.left)</span><br><span class="line">            <span class="keyword">return</span> out <span class="keyword">and</span> inner</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right)</span><br></pre></td></tr></table></figure><h2 id="100、相同的树"><a href="#100、相同的树" class="headerlink" title="100、相同的树"></a>100、相同的树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141526042.png" alt="image-20231114152650867"></p><p>思路基本与对称二叉树一致，需要对两棵树的结点的值以及左右子树的值进行对比，如果不相同则返回，相等则继续递归，知道递归结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        if not p and not q: return True</span><br><span class="line">        elif not p or not q: return False</span><br><span class="line">        elif p.val!&#x3D;q.val: return False</span><br><span class="line"></span><br><span class="line">        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141527981.png" alt="image-20231114152707949"></p><h2 id="572、另一棵树的子树"><a href="#572、另一棵树的子树" class="headerlink" title="572、另一棵树的子树"></a>572、另一棵树的子树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141519990.png" alt="image-20231114151903739"></p><p>解题思路与相同的树一致，只需要遍历<code>root</code>这棵树的每个结点，然后再与<code>subRoot</code>进行判断是否是相同的树即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root: Optional[TreeNode], subRoot: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSame</span>(<span class="params">s,t</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> s.val!=t.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> isSame(s.left,t.left) <span class="keyword">and</span> isSame(s.right,t.right)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 遍历root的所有结点与subRoot进行比较</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isSame(node,subRoot):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141520178.png" alt="image-20231114152036046"></p><h2 id="222、完全二叉树的节点数量"><a href="#222、完全二叉树的节点数量" class="headerlink" title="222、完全二叉树的节点数量"></a>222、完全二叉树的节点数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061044923.png" alt="image-20231106104412026"></p><p>解题思路1：可以直接按照普通二叉树的遍历进行记录总共多少个结点（前中后序遍历+层次遍历都可以解决这个问题），时间复杂度为 O(n)</p><p>（此方法没有利用完全二叉树的性质）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061046621.png" alt="image-20231106104634852"></p><p>使用层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                num+=<span class="number">1</span></span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141934586.png" alt="image-20231114193418762"></p><p>解题思路2：利用完全二叉树的性质，如果是满二叉树结点的数量可以用2的深度-1次方 再 -1 来进行计算。时间复杂度为O(logn * logn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        leftdepth = <span class="number">0</span></span><br><span class="line">        rightdepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            leftdepth+=<span class="number">1</span></span><br><span class="line">            left=left.left</span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            rightdepth+=<span class="number">1</span></span><br><span class="line">            right=right.right</span><br><span class="line">        <span class="keyword">if</span> leftdepth==rightdepth:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftdepth)-<span class="number">1</span></span><br><span class="line">        leftnum = self.countNodes(root.left)</span><br><span class="line">        rightnum = self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">return</span> leftnum+rightnum+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061049909.png" alt="image-20231106104900697"></p><h2 id="257、二叉树的所有路径"><a href="#257、二叉树的所有路径" class="headerlink" title="257、二叉树的所有路径"></a>257、二叉树的所有路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141554968.png" alt="image-20231114155412077"></p><p>本题使用DFS与BFS均可解决。</p><p>使用DFS的时候需要注意在递归的过程中如果当前结点为空则不进行处理，不为空时才进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 使用DFS解决</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="comment"># node结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                path+=<span class="built_in">str</span>(node.val)</span><br><span class="line">                <span class="comment"># 叶子结点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    paths.append(path)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path+=<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        paths = []</span><br><span class="line">        find_path(root,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141605715.png" alt="image-20231114160516588"></p><p>使用BFS解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 使用BFS 层次遍历</span></span><br><span class="line">        paths = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> paths</span><br><span class="line">        </span><br><span class="line">        queue = [root]</span><br><span class="line">        path_lst = [<span class="built_in">str</span>(root.val)]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            path = path_lst.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                paths.append(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                    path_lst.append(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(node.left.val))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                    path_lst.append(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141625644.png" alt="image-20231114162537557"></p><h2 id="113、路径总和II"><a href="#113、路径总和II" class="headerlink" title="113、路径总和II"></a>113、路径总和II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141607596.png" alt="image-20231114160701463"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="comment"># path+=[node.val]</span></span><br><span class="line">                path=path+[node.val]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span>(path)==targetSum:</span><br><span class="line"></span><br><span class="line">                        paths.append(path)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        paths = []</span><br><span class="line">        find_path(root,[])</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141618342.png" alt="image-20231114161838454"></p><p>这里需要注意一个问题，就是<code>path+=[node.val]</code>和<code>path=path+[node.val]</code>这两句代码的写法有点不同，+=是在原来的path上进行修改，而直接赋值是可以形成一个新的列表，在递归的过程中就出现一个新的列表。这是由于python中列表是可变类型的，如果列表也是和字符串一样属于不可变类型的话，就可以直接使用+=操作了。</p><h2 id="988、从叶结点开始的最小字符串"><a href="#988、从叶结点开始的最小字符串" class="headerlink" title="988、从叶结点开始的最小字符串"></a>988、从叶结点开始的最小字符串</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141700936.png" alt="image-20231114170051688"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141701926.png" alt="image-20231114170117467"></p><p>本题思路与二叉树的所有路径思路一致，只需要在其中添加一个用来进行比较的变量即可，注意这里所说的变量不可以是字符串，因为字符串是不可修改的。这里也需要注意是从叶子结点开始的，所以最终求得的路径path需要进行逆序处理[::-1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestFromLeaf</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                path+=<span class="built_in">str</span>(myhash[node.val])</span><br><span class="line">                <span class="comment"># print(node.val,path)</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    minleaf[<span class="number">0</span>] = <span class="built_in">min</span>(minleaf[<span class="number">0</span>],path[::-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        myhash = &#123;i: <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)&#125;</span><br><span class="line">        minleaf = [<span class="string">&quot;z&quot;</span>*<span class="number">8500</span>]</span><br><span class="line">        find_path(root,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> minleaf[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141702599.png" alt="image-20231114170241494"></p><h2 id="404、左叶子之和"><a href="#404、左叶子之和" class="headerlink" title="404、左叶子之和"></a>404、左叶子之和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311142043922.png" alt="image-20231114204344749"></p><p>思路：</p><p>本题采用DFS的方式去解决。需要注意到底什么是左叶子，左叶子是指该节点不为空，同时其左右孩子为空，通过递归的方式去寻找这样的结点，然后对其求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 递归程序如果碰到结点为空则返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果该节点没有左右孩子 也返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        left_num = self.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="comment"># 如果有左孩子并且孩子为叶子结点则进行统计</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            left_num = root.left.val</span><br><span class="line">        right_num = self.sumOfLeftLeaves(root.right)</span><br><span class="line">        <span class="keyword">return</span> left_num + right_num</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311161713500.png" alt="image-20231116171305355"></p><h2 id="236、二叉树的最近公共祖先"><a href="#236、二叉树的最近公共祖先" class="headerlink" title="236、二叉树的最近公共祖先"></a>236、二叉树的最近公共祖先</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311161714944.png" alt="image-20231116171451621"></p><p>从下往上对结点进行处理，采用后序遍历的方法，先左再右再中</p><p>情况1： p和q都为某个节点的孩子结点</p><p>情况2：p是q的父节点或者q是p的父节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root==q <span class="keyword">or</span> root==p:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> right <span class="keyword">and</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h2 id="106、从中序和后序遍历序列构造二叉树"><a href="#106、从中序和后序遍历序列构造二叉树" class="headerlink" title="106、从中序和后序遍历序列构造二叉树"></a>106、从中序和后序遍历序列构造二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171658001.png" alt="image-20231117165833569"></p><p>思路：</p><p>首先在后序遍历序列中找到根结点，然后创建一个根节点</p><p>找到切割的位置</p><ul><li><p>对先序序列进行切割，分为左子树和右子树</p></li><li><p>对后序序列进行切割，分为左子树和右子树</p></li><li><p>构造根节点的左子树，使用递归的方法，传递进去的参数是先序数组的左边和中序数组的左边</p></li><li><p>构造根节点的右子树，使用递归的方法，传递进去的参数是先序数组的右边和中序数组的右边</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到根结点</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        <span class="comment"># 找到切割位置</span></span><br><span class="line">        qiege = inorder.index(root_val)</span><br><span class="line"></span><br><span class="line">        inorder_left = inorder[:qiege]</span><br><span class="line">        inorder_right = inorder[qiege+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        postorder_left = postorder[:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(inorder_left,postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right,postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="654、最大二叉树"><a href="#654、最大二叉树" class="headerlink" title="654、最大二叉树"></a>654、最大二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171926482.png" alt="image-20231117192616419"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171926733.png" alt="image-20231117192638755"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111915337.png" alt="image-20231211191504330"></p><p>思路：使用递归的方式</p><p>递归三部曲</p><ul><li><h4 id="递归函数的参数和返回值"><a href="#递归函数的参数和返回值" class="headerlink" title="递归函数的参数和返回值"></a>递归函数的参数和返回值</h4></li></ul><p>返回值为TreeNode类型</p><p>参数为nums数组</p><ul><li><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h4></li></ul><p>题目中的范围nums的长度是大于等于1的，因此不需要考虑nums为空的情况</p><ul><li><h4 id="单层递归逻辑"><a href="#单层递归逻辑" class="headerlink" title="单层递归逻辑"></a>单层递归逻辑</h4></li></ul><ol><li><p>找到数组中最大值的下标，最大值用来构造根节点，下标用来对数组进行切割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maxValue = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">maxIndex = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    <span class="keyword">if</span> maxValue&lt;value:</span><br><span class="line">        maxValue = value</span><br><span class="line">        maxIndex = i</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>最大值左区间 构造左子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> maxIndex &gt; <span class="number">0</span>:</span><br><span class="line">    new_list = nums[:maxIndex]</span><br><span class="line">    node.left = self.</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>最大值右区间 构造右子树</li></ol><p>首先根据最大值对该数组进行切割，切割完毕后，根据数组的左边与右边分别进行递归，这类似于106从中序和后序遍历序列构造二叉树。最终返回构造好的二叉树root。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        root_val = <span class="built_in">max</span>(nums)</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">        qiege = nums.index(root_val)</span><br><span class="line">        nums_left = nums[:qiege]</span><br><span class="line">        nums_right = nums[qiege+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums_left)</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171928921.png" alt="image-20231117192833812"></p><h2 id="998、最大二叉树II"><a href="#998、最大二叉树II" class="headerlink" title="998、最大二叉树II"></a>998、最大二叉树II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929018.png" alt="image-20231117192902002"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929352.png" alt="image-20231117192919398"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929719.png" alt="image-20231117192933861"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929329.png" alt="image-20231117192954360"></p><p>本题和上一题相比，难点就在于可能需要对这颗二叉树进行重新构造，但是在构造的过程中也有省事的地方，就是只需要往右插入。如果<code>val</code>值大于原树的根节点值，则直接将原树放在<code>val</code>结点的左子树即可。如果小于最大值，向右子树进行遍历，同时记录当前结点的父节点，方便<code>val</code>结点的插入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoMaxTree</span>(<span class="params">self, root: Optional[TreeNode], val: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 遍历root 往右子树遍历</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val&gt;val:</span><br><span class="line">            <span class="comment"># 记录当前结点的父节点</span></span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="comment"># 如果val大于原树的最大值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">            node.left = cur</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># 遍历到了右子树合适的位置 换结点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            prev.right = node</span><br><span class="line">            node.left = cur</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="98、验证二叉搜索树（二叉排序树BST）"><a href="#98、验证二叉搜索树（二叉排序树BST）" class="headerlink" title="98、验证二叉搜索树（二叉排序树BST）"></a>98、验证二叉搜索树（二叉排序树BST）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172201462.png" alt="image-20231117220106841"></p><p>本题思路很简单，利用二叉排序树的性质即可：二叉排序树中序遍历的结果是递增的。</p><p>方法：</p><ul><li>采用非递归遍历算法  设置最小值 在中序递归的过程中进行比较</li><li>采用迭代法，设置最小值，如果出现不满足性质的节点直接返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归遍历算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 添加一个最小值 每次进行比较的时候更新最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.min_= <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 左</span></span><br><span class="line">        left = self.isValidBST(root.left)</span><br><span class="line">        <span class="comment"># 根</span></span><br><span class="line">        <span class="keyword">if</span> self.min_ &lt; root.val:</span><br><span class="line">            self.min_ = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        right = self.isValidBST(root.right)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172204241.png" alt="image-20231117220442215"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归遍历算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 中序遍历 判断值是否小于等于</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="comment"># print(min_,p.val)</span></span><br><span class="line">                <span class="keyword">if</span> min_ &lt; p.val:</span><br><span class="line">                    min_ = p.val</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172204453.png" alt="image-20231117220417506"></p><h2 id="501、二叉搜索树中的众数"><a href="#501、二叉搜索树中的众数" class="headerlink" title="501、二叉搜索树中的众数"></a>501、二叉搜索树中的众数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311182037439.png" alt="image-20231118203749353"></p><p>思路：</p><p>对二叉树进行中序遍历，遍历的过程中统计字符出现的最大次数。其中在递归的过程中需要将<code>max_freq</code>指定为全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> max_freq</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)</span><br><span class="line">            myhash[root.val] = myhash.get(root.val,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, myhash[root.val])</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [k <span class="keyword">for</span> k,v <span class="keyword">in</span> myhash.items() <span class="keyword">if</span> v==max_freq]</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311182037815.png" alt="image-20231118203735546"></p><ul><li>使用迭代法的中序遍历同时不使用字典来统计出现的频率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 使用迭代法的中序遍历</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        freq = <span class="number">0</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    freq = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> pre.val == p.val:</span><br><span class="line">                    freq+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freq = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果频率和最大频率相等 则往结果数组中添加</span></span><br><span class="line">                <span class="keyword">if</span> freq==max_freq:</span><br><span class="line">                    res.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> freq &gt; max_freq:</span><br><span class="line">                    res = [p.val]</span><br><span class="line">                    max_freq = freq</span><br><span class="line">                pre = p</span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个方法的核心是用<code>freq</code>和<code>max_freq</code>进行比较，同时使用<code>pre</code>指针指向前一个结点，这样就方便在中旬遍历的过程中记录已经出现的结点值了。有如下几种情况：</p><ul><li>针对<code>pre</code><ul><li>如果<code>pre</code>为<code>None</code>，则更新<code>freq</code>=1</li><li>如果<code>pre</code>不为<code>None</code>且<code>pre</code>的值与<code>p</code>的值相等，则将<code>freq</code>+1</li><li>如果<code>pre</code>不为<code>None</code>且<code>pre</code>的值与``p<code>不相等，仍然将</code>freq`=1</li></ul></li><li>针对<code>freq</code>和<code>max_freq</code><ul><li>如果<code>freq==max_freq</code>，则往返回值的列表中添加该元素（p.val 即结果的众数）</li><li>如果<code>freq&gt;max_freq</code>，则对res列表进行更新，同时更新<code>max_freq</code></li><li>如果<code>freq&lt;max_freq</code>，可以不进行任何处理</li></ul></li></ul><h2 id="701、二叉搜索树中的插入"><a href="#701、二叉搜索树中的插入" class="headerlink" title="701、二叉搜索树中的插入"></a>701、二叉搜索树中的插入</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201059012.png" alt="image-20231120105950581"></p><p>遍历二叉树直到该值应该出现的地方为止，利用二叉搜索树的性质，如果根节点的值小于value，则再右子树进行递归，否则在左子树进行递归。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: Optional[TreeNode], val: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 根</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val&gt;val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201101896.png" alt="image-20231120110120885"></p><h2 id="450、二叉搜索树中的删除"><a href="#450、二叉搜索树中的删除" class="headerlink" title="450、二叉搜索树中的删除"></a>450、二叉搜索树中的删除</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201044219.png" alt="image-20231120104451186"></p><p>题目中要求的返回值是<strong>二叉搜索树中可能被更新的根结点的引用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val==key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left =  self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201058168.png" alt="image-20231120105811069"></p><h2 id="108、将有序数组转化为二叉搜索树"><a href="#108、将有序数组转化为二叉搜索树" class="headerlink" title="108、将有序数组转化为二叉搜索树"></a>108、将有序数组转化为二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211024882.png" alt="image-20231121102406870"></p><p>思路：本题思路类似于从106、中序和后序遍历构序列构造二叉树和654、最大二叉树的解题思路，需要找到中间的切割点，然后通过递归的方式分别构造左右子树，需要注意的就是对于递归的结束条件的处理如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>一共两种情况，因为再往下就涉及到数组的切割问题。</p><ul><li>如果数组为空，则直接返回None</li><li>如果数组的长度为1，则直接返回以数组中唯一元素构造出二叉树结点即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 本题思路就是通过数组来构造一颗二叉树，需要保持树的平衡，方法将就是从中间进行构造</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        qiege = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># print(qiege)</span></span><br><span class="line">        root = TreeNode(nums[qiege])</span><br><span class="line">        nums_left = nums[:qiege]</span><br><span class="line">        nums_right = nums[qiege+<span class="number">1</span>:]</span><br><span class="line">        root.left = self.sortedArrayToBST(nums_left)</span><br><span class="line">        root.right = self.sortedArrayToBST(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211031663.png" alt="image-20231121103147381"></p><h2 id="123、有序链表转换为二叉搜索树"><a href="#123、有序链表转换为二叉搜索树" class="headerlink" title="123、有序链表转换为二叉搜索树"></a>123、有序链表转换为二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231920721.png" alt="image-20231223184702366"></p><p>本题中的要求是转换为高度平衡的二叉搜索树，即要求是一颗平衡二叉树，所以需要从数组的中间进行构建，核心思路参考108题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 如何构建二叉搜索树？</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">construct</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">            qiege = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[qiege])</span><br><span class="line">            nums_left = nums[:qiege]</span><br><span class="line">            nums_right = nums[qiege+<span class="number">1</span>:]</span><br><span class="line">            root.left = construct(nums_left)</span><br><span class="line">            root.right = construct(nums_right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        p = head</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            nums.append(p.val)</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> construct(nums)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231855531.png" alt="image-20231223185524344"></p><h2 id="538、把二叉搜索树转换为累加树"><a href="#538、把二叉搜索树转换为累加树" class="headerlink" title="538、把二叉搜索树转换为累加树"></a>538、把二叉搜索树转换为累加树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211432312.png" alt="image-20231121143208244"></p><p>针对二叉搜索树的题目，一定要好好利用其==中序遍历得到的是一个递增的序列==这一性质！！！</p><p>思路：根据题目的要求，本题中的树是二叉搜索树，在中序遍历的过程中是递增的，但是要求实现的是将node节点的的值修改为大于等于该节点值的所有节点值的和。因此我们可以采用逆序中序遍历的方法，逆序中序遍历中的结点值与当前结点的结点值相加起来，得到该结点现在的值。</p><p>需要注意的是，使用Python的时候，局部变量的问题，也就是我们pre指向前一个结点值，我们需要用<code>nonlocal</code> pre来申明<code>pre</code>不是局部变量，这样在递归的过程中才能够访问到外层嵌套函数中定义的<code>pre</code>值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">                <span class="comment"># 使用右中左的遍历顺序进行遍历 往前叠加值</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pre</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.right)</span><br><span class="line">            root.val += pre</span><br><span class="line">            pre = root.val</span><br><span class="line">            dfs(root.left)</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root        </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211431170.png" alt="image-20231121143137935"></p><h2 id="1038、从二叉搜索树到更大的和树"><a href="#1038、从二叉搜索树到更大的和树" class="headerlink" title="1038、从二叉搜索树到更大的和树"></a>1038、从二叉搜索树到更大的和树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211426480.png" alt="image-20231121142641537"></p><p>本题与上一题思路一样，不再重复赘述。</p><h2 id="530、二叉树的最小绝对值差"><a href="#530、二叉树的最小绝对值差" class="headerlink" title="530、二叉树的最小绝对值差"></a>530、二叉树的最小绝对值差</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211435843.png" alt="image-20231121143459700"></p><p>思路：本题的树是二叉搜索树，根据其性质可以进行中序遍历，然后在得到的遍历序列中求最小绝对差</p><p>方法1 递归方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left) + [root.val] + dfs(root.right)</span><br><span class="line">        nums = dfs(root)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">min</span>(<span class="built_in">abs</span>(nums[i]-nums[i+<span class="number">1</span>]),res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2 迭代方法</p><p>在迭代法中，需要用pre记录前一个节点的指针，其初始值可以设置为任意值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 使用中序遍历 然后求差值</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                res = <span class="built_in">min</span>(<span class="built_in">abs</span>(pre-p.val),res)</span><br><span class="line">                pre = p.val</span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211504802.png" alt="image-20231121150414365"></p><h2 id="99、恢复二叉搜索树"><a href="#99、恢复二叉搜索树" class="headerlink" title="99、恢复二叉搜索树"></a>99、恢复二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231013364.png" alt="image-20231223101258925"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231013138.png" alt="image-20231223101317451"></p><p>本题的思路是：寻找出两个顺序颠倒的两个位置，在树遍历结束之后交换两个的值</p><p>bigger和smaller分别记录最大和最小值，其中bigger在进行初始化的时候需要进行赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigger = TreeNode(<span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 中序遍历 交换节点</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        smaller = <span class="literal">None</span></span><br><span class="line">        bigger = TreeNode(<span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>))</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="comment"># print(p.val,end=&quot; &quot;)</span></span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val&gt;p.val:</span><br><span class="line">                    <span class="keyword">if</span> bigger.val &lt; pre.val:</span><br><span class="line">                        bigger = pre</span><br><span class="line">                    smaller = p</span><br><span class="line">                pre = p</span><br><span class="line">                p = p.right</span><br><span class="line">        smaller.val,bigger.val = bigger.val,smaller.val</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312231920838.png" alt="image-20231223102107530"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021939061.png&quot; alt=&quot;image-20231102193927953&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="二叉树" scheme="https://guoxiansen.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux SRv6实验</title>
    <link href="https://guoxiansen.github.io/2023/10/31/Linux-SRv6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://guoxiansen.github.io/2023/10/31/Linux-SRv6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-31T11:12:20.000Z</published>
    <updated>2023-10-31T11:55:53.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SRv6实验"><a href="#SRv6实验" class="headerlink" title="SRv6实验"></a>SRv6实验</h1><p><strong>摘要：</strong>本文基于Linux SRv6功能，结合Mininet、Quagga、Python等工具，验证SRv6的一系列功能，包括VPN、流量工程、服务链等。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Linux （推荐Ubuntu20.04）</li><li>最新版Mininet</li><li>Quagga（在Mininet虚拟拓扑下，提供路由器的静态路由/OSPF/BGP等路由协议支持）</li><li>Python（通过脚本建立测试拓扑及初试配置）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Quagga安装"><a href="#Quagga安装" class="headerlink" title="Quagga安装"></a>Quagga安装</h3><p>下载地址</p><p><a href="https://src.fedoraproject.org/repo/pkgs/quagga/">https://src.fedoraproject.org/repo/pkgs/quagga/</a></p><p>下载Quagga1.2.4版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://src.fedoraproject.org/repo/pkgs/quagga/quagga-1.2.4.tar.gz/sha512/3e72440bcccfd3c1a449a62b7ff8623441256399a2bee0a39fa0a19694a5a78ac909c5c2128a24735bc034ea8b0811827293b480a2584a3a4c8ae36be9cf1fcd/quagga-1.2.4.tar.gz</span><br></pre></td></tr></table></figure><p><img src="D:\博客\Hexo\source_posts\images\image-20231031193027677.png" alt="image-20231031193027677"></p><p>安装命令1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-vtysh --enable-user=root --enable-group=root --enable-vty-group=root</span><br></pre></td></tr></table></figure><p>报错</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031193527408.png" alt="image-20231031193527408"></p><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gawk</span><br></pre></td></tr></table></figure><p>重复执行安装命令，继续报错，再来解决</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031194106531.png" alt="image-20231031194106531"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libreadline6-dev</span><br></pre></td></tr></table></figure><p>重复执行安装命令，继续报错，缺少相应的cares资源文件，再来解决</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031194011218.png" alt="image-20231031194011218"></p><p>下载文件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://c-ares.org/download/c-ares-1.12.0.tar.gz</span><br></pre></td></tr></table></figure><p>下载好之后解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ./c-ares-1.12.0.tar.gz</span><br></pre></td></tr></table></figure><p>进入文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd c-ares-1.12.0</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br><span class="line">cp libcares.pc /usr/local/lib/pkgconfig</span><br><span class="line">PKG_CONFIG_PATH=/usr/local/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用第三方库，就少不了要使用到第三方的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库文件的位置。</span></span><br></pre></td></tr></table></figure><p>再次执行命令1，安装无误</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031195401751.png" alt="image-20231031195401751"></p><p>在Quagga目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="D:\博客\Hexo\source_posts\images\image-20231031195522998.png" alt="image-20231031195522998"></p><h3 id="iproute2安装"><a href="#iproute2安装" class="headerlink" title="iproute2安装"></a>iproute2安装</h3><h2 id="参考Reference"><a href="#参考Reference" class="headerlink" title="参考Reference"></a>参考Reference</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SRv6实验&quot;&gt;&lt;a href=&quot;#SRv6实验&quot; class=&quot;headerlink&quot; title=&quot;SRv6实验&quot;&gt;&lt;/a&gt;SRv6实验&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;本文基于Linux SRv6功能，结合Mininet、Quagga、</summary>
      
    
    
    
    
    <category term="SDN" scheme="https://guoxiansen.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://guoxiansen.github.io/2023/10/21/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://guoxiansen.github.io/2023/10/21/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-10-21T01:53:48.000Z</published>
    <updated>2023-10-30T08:35:54.741Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310210959834.png" alt="image-20231021095935123"></p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>首先介绍一下常见位运算的符号（通常在各个编程语言中位运算的符号都是相似的）</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算，参与运算的两个值如果二进制对应位置都为1结果为1，否则为0</td></tr><tr><td>|</td><td>按位或运算，参与运算的两个值如果二进制对应位置有一个为1结果为1，两个均为0结果才为0</td></tr><tr><td>^</td><td>按位异或运算，当两个二进制位置对应位置不同时，结果为1，否则为0</td></tr><tr><td>~</td><td>按位取反运算，对数据的每个二进制位置取反，把0变为1，把1变为0</td></tr><tr><td>&lt;&lt;</td><td>左移运算符：运算数的各位二进制全部左移若干位，由&lt;&lt;符号右边的数字决定左移多少位，高位丢弃，低位自动补0</td></tr><tr><td>&gt;&gt;</td><td>右移运算符：运算数的各位二进制全部右移若干位，由&gt;&gt;符号右边的数字决定右移多少位。</td></tr></tbody></table><p>位运算在力扣中有很多题目的应用，位运算通常都是常数级别的时间复杂度</p><ol><li><strong>按位与（&amp;）</strong>、<strong>按位或（|）</strong>、<strong>按位异或（^）</strong>等基本位运算的时间复杂度是 O(1)，它们在一个常数时间内完成。</li><li><strong>位左移（&lt;&lt;）**和**位右移（&gt;&gt;）</strong>运算的时间复杂度也是 O(1)，因为它们只是在二进制数的表示上进行了移位操作。</li></ol><h2 id="2135-统计追加字母可以获得的单词"><a href="#2135-统计追加字母可以获得的单词" class="headerlink" title="2135.统计追加字母可以获得的单词"></a>2135.统计追加字母可以获得的单词</h2><h3 id="我第一次解法"><a href="#我第一次解法" class="headerlink" title="我第一次解法"></a>我第一次解法</h3><p>整体思路如下：</p><ol><li>首先将startWords中的单词全部转换为一个集合存放在一个列表中</li><li>将targetWords中的单词也全部转换为集合存放在列表中</li><li>通过两层for循环来遍历所有在target中的单词，和start中的单词集合元素取不同时包含在st集合与ta集合中的元素且要满足ta的长度-1等于st的长度，这样就可以确保由st中的单词随机添加一个就可以构成ta中的单词了</li><li>如果满足条件，将res+1，然后break掉，判断下一个单词是否可以由st中的单词获得</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordCount</span>(<span class="params">self, startWords: List[<span class="built_in">str</span>], targetWords: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = [<span class="built_in">set</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> startWords]</span><br><span class="line">        <span class="comment"># print(&quot;start&quot;,start)</span></span><br><span class="line">        target = [<span class="built_in">set</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> targetWords]</span><br><span class="line">        <span class="comment"># print(&quot;target&quot;,target)</span></span><br><span class="line">        <span class="keyword">for</span> ta <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">for</span> st <span class="keyword">in</span> start:</span><br><span class="line">                <span class="comment"># print(&quot;ta=&#123;&#125;,st=&#123;&#125;&quot;.format(ta,st))</span></span><br><span class="line">                <span class="comment"># if 0&lt;=len((ta-st))&lt;=1 and len((st-ta))==0:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st^ta)==<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(ta)-<span class="number">1</span>==<span class="built_in">len</span>(st):</span><br><span class="line">                    <span class="comment"># print(st)</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于当startWords和targetWords中的单词可能会特别长，在理论上集合最长的情况下，集合取各种关系的时候需要重复遍历整个集合，容易造成很大的时间开销，因此我这个代码在部分测试用例的时候可以通过，整体不能通过</p><h3 id="位运算-哈希表解法"><a href="#位运算-哈希表解法" class="headerlink" title="位运算+哈希表解法"></a>位运算+哈希表解法</h3><p>官方给出的解法是可以使用位运算，我看了下源代码，就是在我用集合进行比较的地方将其换成位运算操作能够极大的减少时间开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordCount</span>(<span class="params">self, startWords: List[<span class="built_in">str</span>], targetWords: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># s是一个用于存放startWords中的元素的哈希表，查询速度为O(1)</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> startWords:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="comment"># 按位或运算 只要对应的二进制有一个为1那么结果就为1，这样就把一个单词中的所有字符用掩码的形式表示出来了</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="comment"># 将每个单词的掩码存放在一个哈希表中</span></span><br><span class="line">            s.add(mask)</span><br><span class="line">        <span class="comment"># print(&quot;startword中的mask&quot;,s)</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> targetWords:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print(&quot;word&quot;,word)</span></span><br><span class="line">            <span class="comment"># 计算整个单词的掩码</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="comment"># 遍历单词，在去掉单词的每个字符的情况下，对比是否在哈希表中，如果在则将结果+1并break出来，</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> mask ^ (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))) <span class="keyword">in</span> s:  <span class="comment"># 去掉这个字符</span></span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>备注：<code>ord()</code>是Python内置方法，用于求一个字符的unicode编码</p><h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371.两整数之和"></a>371.两整数之和</h2><p>给你两个整数<code>a</code>和<code>b</code>，不使用运算符<code>+</code>和<code>-</code>，计算并返回两整数之和。</p><p>思路</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310301635268.png" alt="image-20231026203400843"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310210959834.png&quot; alt=&quot;image-20231021095935123&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;位运算&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python实现单链表（带头结点）</title>
    <link href="https://guoxiansen.github.io/2023/10/20/Python%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89/"/>
    <id>https://guoxiansen.github.io/2023/10/20/Python%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89/</id>
    <published>2023-10-20T08:55:05.000Z</published>
    <updated>2023-10-21T02:22:14.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python实现单链表"><a href="#Python实现单链表" class="headerlink" title="Python实现单链表"></a>Python实现单链表</h1><p>首先定义单个结点的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>单个结点中，包含了一个结点值和下一个结点的指针域</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index = <span class="built_in">max</span>(<span class="number">0</span>, index)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.<span class="built_in">next</span> = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = to_add</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = pred.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python实现单链表&quot;&gt;&lt;a href=&quot;#Python实现单链表&quot; class=&quot;headerlink&quot; title=&quot;Python实现单链表&quot;&gt;&lt;/a&gt;Python实现单链表&lt;/h1&gt;&lt;p&gt;首先定义单个结点的结构&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    
    <category term="链表" scheme="https://guoxiansen.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>django drf源码之序列化器</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</id>
    <published>2023-10-12T14:01:11.000Z</published>
    <updated>2023-10-12T14:01:11.107Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>django drf源码之解释器</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8/</id>
    <published>2023-10-12T14:00:45.000Z</published>
    <updated>2023-10-12T14:00:46.013Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>django drf源码之API版本管理</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8BAPI%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8BAPI%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2023-10-12T13:59:55.000Z</published>
    <updated>2023-10-12T14:10:37.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122204844.png" alt="image-20231012220431847"></p><h1 id="API版本"><a href="#API版本" class="headerlink" title="API版本"></a>API版本</h1><p>在开发过程中可能会有多版本的API，因此需要对API进行管理。django drf中对于版本的管理也很方便。</p><p><a href="http://www.example.com/api/v1/info">http://www.example.com/api/v1/info</a></p><p><a href="http://www.example.com/api/v2/info">http://www.example.com/api/v2/info</a></p><p>上面这种形式就是很常见的版本管理</p><p>在restful规范中，后端的API需要体现出版本</p><p>在django drf中，共有三种形式的版本管理</p><ol><li>通过GET参数传递</li><li>通过URL路由进行传递</li><li>通过请求头进行传递</li></ol><p>下面将对这三种方法逐一介绍</p><h2 id="1、通过get请求传递版本信息"><a href="#1、通过get请求传递版本信息" class="headerlink" title="1、通过get请求传递版本信息"></a>1、通过get请求传递版本信息</h2><p>视图函数代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.versioning <span class="keyword">import</span> QueryParameterVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">  versioning_class = QueryParameterVersioning</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">      print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">      print(request.versioning_scheme)</span><br><span class="line">      url = request.versioning_scheme.reverse(<span class="string">&quot;home&quot;</span>, request=request)</span><br><span class="line">      print(<span class="string">&quot;drf反向生成的URL为&quot;</span>, url)</span><br><span class="line">      self.dispatch</span><br><span class="line">      <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">123123</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> HomeView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;home/&quot;</span>, HomeView.as_view(), name=<span class="string">&quot;home&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在项目的<code>settings.py</code>文件中，我们还需要进行三个配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># get请求的默认参数名称</span></span><br><span class="line">    <span class="string">&quot;VERSION_PARAM&quot;</span>: <span class="string">&quot;version&quot;</span>,</span><br><span class="line">    <span class="comment"># 默认的版本</span></span><br><span class="line">    <span class="string">&quot;DEFAULT_VERSION&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="comment"># 允许的版本</span></span><br><span class="line">    <span class="string">&quot;ALLOWED_VERSIONS&quot;</span>: [<span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;v3&quot;</span>, <span class="string">&quot;v111&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>VERSION_PARAM</code>代表get请求的默认参数名，后面请求接口<a href="http://127.0.0.1:8000/home/?version=v1%E6%97%B6%EF%BC%8Cdjango%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84version%E8%8E%B7%E5%8F%96%E5%88%B0%EF%BC%8C%E5%B9%B6%E8%B5%8B%E5%80%BC%E5%88%B0request.version%E4%B8%AD%E3%80%82">http://127.0.0.1:8000/home/?version=v1时，django会自动将参数中的version获取到，并赋值到request.version中。</a></p><p>具体的可以参考drf中通过get请求传递版本对应部分的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryParameterVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    GET /something/?version=0.1 HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in query parameter.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用来提取版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 从请求的参数中先获取有没有版本，如果没有版本则赋值为默认的版本参数</span></span><br><span class="line">        version = request.query_params.get(self.version_param, self.default_version)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotFound(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line">    <span class="comment"># 用来方向生成URL</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, viewname, args=<span class="literal">None</span>, kwargs=<span class="literal">None</span>, request=<span class="literal">None</span>, <span class="built_in">format</span>=<span class="literal">None</span>, **extra</span>):</span></span><br><span class="line">        url = <span class="built_in">super</span>().reverse(</span><br><span class="line">            viewname, args, kwargs, request, <span class="built_in">format</span>, **extra</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> request.version <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> replace_query_param(url, self.version_param, request.version)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><p>QueryParameterVersioning类继承自BaseVersioing类。在BaseVersioing类中，有三个默认的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseVersioning</span>:</span></span><br><span class="line">    default_version = api_settings.DEFAULT_VERSION</span><br><span class="line">    allowed_versions = api_settings.ALLOWED_VERSIONS</span><br><span class="line">    version_param = api_settings.VERSION_PARAM</span><br></pre></td></tr></table></figure><p><code>default_version</code> 代表默认的版本，会自动去全局配置中寻找，如果全局中没有配置则去局部进行寻找</p><p><code>allowed_versions</code> 代表允许的版本号，会自动取<code>settings.py</code>文件中去读取相应的配置</p><p><code>version_param</code> 代表get请求参数中的关键字，例如<a href="http://127.0.0.1:8000/home/?version=v1">http://127.0.0.1:8000/home/?version=v1</a> 例如，若<code>settings.py</code>文件中配置了此url中的<code>version_param</code>值为version，那么version就是获取版本的关键字（本质上是字典的键）</p><p>接下来看效果演示，这里通过postman来模拟get和post请求。</p><ul><li>首先，这里我没有在URL中携带版本信息，由于我在全局配置中写了默认是v1，并且关键字是version，因此会帮我按照这个配置信息反向生成一个url链接。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202654.png"></p><ul><li>接下来的请求我会携带version参数，可以看到响应成功，输出api版本信息并反向生成了url</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202936.png"></p><ul><li>接下来我换一个关键词使用?xx=v3，drf会按照之前的配置，默认使用v1参数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202938.png"></p><ul><li>接下来我会使用不在<code>ALLOWED_VERSIONS</code>中的版本信息，v1000，程序报错，不合格的版本信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202675.png" alt="image-20231009211750100"></p><h2 id="2、通过url路由传递版本信息"><a href="#2、通过url路由传递版本信息" class="headerlink" title="2、通过url路由传递版本信息"></a>2、通过url路由传递版本信息</h2><p>URL路由中携带版本（*）公司中常用的方法 可以直接将其写到settings.py文件中，这样可以方便后续使用，直接去全局配置中找到即可。</p><p>视图类代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home2View</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    versioning_class = URLPathVersioning</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        url = request.versioning_scheme.reverse(<span class="string">&quot;home2&quot;</span>, request=request)</span><br><span class="line">        print(<span class="string">&quot;drf_HOME2反向生成的URL为&quot;</span>, url)</span><br><span class="line">        self.dispatch</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">222222</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这里注意，反向生成URL的时候需要加上一个name</p><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> Home2View</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;api/&lt;str:version&gt;/home2/&quot;</span>, Home2View.as_view(), name=<span class="string">&quot;home2&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在类视图的代码中，我们将<code>versioning_class</code> 赋值为<code>URLPathVersioning</code></p><p>在drf的源代码中，<code>URLPathVersioning</code>是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLPathVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    To the client this is the same style as `NamespaceVersioning`.</span></span><br><span class="line"><span class="string">    The difference is in the backend - this implementation uses</span></span><br><span class="line"><span class="string">    Django&#x27;s URL keyword arguments to determine the version.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    An example URL conf for two views that accept two different versions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    urlpatterns = [</span></span><br><span class="line"><span class="string">        re_path(r&#x27;^(?P&lt;version&gt;[v1|v2]+)/users/$&#x27;, users_list, name=&#x27;users-list&#x27;),</span></span><br><span class="line"><span class="string">        re_path(r&#x27;^(?P&lt;version&gt;[v1|v2]+)/users/(?P&lt;pk&gt;[0-9]+)/$&#x27;, users_detail, name=&#x27;users-detail&#x27;)</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    GET /1.0/something/ HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in URL path.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 从请求的参数中先获取有没有版本，</span></span><br><span class="line">        version = kwargs.get(self.version_param, self.default_version)</span><br><span class="line">        <span class="comment"># 如果没有版本则赋值为默认的版本参数</span></span><br><span class="line">        <span class="keyword">if</span> version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            version = self.default_version</span><br><span class="line">        <span class="comment"># 如果是不合法的API版本，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotFound(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, viewname, args=<span class="literal">None</span>, kwargs=<span class="literal">None</span>, request=<span class="literal">None</span>, <span class="built_in">format</span>=<span class="literal">None</span>, **extra</span>):</span></span><br><span class="line">        <span class="keyword">if</span> request.version <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125; <span class="keyword">if</span> (kwargs <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">else</span> kwargs</span><br><span class="line">            kwargs[self.version_param] = request.version</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().reverse(</span><br><span class="line">            viewname, args, kwargs, request, <span class="built_in">format</span>, **extra</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>本质上就是一个determin_version()函数，首先会从<code>**kwargs</code>中获取有没有版本，如果没有版本信息则将版本赋值为全局配置中的默认版本。如果API是非法的，则抛出异常。</p><h2 id="3、通过请求头传递"><a href="#3、通过请求头传递" class="headerlink" title="3、通过请求头传递"></a>3、通过请求头传递</h2><p>视图类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home3View</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    versioning_class = AcceptHeaderVersioning</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        url = request.versioning_scheme.reverse(<span class="string">&quot;home3&quot;</span>, request=request)</span><br><span class="line">        print(<span class="string">&quot;drf_HOME2反向生成的URL为&quot;</span>, url)</span><br><span class="line">        self.dispatch</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">333333</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home3&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> Home3View</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;api/home3/&quot;</span>, Home3View.as_view(), name=<span class="string">&quot;home3&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在类视图的代码中，我们将<code>versioning_class</code> 赋值为<code>AcceptHeaderVersioning</code></p><p>在drf的源代码中，<code>AcceptHeaderVersioning</code>是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于请求头传递版本信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptHeaderVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    GET /something/ HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json; version=1.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in &quot;Accept&quot; header.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        media_type = _MediaType(request.accepted_media_type)</span><br><span class="line">        version = media_type.params.get(self.version_param, self.default_version)</span><br><span class="line">        version = unicode_http_header(version)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotAcceptable(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We don&#x27;t need to implement `reverse`, as the versioning is based</span></span><br><span class="line">    <span class="comment"># on the `Accept` header, not on the request URL.</span></span><br></pre></td></tr></table></figure><p>这个请求无法再浏览器中模拟，只能通过postman中去添加请求头进行模拟，</p><p>Headers中的KEY为Accept，VALUE为application/json; version=1.0</p><ul><li>这里我先将version设置为1.0，可以看到显示信息为不合法的版本信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122201284.png" alt="image-20231009213432844"></p><ul><li>然后我将version设置为v3，可以看到可以正常访问</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122201464.png" alt="image-20231009213714147"></p><p>如果我不在请求头中设置的话，默认还是会访问v1版本的API，这是由于我在全局中的配置所导致的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122204844.png&quot; alt=&quot;image-20231012220431847&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;API版本&quot;</summary>
      
    
    
    
    
    <category term="django" scheme="https://guoxiansen.github.io/tags/django/"/>
    
    <category term="drf" scheme="https://guoxiansen.github.io/tags/drf/"/>
    
  </entry>
  
  <entry>
    <title>CloudSim Installation</title>
    <link href="https://guoxiansen.github.io/2023/10/11/CloudSim%20Installation/"/>
    <id>https://guoxiansen.github.io/2023/10/11/CloudSim%20Installation/</id>
    <published>2023-10-11T12:58:11.000Z</published>
    <updated>2023-10-27T14:23:37.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112103086.png" alt="image-20231011210335067"></p><h1 id="CloudSim安装与测试用例运行"><a href="#CloudSim安装与测试用例运行" class="headerlink" title="CloudSim安装与测试用例运行"></a>CloudSim安装与测试用例运行</h1><h1 id="0、CloudSim简介"><a href="#0、CloudSim简介" class="headerlink" title="0、CloudSim简介"></a>0、CloudSim简介</h1><ul><li>CloudSim是由澳大利亚墨尔本大学的网格实验室和Gridbus项目共同推出的开源云计算仿真平台；</li><li>CloudSim是基于<strong>Java语言</strong>开发的，可实现跨平台运行；</li><li>CloudSim有助于加快面向云计算平台的算法设计与测试速度，可降低开发的成本；</li><li>用户可以通过CloudSim提供的众多核心类来进行大规模的云计算基础设施的建模与仿真。</li></ul><h1 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h1><ul><li><p>一台Windows操作系统的电脑</p></li><li><p>Java配置</p></li><li><p>Maven下载与配置</p></li><li><p>工具下载（下面两个都可以，二选一即可）</p><ul><li>Eclipse</li><li>IDEA（推荐）</li></ul></li><li><p>CloudSim下载（本次实验使用<strong>CloudSim 5.0</strong>）</p></li></ul><p><strong>注：以上所有软件的安装包均可在百度网盘中下载</strong></p><p>链接：<a href="https://pan.baidu.com/s/12JT4gDKbOLvHIeqyGbgE6A">https://pan.baidu.com/s/12JT4gDKbOLvHIeqyGbgE6A</a><br>提取码：3fd5</p><h2 id="1-1-Java配置"><a href="#1-1-Java配置" class="headerlink" title="1.1 Java配置"></a>1.1 Java配置</h2><p>首先需要再本地配置好Java的环境，这里不过多赘述，可以参考下面的教程</p><p><strong>注：本文中使用的是jdk8的版本</strong></p><h3 id="1-1-1-安装Java8"><a href="#1-1-1-安装Java8" class="headerlink" title="1.1.1 安装Java8"></a>1.1.1 安装Java8</h3><p>双击下载好百度网盘中的文件，选择你的安装路径即可</p><h3 id="1-1-2-配置环境变量"><a href="#1-1-2-配置环境变量" class="headerlink" title="1.1.2 配置环境变量"></a>1.1.2 配置环境变量</h3><p>在“计算机”图标上点击鼠标右键，点击“属性”命令，单击高级系统设置</p><p><strong>注意 配置不要照抄，要按照你自己本地的文件夹路径来</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181325266.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181325255.png" alt="img"></p><p>在“系统变量”中找到Path变量，点击“编辑”，添加一个 你所安装的jdk/bin目录 </p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310251029518.png" alt="image-20231025102917421"></p><h3 id="1-2-3-确认环境变量配置是否正确"><a href="#1-2-3-确认环境变量配置是否正确" class="headerlink" title="1.2.3 确认环境变量配置是否正确"></a>1.2.3 确认环境变量配置是否正确</h3><p>安装完成后在本地cmd中输入<code>java -version</code>能够显示下面的内容即为安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112108746.png" alt="image-20231011210829423"></p><h2 id="1-2-Maven下载与配置"><a href="#1-2-Maven下载与配置" class="headerlink" title="1.2 Maven下载与配置"></a>1.2 Maven下载与配置</h2><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具 软件。 Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较 高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方 法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><h3 id="1-2-1-下载"><a href="#1-2-1-下载" class="headerlink" title="1.2.1 下载"></a>1.2.1 下载</h3><p>打开<a href="https://maven.apache.org/download.cgi">Maven官网下载界面</a>，下载bin文件，该文件为编译后的Maven，无需在本地进行编译直接使用。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112113924.png" alt="image-20231011211326482"></p><p>下载完成后，保存到本地的一个可靠的路径。</p><p>然后在本地的环境变量中添加一个<code>MAVEN_HOME</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112121376.png" alt="image-20231011212120543"></p><p>同时在系统变量的<code>Path</code>中添加一行：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112124937.png" alt="image-20231011212319179"></p><h3 id="1-2-2-配置本地仓库"><a href="#1-2-2-配置本地仓库" class="headerlink" title="1.2.2 配置本地仓库"></a>1.2.2 配置本地仓库</h3><p><strong>注意下面开始修改<code>settings.xml</code>文件的时候，切记不要将你的内容添加在注释当中，xml是一种类似于html的标记语言，不要将其中的结尾标记给错误的删除了。</strong></p><p>在Maven安装的同级目录下创建maven-repository文件夹，用作maven的本地库。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112127205.png" alt="image-20231011212701529"></p><p>在路径apache-maven-3.9.5/conf文件夹下找到<code>settings.xml</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112130718.png" alt="image-20231011213017409"></p><p>在该文件中找到节点localRepository，在注释外添加。<strong>此处的路径需要修改为你自己创建的路径！！！切勿照抄复制</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>你自己创建的maven仓库路径<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112128393.png" alt="image-20231011212855325"></p><blockquote><p>localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:Users用户名.m2。<br>当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。<br>此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。</p></blockquote><h3 id="1-2-3-配置镜像"><a href="#1-2-3-配置镜像" class="headerlink" title="1.2.3 配置镜像"></a>1.2.3 配置镜像</h3><ol><li>在settings.xml配置文件中找到mirrors节点<strong>（XML文件的标签对要注意！！）</strong></li><li>添加如下配置（注意要添加在和两个标签之间，其它配置同理）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112132387.png" alt="image-20231011213207092"></p><blockquote><p>因为国外的服务器下载jar包很慢所以我们改为阿里云服务器</p><p>虽然mirrors可以配置多个子节点，但是它只会使用其中的一个节点，即默认情况下配置多个mirror的情况下，只有第一个生效，只有当前一个mirror无法连接的时候，才会去找后一个；而我们想要的效果是：当a.jar在第一个mirror中不存在的时候，maven会去第二个mirror中查询下载，但是maven不会这样做。</p></blockquote><h3 id="1-2-4-配置JDK"><a href="#1-2-4-配置JDK" class="headerlink" title="1.2.4 配置JDK"></a>1.2.4 配置JDK</h3><ol><li>在settings.xml配置文件中找到profiles节点</li><li>添加如下配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- java版本 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112134024.png" alt="image-20231011213444786"></p><p>配置完成，win+R运行CMD，输入mvn help:system 命令进行测试，配置成功则本地仓库（maven-repository）中会出现一些文件。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112136587.png" alt="image-20231011213655948"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112139145.png" alt="image-20231011213806766"></p><p>输出以下内容即为Maven安装成功：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112137938.png" alt="image-20231011213739689"></p><blockquote><p>首次执行 mvn help:system 命令，Maven相关工具自动帮我们到Maven中央仓库下载缺省的或者Maven中央仓库更新的各种配置文件和类库（jar包)到Maven本地仓库中。<br>下载完各种文件后， mvn help:system 命令会打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助。</p></blockquote><h2 id="1-3-集成开发环境安装"><a href="#1-3-集成开发环境安装" class="headerlink" title="1.3 集成开发环境安装"></a>1.3 集成开发环境安装</h2><p>这里推荐使用IDEA，后续在工作中也多数会使用IDEA</p><p>安装教程参考：<a href="https://blog.csdn.net/rbx508780/article/details/126647849">https://blog.csdn.net/rbx508780/article/details/126647849</a></p><p>注：可以直接从官网下载专业版IDEA，利用校园邮箱免费激活。</p><h2 id="1-4-CloudSim下载"><a href="#1-4-CloudSim下载" class="headerlink" title="1.4 CloudSim下载"></a>1.4 CloudSim下载</h2><p>去github中下载CloudSim <a href="https://github.com/Cloudslab/cloudsim/releases">https://github.com/Cloudslab/cloudsim/releases</a></p><p>本实验中使用的是CloudSim5.0</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112142668.png" alt="image-20231011214208781"></p><p>下载后解压缩，然后在IDEA中打开项目，Maven会自动根据pom.xml下载一些配置文件，等待下载完成后即可。</p><p>点击open project，选择解压缩的CloudSim文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112159988.png" alt="image-20231011214707810"></p><p>在IDEA的设置中，设置之前的Maven仓库</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181130059.png" alt="image-20231018113050839"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181131474.png" alt="image-20231018113120241"></p><p>然后找到example，右击运行，出现如下效果即为安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112144218.png" alt="image-20231011214423011"></p><h1 id="CloudSim介绍"><a href="#CloudSim介绍" class="headerlink" title="CloudSim介绍"></a>CloudSim介绍</h1><h2 id="CloudSim仿真的核心类"><a href="#CloudSim仿真的核心类" class="headerlink" title="CloudSim仿真的核心类"></a>CloudSim仿真的核心类</h2><p>CloudSim仿真的核心类如下</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>DataCenter</td><td><strong>数据中心</strong>，提供虚拟化网络资源</td></tr><tr><td>DataCenterBroker</td><td><strong>代理</strong>，用于提交虚拟机的任务和云任务列表</td></tr><tr><td>Host</td><td><strong>主机</strong>，扩展虚拟机的参数分配策略，一台Host可以对应多台VM</td></tr><tr><td>VM</td><td><strong>虚拟机类</strong>，运行在Host上，与其他虚拟机共享资源</td></tr><tr><td>Cloudlet</td><td><strong>云任务类</strong>，构建云环境任务</td></tr></tbody></table><h2 id="CloudSim仿真流程"><a href="#CloudSim仿真流程" class="headerlink" title="CloudSim仿真流程"></a>CloudSim仿真流程</h2><ol><li>初始化CloudSim</li><li>创建数据中心DataCenter</li><li>创建用户代理Broker</li><li>创建虚拟机VM，添加至Broker</li><li>创建应用Cloudlet，添加至Broker</li><li>开启仿真</li><li>结束模拟仿真</li><li>打印输出</li></ol><h1 id="CloudSim应用"><a href="#CloudSim应用" class="headerlink" title="CloudSim应用"></a>CloudSim应用</h1><p>CloudSim5.0安装包中提供了8个示例代码，后续的实验任务可以参考其中的部分。</p><p><code>CloudSimExample1</code>：展示了如何通过一台主机创建一个云数据中心并在其上运行一个Cloudlet。</p><p><code>CloudSimExample2</code>：展示了如何创建一个包含一个主机的数据中心，并在其上运行两个云任务。这些云任务在具有相同MIPS需求的虚拟机中运行。这些云任务将花费相同的时间来完成执行。</p><p><code>CloudSimExample3</code>：展示了如何创建一个包含两个主机的数据中心，并在其上运行两个Cloudlet云任务。这些云任务在具有不同MIPS需求的虚拟机中运行。云任务将会根据所请求的虚拟机性能，花费不同的时间来完成执行。</p><p><code>CloudSimExample4</code>：展示了如何创建两个包含一个主机的数据中心，并在它们上运行两个云任务。</p><p><code>CloudSimExample5</code>：展示了如何如何创建两个数据中心，每个数据中心包含一个主机，并在它们上运行两个用户的云任务。</p><p><code>CloudSimExample6</code>：展示了如何创建可伸缩的实例。</p><p><code>CloudSimExample7</code>：展示了如何暂停和恢复模拟，以及动态地创建模拟实例（在这个例子中是一个 DatacenterBroker）。</p><p><code>CloudSimExample8</code>：展示了。如何在运行时使用一个全局管理实体（GlobalBroker）创建模拟实体（在这个例子中是一个 DatacenterBroker）。</p><h2 id="仿真步骤"><a href="#仿真步骤" class="headerlink" title="仿真步骤"></a>仿真步骤</h2><p>进行CloudSim仿真前的准备工作包括：首先初始化CloudSim的工具包，创建云数据中心DataCenter和代理DataCenterBroker；然后创建虚拟机列表VmList，将虚拟机列表提交到云数据中心和代理；接着创建云任务列表CloudletList；最后将云任务列表提交给云数据中心和代理。</p><p>在进行CloudSim仿真时，首先需要对CloudSim的核心类参数进行初始化，主要有4个核心类，分别是主机类Host、云数据中心类DataCenter、虚拟机类VirtualMachine和云任务列表类Cloudlet。</p><p>Host参数包括ID、CPU、内存、带宽、外存等，Host参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hostId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ram = <span class="number">2048</span>;              <span class="comment">//Host memory (MB)</span></span><br><span class="line"><span class="keyword">long</span> storage = <span class="number">1000000</span>; <span class="comment">//Host storage</span></span><br><span class="line"><span class="keyword">int</span> bw = <span class="number">10000</span>;</span><br><span class="line">hostList.add( <span class="keyword">new</span> Host(</span><br><span class="line">    hostId,</span><br><span class="line">    <span class="keyword">new</span> RamProvisionerSimple(ram),</span><br><span class="line">    <span class="keyword">new</span> BwProvisionerSimple(bw),</span><br><span class="line">    storage,</span><br><span class="line">    peList,</span><br><span class="line">    <span class="keyword">new</span> VmSchedulerTimeShared(peList)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DataCenter参数包括主机架构、操作系统、虚拟机监视器种类、时区、CPU的使用费用、内存的使用费用、外存的使用费用、带宽的使用费用等。DataCenter参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String arch = <span class="string">&quot;x86&quot;</span>;       <span class="comment">//system architecture</span></span><br><span class="line">String os = <span class="string">&quot;Linux&quot;</span>;        <span class="comment">//operating system</span></span><br><span class="line">String vmm = <span class="string">&quot;Xen&quot;</span>;</span><br><span class="line"><span class="keyword">double</span> time_zone = <span class="number">10.0</span>;  <span class="comment">//time zone this resource located</span></span><br><span class="line"><span class="keyword">double</span> cost = <span class="number">3.0</span>;        <span class="comment">//the cost of using processing in this resource</span></span><br><span class="line"><span class="keyword">double</span> costPerMem = <span class="number">0.05</span>; <span class="comment">//the cost of using memory in this resource</span></span><br><span class="line"><span class="keyword">double</span> costPerStorage = <span class="number">0.001</span>;  <span class="comment">//the cost of using storage in this</span></span><br><span class="line"><span class="comment">//resource</span></span><br><span class="line"><span class="keyword">double</span> costPerBw = <span class="number">0.0</span>; <span class="comment">//the cost of using bw in this resource</span></span><br><span class="line">LinkedList&lt;Storage&gt; storageList = <span class="keyword">new</span> LinkedList&lt;Storage&gt;(); <span class="comment">//we are not adding SAN</span></span><br><span class="line"><span class="comment">//devices by now</span></span><br><span class="line"></span><br><span class="line">DatacenterCharacteristics characteristics = <span class="keyword">new</span> DatacenterCharacteristics(</span><br><span class="line">    arch, os, vmm, hostList, time_zone, cost, costPerMem, costPerStorage, costPerBw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//we need to create a PowerDatacenter object.</span></span><br><span class="line">Datacenter datacenter = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    datacenter = <span class="keyword">new</span> Datacenter(name, characteristics, <span class="keyword">new</span> VmAllocationPolicySimple(hostList),</span><br><span class="line">                             storageList, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>VirtualMachine参数包括ID、MIPS、镜像大小、内存大小、带宽、CPU数、虚拟机命名等。VirtualMachine参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VirtualMachine properties</span></span><br><span class="line"><span class="keyword">int</span> vmid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mips = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">long</span> size = <span class="number">10000</span>;          <span class="comment">//image size (MB)</span></span><br><span class="line"><span class="keyword">int</span> ram = <span class="number">512</span>;             <span class="comment">//vm memory (MB)</span></span><br><span class="line"><span class="keyword">long</span> bw = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> pesNumber = <span class="number">1</span>;            <span class="comment">//number of cpus</span></span><br><span class="line">String vmm = <span class="string">&quot;Xen&quot;</span>;        <span class="comment">//VMM name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//create VM</span></span><br><span class="line">Vm vm = <span class="keyword">new</span> Vm(vmid, brokerId, mips, pesNumber, ram, bw, size, vmm, </span><br><span class="line">                <span class="keyword">new</span> CloudletSchedulerTimeShared());</span><br><span class="line"></span><br><span class="line"><span class="comment">//add the VM to the vmList</span></span><br><span class="line">vmlist.add(vm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit vm list to the broker</span></span><br><span class="line">broker.submitVmList(vmlist);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Cloudlet参数包括编号、执行时的应用长度、用到的CPU数量、提交应用前的文件大小、应用执行完成后的文件大小、CPU和内存的使用模型/策略、网络带宽的使用模型/策略等。Cloudlet参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cloudlet properties</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> length = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">long</span> fileSize = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">long</span> outputSize = <span class="number">300</span>;</span><br><span class="line">UtilizationModel utilizationModel = <span class="keyword">new</span> UtilizationModelFull();</span><br><span class="line"></span><br><span class="line">Cloudlet cloudlet = <span class="keyword">new</span> Cloudlet(id, length, pesNumber, fileSize, outputSize, </span><br><span class="line">                                utilizationModel, utilizationModel, utilizationModel);</span><br><span class="line">cloudlet.setUserId(brokerId);</span><br><span class="line">cloudlet.setVmId(vmid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add the cloudlet to the list</span></span><br><span class="line">cloudletList.add(cloudlet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit cloudlet list to the broker</span></span><br><span class="line">broker.submitCloudletList(cloudletList);</span><br></pre></td></tr></table></figure><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>现在需要仿真：在<strong>2个</strong>云数据中心上分别各配置<strong>2台</strong>虚拟机，每台虚拟机运行<strong>1个</strong>用户的<strong>4个</strong>Cloudlet，总计<strong>4个</strong>用户<strong>16个</strong>Cloudlet，请进行实验，并给出实验结果截图附在实验报告中。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310272206306.png" alt="image-20231027220654889"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112103086.png&quot; alt=&quot;image-20231011210335067&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;CloudS</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PROM1014-级数求和</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1014-%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1014-%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2022-03-21T12:17:41.000Z</published>
    <updated>2023-10-18T05:34:32.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在死循环中进行级数求和，每一轮循环进行判断，是否大于输入的<code>K</code>，大于则返回当前的<code>n</code>值</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334932.png" alt="image-20220321202013051"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">sum_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sum_num += <span class="number">1</span> / n</span><br><span class="line">    <span class="keyword">if</span> sum_num &gt; k:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;级数求和&quot;&gt;&lt;a href=&quot;#级数求和&quot; class=&quot;headerlink&quot; title=&quot;级数求和&quot;&gt;&lt;/a&gt;级数求和&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PROM1011-忠诚的骑士</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1011-%E5%BF%A0%E8%AF%9A%E7%9A%84%E9%AA%91%E5%A3%AB/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1011-%E5%BF%A0%E8%AF%9A%E7%9A%84%E9%AA%91%E5%A3%AB/</id>
    <published>2022-03-21T12:12:56.000Z</published>
    <updated>2023-10-18T05:34:20.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="忠诚的骑士"><a href="#忠诚的骑士" class="headerlink" title="忠诚的骑士"></a>忠诚的骑士</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分组的思想，判断输入的数字应该在第几组，然后判断该数字在当前分组的第几个位置，然后进行求和</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334473.png" alt="image-20220321202055824"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n, index</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="built_in">sum</span> += i * i</span><br><span class="line">    <span class="built_in">sum</span> += n * index</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># if k == 1:</span></span><br><span class="line">    <span class="comment">#     print(1)</span></span><br><span class="line">    p = k</span><br><span class="line">    s = k * (k + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= s:</span><br><span class="line">        p = p - <span class="number">1</span></span><br><span class="line">        s = p * (p + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 检测在第三组第几个位置</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="comment"># print(&#x27;p =&#x27;, p)</span></span><br><span class="line">    <span class="comment"># print(&#x27;s =&#x27;, s)</span></span><br><span class="line">    num = p * (p + <span class="number">1</span>) // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p + <span class="number">1</span>):</span><br><span class="line">        nums.append(num)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="comment"># print(&#x27;第&#x27;, nums.index(k) + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算金币总数</span></span><br><span class="line">    <span class="comment"># print(&#x27;金币总数：&#x27;, cal(p + 1, nums.index(k) + 1))</span></span><br><span class="line">    print(cal(p + <span class="number">1</span>, nums.index(k) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;忠诚的骑士&quot;&gt;&lt;a href=&quot;#忠诚的骑士&quot; class=&quot;headerlink&quot; title=&quot;忠诚的骑士&quot;&gt;&lt;/a&gt;忠诚的骑士&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1010-萌萌摘苹果</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1010-%E8%90%8C%E8%90%8C%E6%91%98%E8%8B%B9%E6%9E%9C/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1010-%E8%90%8C%E8%90%8C%E6%91%98%E8%8B%B9%E6%9E%9C/</id>
    <published>2022-03-21T12:07:34.000Z</published>
    <updated>2023-10-18T05:34:43.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="萌萌摘苹果"><a href="#萌萌摘苹果" class="headerlink" title="萌萌摘苹果"></a>萌萌摘苹果</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历苹果高度列表，判断是否能够到苹果，然后将能够到的苹果高度添加到一个新列表，循环结束之后，对两个列表长度进行比较，若长度一样返回<code>Yes</code>，否则返回<code>No</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334844.png" alt="image-20220321200943805"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">height = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)]</span><br><span class="line">high = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">get_height = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> height:</span><br><span class="line">    <span class="keyword">if</span> i &lt;= high+<span class="number">30</span>:</span><br><span class="line">        get_height.append(i)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(get_height))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(get_height)==<span class="built_in">len</span>(height):</span><br><span class="line">    print(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;No&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;萌萌摘苹果&quot;&gt;&lt;a href=&quot;#萌萌摘苹果&quot; class=&quot;headerlink&quot; title=&quot;萌萌摘苹果&quot;&gt;&lt;/a&gt;萌萌摘苹果&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1008-回文回文</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1008-%E5%9B%9E%E6%96%87%E5%9B%9E%E6%96%87/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1008-%E5%9B%9E%E6%96%87%E5%9B%9E%E6%96%87/</id>
    <published>2022-03-21T12:00:30.000Z</published>
    <updated>2023-10-18T05:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181255837.png"></p><h1 id="回文回文"><a href="#回文回文" class="headerlink" title="回文回文"></a>回文回文</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由样例输入输出来看，如果有字母大小写均存在但是回文的话返回<code>Yes</code>。因此将字符串统一转成小写，然后进行回文判断</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181254615.png" alt="image-20220321200451662"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">huiwen = <span class="built_in">input</span>()</span><br><span class="line">huiwen = huiwen.lower()</span><br><span class="line"><span class="comment"># print(huiwen, &#x27;1111&#x27;)</span></span><br><span class="line"><span class="keyword">if</span> huiwen == huiwen[::-<span class="number">1</span>]:</span><br><span class="line">    print(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;No&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181255837.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;回文回文&quot;&gt;&lt;a href=&quot;#回文回文&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1007-斐波那契数列</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1007-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1007-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2022-03-21T11:55:11.000Z</published>
    <updated>2023-10-18T05:34:52.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>递归<ul><li>Python解答会超时</li></ul></li><li>滚动数组<ul><li>时间复杂度较低 Python也不会超时</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334516.png" alt="image-20220321195628243"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">p,q,r = <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">    print(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    print(r)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
</feed>

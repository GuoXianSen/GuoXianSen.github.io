<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay_Guo的博客</title>
  
  
  <link href="https://guoxiansen.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoxiansen.github.io/"/>
  <updated>2024-03-26T07:40:20.811Z</updated>
  <id>https://guoxiansen.github.io/</id>
  
  <author>
    <name>Clay_Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三次握手与四次挥手</title>
    <link href="https://guoxiansen.github.io/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://guoxiansen.github.io/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2024-03-26T03:05:56.000Z</published>
    <updated>2024-03-26T07:40:20.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP是一种面向连接的协议，可以保证传输的可靠性</p><p>TCP是一种全双工的协议</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="三次握手的流程"><a href="#三次握手的流程" class="headerlink" title="三次握手的流程"></a>三次握手的流程</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261540258.png" alt="TCP 三次握手"></p><h2 id="为什么是三次而不是两次"><a href="#为什么是三次而不是两次" class="headerlink" title="为什么是三次而不是两次"></a>为什么是三次而不是两次</h2><p>首先客户端给服务器端发送请求之后，当服务器端收到请求就可以确保客户端的发送功能是正常的</p><p>然后服务器端给客户端响应<strong>（seq=y, ack=x+1）</strong>，当客户端收到消息之后，就可以确保服务器端的发送和接收功能都是正常的</p><p>此时客户端再给服务器端发送一条响应，那么服务器端就可以确保客户端的接收功能也是正常的。</p><p>如果说只进行两次握手，客户端给服务器端发送Hello，服务器端给客户端回一个hi，可能存在一个问题，这个消息并没有被客户端所接收，连接可能会存在数据丢失导致不可靠的问题。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP通过四次挥手来保证数据完整传输的</p><p>四次挥手需要确保双方后面都不会再发送数据的情况下再进行断开连接</p><h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><ol><li>客户端给服务器端发送一个带有FIN结束标识和seq=1的断开连接的请求包，主要目的是告诉客户端我这边不再发送数据包了，但是可以接收数据。</li><li>服务器端会给客户端发送一个ack包，表示自己已经知道客户端不会再向自己发送数据了</li><li>服务端给客户端发送一个断开连接的请求包，告知客户端自己这边也不会发送数据了</li><li>客户端给服务器端做出最后的响应，当服务端收到响应之后就会断开连接并释放资源；客户端这边需要等待一段时间再去断开连接，等待的时间是两倍的请求时间。</li></ol><h2 id="为什么不能将服务器端的两次请求合并成一个？"><a href="#为什么不能将服务器端的两次请求合并成一个？" class="headerlink" title="为什么不能将服务器端的两次请求合并成一个？"></a>为什么不能将服务器端的两次请求合并成一个？</h2><p>第二次挥手和第三次挥手之间是有一定的延迟性的，延迟可能是几秒、几十秒甚至几分钟</p><p>第二次挥手直接进行一次确认可以保证不会触发TCP的超时重传机制，减少额外的开销</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;p&gt;TCP是一种面向连接的协议，可以保证传输的可靠性&lt;/p&gt;
&lt;p&gt;TCP是一种全双工的协议&lt;/p&gt;
&lt;h1 id=&quot;三次握手&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://guoxiansen.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python内置模块collections解析</title>
    <link href="https://guoxiansen.github.io/2024/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97collections%E8%A7%A3%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97collections%E8%A7%A3%E6%9E%90/</id>
    <published>2024-03-25T13:40:03.000Z</published>
    <updated>2024-03-26T06:41:15.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置模块collections解析"><a href="#Python内置模块collections解析" class="headerlink" title="Python内置模块collections解析"></a>Python内置模块collections解析</h1><p>python的collections模块提供了非常多方便的操作，例如</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261336795.png" alt="image-20240326133642376"></p><ul><li>Counter</li><li>defaultdict()</li><li>OrderDict()</li><li>deque<ul><li>双端队列</li></ul></li><li>namedtuple()</li><li></li></ul><p>下面将逐个介绍每一个具体类的用法</p><h2 id="Counter类"><a href="#Counter类" class="headerlink" title="Counter类"></a>Counter类</h2><p>该类可以快速的进行统计，例如给定一个字符串之后，可以统计每个字符出现的次数，当然只要是<strong>可迭代【可哈希】</strong>的数据都是可以传给Counter中的，例如list，tuple等</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261340020.png" alt="image-20240326134016203"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;abcdeasdasdkjyhaksjdhkashd&quot;</span></span><br><span class="line">myhash = Counter(string)</span><br><span class="line">print(myhash)</span><br></pre></td></tr></table></figure><p>该类中提供了几个方法可以使用</p><ul><li><code>most_common()</code><ul><li>可以将字典中的元素按照出现次数组成一个元素，再按照出现次数从大到小排列成一个列表</li><li>例如：[(‘a’, 5), (‘d’, 5), (‘s’, 4), (‘k’, 3), (‘h’, 3), (‘j’, 2), (‘b’, 1), (‘c’, 1), (‘e’, 1), (‘y’, 1)]</li></ul></li><li><code>element()</code><ul><li>该方法会返回一个迭代器，其中包含元素的重复次数，如果这个元素出现次数为0，则不会返回该元素，可以作为字符串对其进行处理</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my = Counter(<span class="string">&quot;123123asdasdas&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(my.elements()))</span><br><span class="line"><span class="comment"># 112233aaasssdd</span></span><br></pre></td></tr></table></figure><h2 id="defaultdict类"><a href="#defaultdict类" class="headerlink" title="defaultdict类"></a>defaultdict类</h2><p>普通的字典在使用的时候，如果键不存在则会报错<code>KeyError</code>，这一点很影响使用体验，当然也可以每次都采用<code>dic.get(key, defaultValue)</code>的方式去获取值。这时就可以使用defaultdic来创建一个具有默认值的字典，这里的类型可以是整型、浮点型、列表、元祖、集合、字典等。</p><table><thead><tr><th>类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>float</td><td>0.0</td></tr><tr><td>list</td><td>[]</td></tr><tr><td>tuple</td><td>()</td></tr><tr><td>set</td><td>set()</td></tr><tr><td>dict</td><td>{}</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dic = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">print(dic[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="OrderDict"><a href="#OrderDict" class="headerlink" title="OrderDict"></a>OrderDict</h2><p>OrderDict是一个可以按照元素添加顺序来存储键值对的字典类型，可以确保元素的顺序性。除了拥有普通字典的所有的操作以外，多了个顺序性。</p><p>底层采用的是双向链表，可以解决LRU算法的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="number">1</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">od[<span class="number">2</span>] = <span class="string">&quot;Java&quot;</span></span><br><span class="line">od[<span class="number">3</span>] = <span class="string">&quot;Golang&quot;</span></span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># OrderedDict([(1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;), (3, &#x27;Golang&#x27;)])</span></span><br></pre></td></tr></table></figure><p>可以确保元素的打印顺序</p><p>其中有几个实用的方法：</p><ul><li>popitem(last=True)<ul><li>该方法会移除字典最后一个元素，可以接收一个参数，如果为空默认为True移除最后一个元素，如果为False则移除第一个元素。</li></ul></li><li>move_to_end(key, last=True)<ul><li>该方法会将指定key位置的元素移动到字典的最后【默认情况】，如果last为False则移动到最开头位置。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="number">1</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">od[<span class="number">2</span>] = <span class="string">&quot;Java&quot;</span></span><br><span class="line">od[<span class="number">3</span>] = <span class="string">&quot;Golang&quot;</span></span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># od.popitem(0)</span></span><br><span class="line"><span class="comment"># print(od)</span></span><br><span class="line">od.move_to_end(<span class="number">3</span>,<span class="literal">False</span>)</span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># OrderedDict([(1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;), (3, &#x27;Golang&#x27;)])</span></span><br><span class="line"><span class="comment"># OrderedDict([(3, &#x27;Golang&#x27;), (1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;)])</span></span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>作为一个双端队列，此部分可以参考【<a href="https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">二叉树总结</a>】</p><p>实现树的层次遍历，使用popleft()方法可以提升效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python内置模块collections解析&quot;&gt;&lt;a href=&quot;#Python内置模块collections解析&quot; class=&quot;headerlink&quot; title=&quot;Python内置模块collections解析&quot;&gt;&lt;/a&gt;Python内置模块collect</summary>
      
    
    
    
    
    <category term="Python" scheme="https://guoxiansen.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常见限流算法</title>
    <link href="https://guoxiansen.github.io/2024/03/25/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>https://guoxiansen.github.io/2024/03/25/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</id>
    <published>2024-03-25T00:40:04.000Z</published>
    <updated>2024-03-25T00:52:59.768Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250840747.png" alt="image-20240325084030703"></p><h1 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h1><ul><li>固定窗口限流算法</li><li>滑动窗口限流算法</li><li>漏桶限流算法</li><li>令牌桶限流算法</li></ul><h2 id="滑动窗口限流算法"><a href="#滑动窗口限流算法" class="headerlink" title="滑动窗口限流算法"></a>滑动窗口限流算法</h2><p>有时候用户的一些无意义或者非法操作，例如频繁的发送短信、频繁的修改个人信息等操作就是无意义或者非法的，因此我们要针对这些操作进行限流。</p><p>限流的主要核心思路就是使用redis的zset结合滑动窗口限流算法，</p><p>针对这些行为，我设计了一个通用的接口，思路上是使用时间窗口限流算法，具体实现我使用zset进行的。</p><p>比如用户五分钟内只能发送三条验证码，于是就将用户发送短信的行为设计为redis的key，格式为：</p><p><strong>场景:行为:用户唯一标识</strong>，zset的score分数值为时间戳，value值也是时间戳。</p><p>具体的流程为：</p><ul><li><p>当用户每次发生这样的限流行为，我就会在Redis中进行记录，</p></li><li><p>在业务处理中，使用Redis的api进行查询，本质上就是调用了Redis的<code>zcount</code>命令去统计，传入开始score值和结束score值，我们以当前时间戳作为结束分值，然后使用当前时间去减去限流时间，例如五分钟，求出五分钟之前的时间戳，于是根据这两个时间戳作为score分值，查询这个范围中限流行为的发生次数，判断该行为一共触发了几次。</p></li><li><p>后续的业务中，就根据不同的场景和需要进行校验。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250840747.png&quot; alt=&quot;image-20240325084030703&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;常见限流算法</summary>
      
    
    
    
    
    <category term="限流算法" scheme="https://guoxiansen.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap底层源码分析</title>
    <link href="https://guoxiansen.github.io/2024/03/18/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/18/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-03-18T02:03:18.000Z</published>
    <updated>2024-03-25T06:07:53.321Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072003833.png" alt="image-20240307200352512"></p><h1 id="HashMap底层源码分析"><a href="#HashMap底层源码分析" class="headerlink" title="HashMap底层源码分析"></a>HashMap底层源码分析</h1><p>HashMap主要是用来存放键值对的，它基于哈希表的Map接口实现，是常用的Java集合之一，是非线程安全的。</p><p>HashMap可以存放null的Key和value，但是null作为键只能有一个，作为value可以有多个</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">V <strong>put</strong>(K key, V value)</td><td align="center">添加元素</td></tr><tr><td align="center">V <strong>remove</strong>(Object key)</td><td align="center">根据键删除键值对元素</td></tr><tr><td align="center"><strong>void</strong> clear()</td><td align="center">移除所有的键值对元素</td></tr><tr><td align="center">boolean <strong>containsKey</strong>(Object key)</td><td align="center">判断集合是否包含指定的键</td></tr><tr><td align="center">boolean <strong>containsValue</strong>(Object value)</td><td align="center">判断集合是否包含指定的值</td></tr><tr><td align="center">boolean <strong>isEmpty</strong>()</td><td align="center">判断集合是否为空</td></tr><tr><td align="center">int <strong>size</strong>()</td><td align="center">集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><h3 id="HashMap内部方法"><a href="#HashMap内部方法" class="headerlink" title="HashMap内部方法"></a>HashMap内部方法</h3><p>图标为<code>m</code>表示<code>method</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181611363.png" alt="image-20240318161136018"></p><h3 id="HashMap内部类"><a href="#HashMap内部类" class="headerlink" title="HashMap内部类"></a>HashMap内部类</h3><p>图标为<code>c</code>表示<code>class</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181613451.png" alt="image-20240318161323108"></p><h3 id="HashMap内部属性"><a href="#HashMap内部属性" class="headerlink" title="HashMap内部属性"></a>HashMap内部属性</h3><p>图标为<code>f</code>表示<code>field</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181613605.png" alt="image-20240318161341292"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>HashMap中每个元素都是一个Entry对象，</p><p>数组+链表+红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示数组默认的大小 为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示默认的负载因子（加载因子）为0.75</span></span><br><span class="line"><span class="comment">// 当数组元素个数超过0.75*16=12的时候就进行扩容，扩容为原来的2倍空间大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示HashMap最大的空间为 1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap中的Hash值只与键有关系与值无关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回键所对应的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&gt;&gt;&gt;</code> 表示无符号右移</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>调用空参构造的时候，只把属性<code>loadFactor</code>初始化为0.75</p><p>剩余的核心源码主要涉及到put操作：</p><ul><li>如果当前位置没有值，则直接在数组中添加该键值对，即Node对象<ul><li>如果数组长度超过其初始长度16*0.75=12的时候，则会进行扩容，扩容成原来的2倍</li></ul></li><li>如果当前位置有值，需要判断和当前新添加的键是否一致： <strong>PUT操作</strong><ul><li>一致：<ul><li>则进行覆盖更新</li></ul></li><li>不一致：<ul><li>则在其后以链表的形式进行追加。</li><li>当链表的长度达到8【<code>TREEIFY_THRESHOLD</code>】的时候，则会调用<code>treeifyBin()</code>方法，此方法会根据HashMap数组长度来判断是否需要转成红黑树。只有当数组长度大于或者等于64【<code>MIN_TREEIFY_CAPACITY</code>】的情况下，才会执行转换红黑树的操作，以减少搜索时间。否则就只执行<code>resize()</code>方法对数组进行扩容。</li></ul></li></ul></li></ul><p>get操作：</p><p>判断hash和key是否相等，如果是就直接返回，如果不是，需要判断是否是红黑树，是的话按照红黑树的方式进行搜索；如果也不是红黑树就按照链表的顺序从前往后进行遍历查找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072003833.png&quot; alt=&quot;image-20240307200352512&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashMa</summary>
      
    
    
    
    
    <category term="HashMap" scheme="https://guoxiansen.github.io/tags/HashMap/"/>
    
    <category term="哈希表" scheme="https://guoxiansen.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://guoxiansen.github.io/2024/03/15/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://guoxiansen.github.io/2024/03/15/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2024-03-15T13:15:28.000Z</published>
    <updated>2024-03-26T02:40:50.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种特殊的数据结构，由数据表中的一列或者多列组成，可以用来快速查询数据库中的某一特定值的记录。</p><h2 id="索引的类型有哪些？"><a href="#索引的类型有哪些？" class="headerlink" title="索引的类型有哪些？"></a>索引的类型有哪些？</h2><h3 id="按照数据结构的维度进行划分："><a href="#按照数据结构的维度进行划分：" class="headerlink" title="按照数据结构的维度进行划分："></a>按照数据结构的维度进行划分：</h3><ul><li>BTree索引</li><li>哈希索引</li><li>RTree索引</li><li>全文索引<ul><li>对文本的内容进行分词，进行索引。目前只有CHAR、VARCHAR、TEXT列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如ElasticSearch代替。</li></ul></li></ul><h3 id="按照应用的维度划分："><a href="#按照应用的维度划分：" class="headerlink" title="按照应用的维度划分："></a>按照应用的维度划分：</h3><ul><li><p><strong>单列索引</strong></p><ul><li></li></ul></li><li><p><strong>联合索引</strong></p><ul><li>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li></ul></li><li><p>主键索引</p><ul><li>加速查询+列值唯一（不可以有NULL）</li></ul></li><li><p>普通索引</p><ul><li>仅加速查询</li></ul></li><li><p>唯一索引</p><ul><li>加速查询+列值唯一（可以有NULL）</li></ul></li><li><p>覆盖索引</p><ul><li>一个索引包含或者说覆盖所有需要查询的字段值</li></ul></li><li><p>全文索引</p></li></ul><p>联合索引：</p><p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或者复合索引。</p><p>以score和name两个字段建立联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`cus_order`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> id_score_name(score, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure><p>最左匹配原则，在使用联合索引的时候，mysql会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用字段过滤掉一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code>**、</strong><code>&lt;</code>** ）才会停止匹配。对于 <strong><code>&gt;=</code>**、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code>** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><p>在navicat中创建索引</p><h2 id="使用索引注意事项"><a href="#使用索引注意事项" class="headerlink" title="使用索引注意事项"></a>使用索引注意事项</h2><h3 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h3><ul><li><p>不为NULL字段：索引字段的数据应该尽量不为NULL，因为对数据为NULL的字段，数据库较难优化。如果字段频繁查询，但又避免不了为NULL，建议使用1，true，false这样语义较为清晰的短值或者短字符作为替代。</p></li><li><p>被频繁查询的字段：</p></li><li><p>被作为查询条件的字段</p></li><li><p>频繁需要排序的字段</p></li><li><p>被经常频繁用于连接的字段：</p></li><li><p>尽可能考虑建立联合索引而不是单列索引</p></li></ul><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><h2 id="为什么要用索引？"><a href="#为什么要用索引？" class="headerlink" title="为什么要用索引？"></a>为什么要用索引？</h2><p>这里我首先在数据库中插入了500多万条数据</p><p>创建数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_data`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`random`</span> <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>这里我用java的代码来往数据库中反复的插入数据， 具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertDataDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initConn</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/testdb?&quot;</span></span><br><span class="line">                + <span class="string">&quot;user=root&amp;password=xxxxxx&amp;useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamically load mysql driver</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Successfully loaded MySQL driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomStr</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Define an empty string</span></span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="comment">// Generate an int type integer between 97 ~ 122</span></span><br><span class="line">            <span class="keyword">int</span> intVal = (<span class="keyword">int</span>) (Math.random() * <span class="number">26</span> + <span class="number">97</span>);</span><br><span class="line">            <span class="comment">// Force conversion (char) intVal Convert the corresponding value to the corresponding character, and splicing the characters</span></span><br><span class="line">            result = result + (<span class="keyword">char</span>) intVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Output string</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> insertNum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// open time</span></span><br><span class="line">        Long begin = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Start Inserting Data...&quot;</span>);</span><br><span class="line">        <span class="comment">// sql prefix</span></span><br><span class="line">        String prefix = <span class="string">&quot;INSERT INTO tb_data (id, user_name, create_time, random) VALUES &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// save the sql suffix</span></span><br><span class="line">            StringBuffer suffix = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// Set the transaction to non-automatic commit</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            PreparedStatement pst = conn.prepareStatement(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= insertNum; i++) &#123;</span><br><span class="line">                <span class="comment">// Build sql suffix</span></span><br><span class="line">                suffix.append(<span class="string">&quot;(&quot;</span> + i + <span class="string">&quot;,&#x27;&quot;</span> + randomStr(<span class="number">8</span>) + <span class="string">&quot;&#x27;, SYSDATE(), &quot;</span> + i * Math.random() + <span class="string">&quot;),&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Build a complete sql</span></span><br><span class="line">            String sql = prefix + suffix.substring(<span class="number">0</span>, suffix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// Add execution sql</span></span><br><span class="line">            pst.addBatch(sql);</span><br><span class="line">            <span class="comment">// perform the operation</span></span><br><span class="line">            pst.executeBatch();</span><br><span class="line">            <span class="comment">// commit the transaction</span></span><br><span class="line">            conn.commit();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// close the connection</span></span><br><span class="line">            pst.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// End Time</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;insert&quot;</span> + insertNum + <span class="string">&quot; data data is completed!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Time-consuming : &quot;</span> + (end - begin) / <span class="number">1000</span> + <span class="string">&quot;seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        initConn();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            insert(<span class="number">50000</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到现在数据库中一共有523万条数据</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152118596.png" alt="image-20240315211801264"></p><p>现在我来随机进行一条user_name数据的查询，可以看到耗时39秒</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152119959.png" alt="image-20240315211945502"></p><h3 id="慢SQL查询"><a href="#慢SQL查询" class="headerlink" title="慢SQL查询"></a>慢SQL查询</h3><p>这里也是一道常见的面试问题，一般而言，可以在MySQL配置文件中开启慢查询日志，打开my.ini文件，找到<code>slow_query_log</code>，将其参数修改为<code>ON</code>，同时可以设置<code>long_query_time</code>来定义慢查询的阈值（以秒为单位，默认为10秒）。然后我们可以在本地的<code>hostname-slow.log</code>文件中查看到之前的慢sql语句。</p><p>注意：这里的<code>hostname</code>是指你笔记本/服务器的主机名称</p><p>打开文件，直接到最后：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152126574.png" alt="image-20240315212601235"></p><p>可以看到我刚进行的几条sql语句因为时间过长都被记录在日志当中了。然后开发人员就可以根据SQL语句来进行针对性的优化，这里我进行设置索引</p><p>这里也可以使用<code>EXPLAIN</code>语句查看这条SQL语句慢的原因：可以看到这里涉及到了523w行记录，所以会慢，因此我们可以考虑添加数据库索引</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152151306.png" alt="image-20240315215146207"></p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_user_name <span class="keyword">ON</span> tb_data (user_name);</span><br></pre></td></tr></table></figure><p>这样的方式我们就可以在tb_data表中给user_name列创建了一个名为idx_user_name的索引</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152155913.png" alt="image-20240315215538262"></p><p>创建索引的时间也比较漫长，可以看到花费了一百多秒</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152210565.png" alt="image-20240315221023511"></p><p>索引在本地也会生成一个<code>.MYI</code>的文件，思想是以空间换时间</p><p>现在我们在执行刚刚的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_data <span class="keyword">WHERE</span> user_name=<span class="string">&quot;gdpzfbho&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152157326.png" alt="image-20240315215701951"></p><p>可以看到查询时间肉眼可见的降低。</p><p>同时再次使用<code>explain</code>语句进行查询</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261040947.png" alt="image-20240315221419192"></p><p>发现这条命令已经是通过索引走的了</p><p>查看数据库引擎</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152208450.png" alt="image-20240315220851579"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;h2 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://guoxiansen.github.io/tags/MySQL/"/>
    
    <category term="索引" scheme="https://guoxiansen.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>JWT技术详解</title>
    <link href="https://guoxiansen.github.io/2024/03/15/JWT%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://guoxiansen.github.io/2024/03/15/JWT%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-03-15T12:12:57.000Z</published>
    <updated>2024-03-29T14:48:11.290Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250839890.png" alt="image-20240325083940667"></p><h2 id="常见的跨域认证方式："><a href="#常见的跨域认证方式：" class="headerlink" title="常见的跨域认证方式："></a>常见的跨域认证方式：</h2><ul><li><p>Session-Cookies</p></li><li><p>Toekn验证（包括jwt、SSO）</p></li><li><p>OAuth2.0（开放授权）</p></li></ul><h3 id="Session-Cookies实现方式："><a href="#Session-Cookies实现方式：" class="headerlink" title="Session-Cookies实现方式："></a>Session-Cookies实现方式：</h3><blockquote><ol><li>用户通过POST请求向服务器发送账号密码</li><li>服务器验证通过之后，在当前对话session中保存相应的数据，如用户角色、登录时间等</li><li>服务器向用户返回一个session_id，写入用户的cookies</li><li>用户随后的每一次请求，都会通过cookies，将session_id，传给服务器</li><li>服务器收到session_id，找到前期保存的数据，由此知道用户的身份。</li></ol></blockquote><p>这个流程在单机的时候没有问题，但是当服务器变为集群的时候，或者跨域的服务器的时候，Session就必须进行数据共享。</p><p>Cookies存在问题，容易被csrf攻击，解决攻击的方法：</p><ul><li>提交Form表单时，添加本域才能获取验证消息<ul><li>CSRF-Token</li></ul></li><li>防止不明外部域名的访问<ul><li>同源检测</li><li>Samesite Cookies</li></ul></li></ul><p>考虑每台服务器如何实现对Session的共享？</p><p>方式一：<strong>实现Session数据的持久化。</strong>当各种服务收到请求后，都向数据持久层请求数据，来验证是否是正确的用户。但是无论将Session存在服务器哪里都会带来额外的负担。这种方案的优点就是简单，但是扩展性不好，安全性较差。【】</p><p>方式二：<strong>使用JWT的方式。</strong>所有的数据都不保存在服务器端，而是保存在客户端，用户每次的请求都携带上Token令牌。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Toekn(JWT)是一个开放标准，它定义了一种紧凑且自包含的方式。</p><p>用途最多的地方就是授权</p><p>单点登录SSO也是广泛使用JWT的一项功能。</p><h3 id="JWT的数据结构"><a href="#JWT的数据结构" class="headerlink" title="JWT的数据结构"></a>JWT的数据结构</h3><ul><li>Header头部</li><li>Payload负载</li><li>Signature</li></ul><p>xxxx.yyyyyy.zzzz</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152026717.png" alt="img"></p><h2 id="JWT问题"><a href="#JWT问题" class="headerlink" title="JWT问题"></a>JWT问题</h2><ul><li>无法解决多个设备排他登录的问题</li><li>如何快速让一个用户下线</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250839890.png&quot; alt=&quot;image-20240325083940667&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的跨域认</summary>
      
    
    
    
    
    <category term="JWT" scheme="https://guoxiansen.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://guoxiansen.github.io/2024/03/14/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://guoxiansen.github.io/2024/03/14/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-14T14:25:43.000Z</published>
    <updated>2024-03-25T10:43:09.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p>NoSQL</p><h2 id="认识redis"><a href="#认识redis" class="headerlink" title="认识redis"></a>认识redis</h2><p>redis</p><p>Remote Dictionary Server  远程词典服务器</p><p>特征：</p><ul><li>键值型，value支持多种不同数据结构</li><li>单线程，每个命令具有原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据的持久化（定期将数据持久化到硬盘中）</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p>redis6.0开始的时候是网络请求部分多线程，其余的依旧是单线程</p><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>redis-cli -a   这个命令会调出控制台</p><p>redis-cli 进入到控制台的话，可以进入控制台，但是需要注意的是，如果设置了密码此时会提示你没有进行任何授权，需要进行授权</p><p>auth 123321</p><p>如果没有用户名直接auth + 密码即可</p><p>redis 常见命令</p><h3 id="Redis常见数据结构"><a href="#Redis常见数据结构" class="headerlink" title="Redis常见数据结构"></a>Redis常见数据结构</h3><ul><li><p>基本数据类型</p><ul><li><p>String类型</p></li><li><p>Hash类型</p></li><li><p>List类型</p></li><li><p>Set类型</p></li><li><p>SortedSet类型（ZSet）</p></li></ul></li><li><p>特殊类型</p><ul><li></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110911.png" alt="image-20240226172449416"></p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h3><p>通用命令是不分数据类型的，都可以使用的命令，常见的有：</p><ul><li><code>KEYS</code>：查看符合模板的所有key，不建议在生产环境中使用，会阻塞所有的请求</li><li><code>DEL</code>：删除一个指定的key</li><li><code>EXISTS</code>：判断key是否存在</li><li><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除</li><li><code>TTL</code>：查看一个key的剩余有效期</li></ul><p>如果一个key查询的有效期是-1，表示该key没有设置有效时间，即==永久有效==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110015.png" alt="image-20240226171638048"></p><p>如果查询的有效期是-2，则表示该key已经已经到期了</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110730.png" alt="image-20240226171824977"></p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110417.png" alt="image-20240226200526099"></p><p>底层都是以字节数组的形式去存储的，包括图片，最大的上限是<strong>512M</strong></p><h4 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h4><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p>Redis中没有MySQL中的表，如何区分不同类型的key？</p><p>例如需要存储用户、商品信息到redis，有一个用户id是1，商品id也是1怎么办？》</p><p>key的结构</p><p>Redis的key允许有多个单词构成层级结构，多个单词之间使用<code>:</code>隔开，格式如下：</p><p>项目名:业务名:类型:ID</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110917.png" alt="image-20240226202905967"></p><p>字符串类型的三种格式：</p><ul><li>字符型</li><li>int</li><li>float</li></ul><p>值的类型是一个字符串</p><p>keys匹配</p><h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>String结构中，值如果是json对象，需要修改的话，只能将整个字符串全部修改，这样的方式不方便</p><p>但是在hash结构中，可以将每个字段独立存储，可以针对单个字段进行CRUD</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402262110339.png" alt="image-20240226203943223"></p><h4 id="hash类型的常见命令"><a href="#hash类型的常见命令" class="headerlink" title="hash类型的常见命令"></a>hash类型的常见命令</h4><p>相较于String类型而言，就是在其前面加上H即可</p><p>类似于java中的map</p><p>值的类型是一个哈希表</p><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>值的类型是一个list集合，底层可以看做是一个双向链表，支持正向检索和反向检索</p><p>特点：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快（同链表）</li><li>查询速度一般</li></ul><p>如何利用list模拟一个栈？</p><p>如何利用list模拟一个队列？</p><p>如何利用list模拟一个阻塞队列？</p><ul><li>出口和入口在不同边</li><li>出队时采用BLPOP和BRPOP</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的set类型与Java中的HashSet类似</p><p>特点：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a>Set类型的常见命令</h4><ul><li>SADD key member：向set中添加一个或多个元素</li><li>SREM key member：移除set中的指定元素</li><li>SCARD key：返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中所有元素</li><li>SINTER key1 key2：求key1与key2的交集</li><li>SUNION key1 key2：返回多个集合的并集</li><li>SDIFF key1 key2：返回多个集合的差集</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271048773.png" alt="image-20240227104855579"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271104453.png" alt="image-20240227110446338"></p><h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>这是一个可排序的set集合，与Java的TreeSet有些类似，但底层数据结构差别很大。</p><p>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素进行排序，底层的实现是基于一个跳表+hash表</p><p>特点：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>用途</p><p>用于实现排行榜这样的功能</p><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><ul><li>ZREVRANK key member：获取降序排名</li><li>ZRANK key member：获取排名</li></ul><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271137856.png" alt="image-20240227113702079"></p><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>JedisTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.简历连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;1.94.65.33&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;郭寅之&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        String username = jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态初始化块，在类加载时执行，用于初始化静态成员变量或执行一些静态操作。</p><p>JedisConnectionFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;1.94.65.33&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式</p><p> <code>JedisConnectionFactory</code> 类中的 <code>jedisPool</code> 属性被声明为 <code>static</code>，并在静态初始化块中初始化。这样做确保了在整个应用程序生命周期中只有一个 Jedis 连接池实例。</p><p>工厂模式</p><p>类中的getJedis()方法充当了工厂方法，用于创建Jedis对象。它封装了Jedis连接池的创建和配置细节，并提供了一个统一的接口来获取Jedis对象。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271533856.png" alt="image-20240227153313280"></p><h4 id="使用Spring-Data-Redis步骤"><a href="#使用Spring-Data-Redis步骤" class="headerlink" title="使用Spring Data Redis步骤"></a>使用Spring Data Redis步骤</h4><ol><li>引入依赖</li><li>配置Redis</li><li>注入RedisTemplate</li><li>编写测试</li></ol><p>序列化的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271605167.png" alt="image-20240227160501118"></p><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为<strong>字节</strong>形式，默认采用JDK序列化。</p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><h3 id="redisTemplate"><a href="#redisTemplate" class="headerlink" title="redisTemplate"></a>redisTemplate</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402271716649.png" alt="image-20240227171629468"></p><h4 id="redisTemplate操作hash"><a href="#redisTemplate操作hash" class="headerlink" title="redisTemplate操作hash"></a>redisTemplate操作hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;gyz&quot;</span>);</span><br><span class="line">    redisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; entries = redisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战阶段"><a href="#实战阶段" class="headerlink" title="实战阶段"></a>实战阶段</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ul><li><p>短信登录</p><ul><li>Redis的共享session应用</li></ul></li><li><p>商户查询缓存</p><ul><li>企业缓存使用技巧</li><li>缓存雪崩、穿透等问题解决</li></ul></li><li><p>达人探店</p><ul><li>基于List的点赞列表</li><li>基于SortedSet的点赞排行榜</li></ul></li><li><p>优惠券秒杀</p><ul><li>Redis的计数器</li><li>Lua脚本</li><li>Redis分布式锁</li><li>Redis的三种消息队列</li></ul></li><li><p>好友关注</p><ul><li>基于Set集合的关注、取关、共同关注</li><li>消息推送</li></ul></li><li><p>附近的商户</p><ul><li>GeoHash的应用（根据地理坐标获取数据）</li></ul></li><li><p>用户签到</p><ul><li>BitMap数据统计功能</li></ul></li><li><p>UV统计</p><ul><li>HyperLogLog的统计功能</li></ul></li></ul><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="导入黑马点评项目"><a href="#导入黑马点评项目" class="headerlink" title="导入黑马点评项目"></a>导入黑马点评项目</h3><p>导入sql文件，其中包括</p><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li></li></ul><p>基于Session实现登录</p><p>集群的session共享问题</p><p>基于Redis实现共享session登录</p><h3 id="发送验证码的逻辑"><a href="#发送验证码的逻辑" class="headerlink" title="发送验证码的逻辑"></a>发送验证码的逻辑</h3><ul><li><p>发送短信验证码</p><ul><li>校验：手机号是否符合规定</li></ul></li><li><p>短信验证码登录、注册</p><ul><li>校验：手机号对应的用户是否存储在数据库中</li></ul></li><li><p>校验登录状态</p><ul><li>校验：</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402281056511.png" alt="image-20240228105642912"></p><h3 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h3><p>UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone,session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IUserService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">sendCode</span><span class="params">(String phone, HttpSession session)</span></span>;</span><br></pre></td></tr></table></figure><p>UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">sendCode</span><span class="params">(String phone, HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    String code = RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 4.保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    <span class="comment">// 调用第三方平台，此处进行模拟</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码 &#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回OK</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>拦截器</p><p>SpringMVC中提供了拦截器</p><p>集群的session共享问题</p><p>sessionStorage</p><h2 id="商户缓存查询"><a href="#商户缓存查询" class="headerlink" title="商户缓存查询"></a>商户缓存查询</h2><h3 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h3><p>缓存是数据交换的缓冲区，是存储数据的临时地方，一般读写性能高</p><p>缓存的作用</p><ul><li>降低后端负载，避免在后端频繁的查询数据库</li><li>降低读写效率，降低系响应时间</li></ul><p>成本：</p><ul><li>数据一致性</li><li>代码维护成本</li><li>运维成本</li></ul><h4 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402291052201.png" alt="image-20240229105250443"></p><p>根据ID查询商品缓存的流程</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402291055678.png" alt="image-20240229105500176"></p><p>原本的代码中是直接走数据库中进行查询的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询商铺信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 商铺id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 商铺详情数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getById是使用mybatis直接从数据库中进行查询，在IService中有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> T <span class="title">getById</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getBaseMapper().selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码中，首先会去缓存中查询，如果不存在才会去MySQL中查询</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402291311973.png" alt="image-20240229131126958"></p><p>业务场景：</p><ul><li>低一致性需求：使用Redis自带的内存淘汰机制。例如店铺类型的查询缓存</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存。</li></ul><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><p><code>Cache Aside Pattern</code>：由缓存的调用者，在更新数据库的同时更新缓存</p><p><code>Read/Write Through Pattern</code>：缓存和数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。</p><p><code>Write Behind Caching Pattern</code>：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402291433062.png" alt="image-20240229143343443"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li><p>缓存空对象</p><ul><li>思路：对于不存在的数据也在Redis建立缓存，值为空并设置一个较短的TTL时间</li><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致问题</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>在Redis和MySQL中间加上布隆过滤算法，在请求进入Redis之前先判断是否存在，如果不存在则直接拒接请求。</li><li>优点：占用内存少</li><li>缺点：实现复杂；可能存在误判的情况，即布隆过滤算法说MySQL中有，但是实际并没有该数据的情况</li></ul></li></ul><p><strong>店铺如果不存在，将空值写入Redis</strong></p><p><strong>命中时，如果为空值，也需要返回不存在</strong></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是同一时段<strong>大量的缓存key同时失效</strong>或者<strong>Redis服务器宕机</strong>，导致大量的请求到达数据库，带来巨大的压力。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫<strong>热点Key问题</strong>，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数请求访问会在瞬间给数据库带来巨大的冲击。</p><p>热点Key + 缓存重建时间比较长</p><ul><li>缓存重建业务较为复杂：<ul><li>涉及到多表查询或者表关联运算，业务耗时比较长，可能有数百毫秒</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403021136644.png" alt="image-20240302113645651"></p><p>缓存雪崩是由于大量key过期导致的结果，缓存击穿是由于部分的key（通常是一些热点key）突然失效的结果。</p><h4 id="解决缓存击穿的方法"><a href="#解决缓存击穿的方法" class="headerlink" title="解决缓存击穿的方法"></a>解决缓存击穿的方法</h4><ul><li><p>互斥锁</p><ul><li><p>缓存重建的过程中加锁，确保重建过程只有一个线程执行，其他线程阻塞</p></li><li><p>优点：</p><ul><li>实现简单</li></ul></li><li><p>缺点：</p><ul><li>等待导致性能的下降</li><li>有死锁的风险</li></ul></li></ul></li><li><p>逻辑过期</p><ul><li>不给key设置ttl，在其value中加上一个字段<code>expire</code> 表示过期时间（时间戳）</li><li>热点key缓存用户过期，而是设置一个逻辑过期时间，查询到数据时通过对逻辑过期时间进行判断，决定是否需要重建缓存</li><li>重建缓存也通过互斥锁保证单线程执行</li><li>重建缓存利用独立线程异步执行</li><li>其他线程无需等待，查询到旧数据即可。</li><li>优点：<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点<ul><li>不能保证数据一致性</li><li>有额外的内存消耗</li><li>实现复杂</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403021059983.png" alt="image-20240302105919012"></p><h4 id="互斥锁解决缓存击穿"><a href="#互斥锁解决缓存击穿" class="headerlink" title="互斥锁解决缓存击穿"></a>互斥锁解决缓存击穿</h4><p>2024.3.2</p><h4 id="逻辑过期解决缓存击穿"><a href="#逻辑过期解决缓存击穿" class="headerlink" title="逻辑过期解决缓存击穿"></a>逻辑过期解决缓存击穿</h4><p>2024/3/3</p><p>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403031542890.png" alt="image-20240303154206212"></p><h3 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h3><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置TTL过期时间</strong></li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置<strong>逻辑过期时间</strong>，用户处理缓存击穿问题</li><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存控制的方法解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期时间解决缓存击穿问题。</li></ul><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><p>订单表如果使用数据库自增ID就会存在一些问题：</p><ul><li>ID规律太明显</li><li>首单表数据量的限制</li><li>订单需要确保唯一性</li></ul><h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p>全局ID生成器，是一种在<strong>分布式系统</strong>下用来生成全局唯一ID的工具，一般要满足下列特征：</p><ul><li><p><strong>唯一性（订单ID必须唯一）</strong></p></li><li><p>高可用</p><ul><li>集群方案、主从方案、哨兵方案</li></ul></li><li><p>高性能</p><ul><li>速度足够快</li></ul></li><li><p>递增性</p><ul><li>单调递增性，有利于创建数据库索引</li></ul></li><li><p>安全性</p><ul><li></li></ul></li></ul><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是<strong>拼接一些其他信息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403052215788.png" alt="image-20240305221539377"></p><p>8个字节，64个比特位</p><h3 id="实现优惠券秒杀下单"><a href="#实现优惠券秒杀下单" class="headerlink" title="实现优惠券秒杀下单"></a>实现优惠券秒杀下单</h3><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h3 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h3><h3 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a>Redis消息队列实现异步秒杀</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis基础&quot;&gt;&lt;a href=&quot;#Redis基础&quot; class=&quot;headerlink&quot; title=&quot;Redis基础&quot;&gt;&lt;/a&gt;Redis基础&lt;/h1&gt;&lt;p&gt;NoSQL&lt;/p&gt;
&lt;h2 id=&quot;认识redis&quot;&gt;&lt;a href=&quot;#认识redis&quot; clas</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://guoxiansen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>前缀和整理</title>
    <link href="https://guoxiansen.github.io/2024/03/13/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B4%E7%90%86/"/>
    <id>https://guoxiansen.github.io/2024/03/13/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B4%E7%90%86/</id>
    <published>2024-03-13T13:12:25.000Z</published>
    <updated>2024-03-13T14:32:55.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><blockquote><p>2024年3月9日美团笔试 前缀和 * 1</p><p>2024年3月13日 携程笔试 前缀和 * 1</p></blockquote><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="2602、使数组元素全部相等的最少操作次数"><a href="#2602、使数组元素全部相等的最少操作次数" class="headerlink" title="2602、使数组元素全部相等的最少操作次数"></a>2602、使数组元素全部相等的最少操作次数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132151734.png" alt="image-20240313215122293"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153581.png" alt="image-20240313215333584"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153069.png" alt="image-20240313215347177"></p><p>本题类似于<strong>携程</strong>的笔试题，暴力算法的时间复杂度为<code>O(n²)</code>，n=10^5，铁超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], queries: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            operation = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                operation += <span class="built_in">abs</span>(nums[i]-q)</span><br><span class="line">            res.append(operation)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153379.png" alt="image-20240313215259899"></p><p>正确思路：</p><p>前缀和+二分查找</p><p>构造前缀和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], queries: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        s = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))  <span class="comment"># 前缀和</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            j = bisect_left(nums, q)</span><br><span class="line">            <span class="comment"># print(j)</span></span><br><span class="line">            left = q * j - s[j]  <span class="comment"># 蓝色面积</span></span><br><span class="line">            right = s[n] - s[j] - q * (n - j)  <span class="comment"># 绿色面积</span></span><br><span class="line">            ans.append(left + right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132223074.png" alt="image-20240313222304904"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;2024年3月9日美团笔试 前缀和 * 1&lt;/p&gt;
&lt;p&gt;2024年3月13日 携程笔试 前缀和 * 1&lt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="前缀和" scheme="https://guoxiansen.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记</title>
    <link href="https://guoxiansen.github.io/2024/03/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://guoxiansen.github.io/2024/03/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-12T12:04:43.000Z</published>
    <updated>2024-04-01T13:47:33.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础（黑马）"><a href="#Java基础（黑马）" class="headerlink" title="Java基础（黑马）"></a>Java基础（黑马）</h1><p>提示忽略大小写</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312012223518.png" alt="image-20231201222339340"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="字符串和字符的加操作"><a href="#字符串和字符的加操作" class="headerlink" title="字符串和字符的加操作"></a>字符串和字符的加操作</h3><p>字符+数字或者字符+数字时，会把字符通过ASCII码表查询到对应的数字再进行计算。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032148920.png" alt="image-20231203214853071"></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h2 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h2><p>例如在登录程序中，判断用户名**&amp;&amp;**密码</p><p>1、用户名正确，需要判断密码</p><p>2、用户名错误，无需判断密码</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311302221708.png" alt="image-20231130222117356"></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032213733.png" alt="image-20231203221258452"></p><p>数组的定义</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032217919.png" alt="image-20231203221737720"></p><h2 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h2><p>完整格式</p><p>数据类型[] 数组名 = new 数据类型[] {元素1， 元素2 …}</p><p>简化格式</p><p>数据类型[] 数组名 = {1,2,3,4,5}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>idea中打印地址值</p><p><strong>[I@1b6d3586</strong></p><ul><li><p><code>[</code> 表示当前是一个数组</p></li><li><p><code>I</code> 表示当前数组中的元素都是int类型的</p></li><li><p><code>@</code> 表示一个间隔符号（固定格式）</p></li><li><p><code>1b6d3586</code>  这部分才是数组真正的地址值（十六进制）</p></li></ul><p>arr.fori  可以在idea中快速的遍历数组</p><h2 id="数组的动态初始化"><a href="#数组的动态初始化" class="headerlink" title="数组的动态初始化"></a>数组的动态初始化</h2><p>数据类型[] 数组名 = new 数据类型[数组长度]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>在创建的时候，由我们自己制定数组的长度，由虚拟机给出默认的初始化值</p><h3 id="数组默认初始化值"><a href="#数组默认初始化值" class="headerlink" title="数组默认初始化值"></a>数组默认初始化值</h3><p>整数类型：默认初始化值是<code>0</code></p><p>小数类型：默认初始化值是<code>0.0</code></p><p>字符类型：默认初始化值是<code>/u0000</code>  展现形式是一个空格</p><p>布尔类型：默认初始化值是<code>false</code></p><p>引用数据类型：默认初始化值是<code>null</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041037650.png" alt="image-20231204103755487"></p><h2 id="数组的内存图"><a href="#数组的内存图" class="headerlink" title="数组的内存图"></a>数组的内存图</h2><p>Java的内存分配</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041315125.png" alt="image-20231204131458724"></p><ul><li>栈（内存）<ul><li>方法运行时使用的内存，比如main方法运行，进入方法栈中执行</li></ul></li><li>堆（内存）<ul><li>存储对象或者数组，new创建来的都是存储在堆内存</li></ul></li><li>方法区<ul><li>存储可以运行的<code>.class</code>文件</li></ul></li><li>本地方法栈<ul><li>JVM在使用操作系统功能的时候使用，与开发无关</li></ul></li><li>寄存器<ul><li>给CPU使用，与开发无关</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041316071.png" alt="image-20231204131655243"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041322395.png" alt="image-20231204132211905"></p><h2 id="数组的常见问题"><a href="#数组的常见问题" class="headerlink" title="数组的常见问题"></a>数组的常见问题</h2><ul><li>索引越界问题</li></ul><p>注意访问数组的下标是在合法区间的</p><h2 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h2><ul><li>求最值</li><li>求和</li><li>交换数据</li><li>打乱数据（抽奖优化）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041058601.png" alt="image-20231204105834849"></p><ul><li>生成随机数</li></ul><p>Java中生成随机数使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> number = r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Random括号中的参数是范围，左闭右开</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组静态初始化</p><p>初始化的时候可以写成多行，一行一个一维数组，这样方便我们进行查看</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312042143605.png" alt="image-20231204214318774"></p><p>二维数组的动态初始化</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121930313.png" alt="image-20231204220823419"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312042207266.png" alt="image-20231204220705518"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121930868.png" alt="image-20231204220753402"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法是程序中最小的执行单元</p><p>方法命名规范：首字母小写和驼峰命名相结合  例如getResult()</p><h2 id="方法的格式"><a href="#方法的格式" class="headerlink" title="方法的格式"></a>方法的格式</h2><p>方法的定义与调用</p><ul><li>最简单的方法调用</li><li>带参数的方法定义</li><li>带返回值的方法定义</li></ul><p>带参数方法的定义</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041400398.png" alt="image-20231204140009375"></p><p>带参数方法的调用</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041400609.png" alt="image-20231204140024968"></p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><ul><li>形参：指方法定义中的参数</li><li>实参：方法调用中的参数</li></ul><p>带返回值的方法定义</p><p>带返回值的方法调用</p><ul><li>直接调用</li><li>赋值调用</li><li>输出调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041444094.png" alt="image-20231204144450184"></p><ul><li>方法与方法之间是平级关系，不能互相嵌套定义</li><li></li></ul><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>在同一个类中，定义了多个同名方法，这些同名的方法具有同种功能。</p><p>每个方法有不同的参数类型或者参数个数，这些同名的方法构成了重载关系</p><p>方法名相同，参数不同的方法  | ==与返回值无关==</p><p>参数不同：个数不同、类型不同、顺序不同</p><p>定义方法时候可以把相同功能的定义成一样的名字：</p><ul><li>定义方法时候可以不用那么多单词</li><li>调用方法时候也不需要那么麻烦了</li></ul><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><p>println(“abc”) //先打印abc再进行换行</p><p>print(“abc”)    //只打印abc不进行换行</p><h2 id="方法的基本内存原理"><a href="#方法的基本内存原理" class="headerlink" title="方法的基本内存原理"></a>方法的基本内存原理</h2><ol><li>方法的基本内存原理</li><li>方法传递基本数据类型内存原理</li><li>方法传递引用数据类型的内存原理</li></ol><p>什么是基本数据类型</p><ul><li>整数类型</li><li>浮点数类型</li><li>布尔类型</li><li>字符类型</li></ul><p>什么是引用数据类型</p><ul><li>除了上面的其他所有类型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041707151.png" alt="image-20231204170715357"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312041709647.png" alt="image-20231204170916665"></p><h2 id="方法值传递"><a href="#方法值传递" class="headerlink" title="方法值传递"></a>方法值传递</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051112990.png" alt="image-20231205111214793"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ul><li>类（设计图）：是对象共同特征的描述</li><li>对象：是真实的具体的东西</li></ul><p>需要先设计类，在实例化对象</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051117042.png" alt="image-20231205111701386"></p><p>定义类的补充注意事项</p><ul><li>用来描述一类事物的类，专业叫做 ==<strong>Javabean类</strong>==<ul><li>在Javabean类中是不写main方法的</li></ul></li><li>在之前编写的main方法类，叫做==<strong>测试类</strong>==<ul><li>可以在测试类中创建javabean类的对象并进行赋值调用</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081307875.png" alt="image-20231205112812409"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081308961.png" alt="image-20231205112844516"></p><p>类名首字母要大写、英文、有意义，满足驼峰规则，不能使用关键字，满足标识符规定</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051143926.png" alt="image-20231205114351233"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051308831.png" alt="image-20231205130854753"></p><p>private关键字</p><ul><li>是一个权限修饰符</li><li>可以修饰（成员变量和成员方法）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051325837.png" alt="image-20231205132524442"></p><p>就近原则和<code>this</code>关键字</p><p>this的作用是可以区分成员变量和局部变量</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>作用：在创建对象的时候给成员变量进行赋值</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051937388.png" alt="image-20231205193751144"></p><p>构造方法的定义</p><ul><li>如果没有定义构造方法，系统会给出默认的无参构造方法<ul><li>这时候可以直接使用new Teacher()这样的方式去定义对象</li></ul></li><li>如果定义了有参的构造方法，系统则不会提供默认的构造方法<ul><li>如果这时候使用new Teacher()空参去定义对象则会报错</li></ul></li></ul><p>有参构造和无参构造没有返回值，并且这两者属于构造方法的重载</p><p>因为后面无论是否使用，都需要将两种构造方法都写出来</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051957248.png" alt="image-20231205195748933"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051958704.png" alt="image-20231205195824760"></p><p>构造方法</p><ul><li>无参构造方法<ul><li>初始化对象时，成员变量的数据均采用默认值。</li><li>初始化对象时，同时可以为对象进行赋值。</li></ul></li><li>有参构造方法</li></ul><h2 id="标准的Javabean类"><a href="#标准的Javabean类" class="headerlink" title="标准的Javabean类"></a>标准的Javabean类</h2><p>插件==<strong>PTG</strong>==  可以快速生成一个标注的Javabean类</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052001158.png" alt="image-20231205200105002"></p><h2 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h2><ul><li>一个对象的内存图</li><li>多个对象的内存图</li><li>两个变量指向同一个对象的内存图</li><li>this的内存原理</li><li>基本数据类型和引用数据类型的区别</li><li>局部变量和成员变量的区别</li></ul><h3 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052016623.png" alt="image-20231205201646276"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052025289.png" alt="image-20231205202524019"></p><p>main方法执行完毕之后，程序会退出栈，之前定义的对象所占用的堆内存空间也就变成了垃圾</p><h3 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h3><p>第二次实例化同一个对象的时候不会再重复加载class文件</p><p>其余的过程和一个对象的内存图差不多</p><h3 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h3><p>修改其中一个引用会对另一个引用进行覆盖</p><h2 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h2><p>如果没有使用this，在变量进行使用的时候会根据就近原则进行选择</p><p>this 可以区分局部变量和成员变量</p><p>this ==的本质是表示所在方法调用者的地址值==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052049338.png" alt="image-20231205204949671"></p><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>成员变量：类中方法外的变量</p><ul><li>位于堆内存中</li></ul><p>局部变量：方法中的变量（对象中的方法内）</p><ul><li>位于栈内存中（具体是在栈中方法内）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052054236.png" alt="image-20231205205423943"></p><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>API帮助文档</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071315086.png" alt="image-20231207131510925"></p><p>字符串在开发中的场景</p><ul><li>登录<ul><li>账号</li><li>密码 校验</li></ul></li><li>字符串敏感词替换  ***</li><li>人民币转大写</li></ul><p>字符串相关API</p><ul><li>String</li><li>==<strong>StringBuilder</strong>==</li><li>StringJoiner</li><li>StringBuffer</li><li>Pattern</li><li>Matcher</li></ul><p>字符串的底层原理</p><p>字符串的练习题</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>java.lang.String</code> 代表字符串类，java程序中的所有字符串文字（例如”abc”)都是此类的对象</p><p>字符串的内容是不会发生改变的，他的对象在创建后不能被更改</p><h3 id="字符串为什么要设计成不可变类型？"><a href="#字符串为什么要设计成不可变类型？" class="headerlink" title="字符串为什么要设计成不可变类型？"></a>字符串为什么要设计成不可变类型？</h3><ul><li>保存字符串的数组被<code>final</code>关键字修饰并且为私有，同时<code>String</code>类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code>类被<code>final</code>关键字修饰导致其不能被继承，进而避免了子类破坏<code>String</code>不可变</li></ul><p>String中的对象是不可变的，也可以理解为常量，线程安全。</p><p><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code>没有对方法进行加同步锁，所以是非线程安全的。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>每次对于String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的String对象。<code>StringBuffer</code>每次会对<code>Stringbuffer</code>对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下，<code>StringBuffer</code>性能比<code>StringBuilder</code>低10%-15%左右，但是在性能上是更加安全的。</p><p>总结：</p><ul><li>少用String</li><li>单线程下对字符串缓冲区操作大量数据：适用<code>StringBuilder</code></li><li>多线程下对字符串缓冲区操作大量数据：使用<code>StringBuffer</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071319336.png" alt="image-20231207131915963"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081318650.png" alt="image-20231207131954075"></p><h3 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h3><ul><li><p>直接赋值</p><ul><li><pre><code class="java">String name = &quot;abc&quot;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ new</span><br><span class="line"></span><br><span class="line">  + 通过空参构建一个空白的字符串</span><br><span class="line">  + 通过带参构造方法构初始化一个字符串对象</span><br><span class="line">  + 通过字符数组来创建字符串对象</span><br><span class="line">  + 通过字节数组来创建字符串对象（字符所对应的ASCII码表中的数字！）</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20231207132048098](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;GuoXianSen&#x2F;pic-bed@main&#x2F;imgs&#x2F;202312071332083.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;1、使用直接赋值的方式获取一个字符对象</span><br><span class="line">String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">&#x2F;&#x2F;2、使用new的方式来获取一个字符串对象</span><br><span class="line">&#x2F;&#x2F;空参构造：可以获取一个空白的字符串对象</span><br><span class="line">String s2 &#x3D; new String();</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传递一个字符串，根据传递进来的字符串创建一个新的字符串对象</span><br><span class="line">String s3 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(s3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传递进来一个字符数组，根据字符数组的内容创建一个新的字符串对象</span><br><span class="line">char[] chs &#x3D; new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;</span><br><span class="line">String s4 &#x3D; new String(chs);</span><br><span class="line">System.out.println(s4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传递进来一个字节数组，根据字节数组的内容创建一个字符串对象  转换为ASCII码表中对应的字符</span><br><span class="line">&#x2F;&#x2F;应用场景：在网络中以后传递的都是字节信息  要把字节信息转换成字符串就可以用到这个方法</span><br><span class="line">byte[] bytes &#x3D; new byte[]&#123;97,98,99,100&#125;;</span><br><span class="line">String s5 &#x3D; new String(bytes);</span><br><span class="line">System.out.println(s5);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="字符串创建的内存分析"><a href="#字符串创建的内存分析" class="headerlink" title="字符串创建的内存分析"></a>字符串创建的内存分析</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081318295.png" alt="image-20231207133312860"></p><p>StringTable（串池）在JDK7之后就从方法区挪到了堆内存</p><p>在使用直接赋值方式创建字符串的时候，如果发现串池中存在该字符串，则会直接将已存在的字符串拿过来==复用==节省空间，如果不存在才会创建一个新的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081318092.png" alt="image-20231207133532188"></p><p>手动new出来的字符串对象内存分析</p><p>如果出现重复的字符串则会多次占用内存空间</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081318115.png" alt="image-20231207134049016"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String aa = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String bb = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(aa == bb);</span><br><span class="line">String aaa = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String bbb = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(aaa == bbb);</span><br></pre></td></tr></table></figure><p>上面的这个代码中：</p><p><code>==</code>如果是比较引用数据类型，则会比较两个引用是否相等，java在进行编译的时候如果是字符串常量会放在常量池中，因此aa和bb都是引用的字符串常量池中的abc，所以<code>==</code>比较的引用对象是相等的.</p><p>对于第二个部分，是创建了两个新的字符串对象，这个字符串对象会被存储在堆内存中的不同位置，因此aaa和bbb的引用是不同的，所以会输出false。</p><p>如果说在项目中需要比较两个对象的值是否相等，可以使用继承自父类的<code>equals()</code>方法进行比较，String对象也重写了这个方法，会进行值的比较。</p><p>总结</p><p>使用直接赋值的方式创建字符串简单并且还会节约内存</p><h2 id="Java的常用方法（比较）"><a href="#Java的常用方法（比较）" class="headerlink" title="Java的常用方法（比较）"></a>Java的常用方法（比较）</h2><p><code>==</code>号比较的是什么内容？</p><ul><li>如果比较的是基本数据类型，则比较的是两者之间的==<strong>数据值</strong>==是否相等</li><li>如果比较的是引用数据类型，则比较的是两者之间的==<strong>地址值</strong>==是否相等</li></ul><p>这里的引用数据类型包括</p><ul><li>类</li><li>接口</li><li>数组</li><li>枚举类型</li><li>注解类型</li><li>字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s3==s4);  <span class="comment">//false</span></span><br><span class="line">        <span class="comment">// 比较字符串对象中的内容是否相等</span></span><br><span class="line">        System.out.println(s3.equals(s4));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><ul><li><p>boolean equals(要比较的字符串)  // 完全一样的结果才是true，否则为false</p></li><li><p>boolean equalsIgnoreCase(要比较的字符串) // 忽略大小写的比较    只能是忽略英文状态下的大小写</p><ul><li>可以用于验证码的比较</li></ul><p>键盘录入的字符串信息在底层源码中是new出来的，存在堆内存中，所以和直接赋值的字符串对象用<code>==</code>比较 结果为false</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s1 = sc.next();</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子结果为false</p><p>所以以后再比较字符串内容的时候，需要使用字符串的方法</p><p> <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071357484.png" alt="image-20231207135747775"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String username = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">        String passwd = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">3</span>; <span class="comment">// 三次输入机会</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag--;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">            String inputUsername = sc.next();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">            String inputPasswd = sc.next();</span><br><span class="line">            <span class="comment">//短路运算符</span></span><br><span class="line">            <span class="keyword">if</span> (username.equals(inputUsername) &amp;&amp; passwd.equals(inputPasswd)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户名或密码错误，请重新登录，还剩&quot;</span> + flag + <span class="string">&quot;次机会！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的账户被锁定，请联系管理!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="遍历字符串中的字符"><a href="#遍历字符串中的字符" class="headerlink" title="遍历字符串中的字符"></a>遍历字符串中的字符</h3><ul><li>charAt(int index)</li><li>length()</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081319292.png" alt="image-20231207141223070"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.键盘录入字符串</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        <span class="comment">//2.进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个字符为：&quot;</span> + ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计字符个数"><a href="#统计字符个数" class="headerlink" title="统计字符个数"></a>统计字符个数</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071417764.png" alt="image-20231207141701381"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo06</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计字符串中的大小写字母和数字的个数 （仅限字母）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&#x27;a&#x27;&gt;&#x27;b&#x27;);</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        String str = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> big = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母有&quot;</span>+big+<span class="string">&quot;个，&quot;</span>+<span class="string">&quot;小写字母有&quot;</span>+small+<span class="string">&quot;个，&quot;</span>+<span class="string">&quot;数字有&quot;</span>+number+<span class="string">&quot;个。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拼接字符串和反转"><a href="#拼接字符串和反转" class="headerlink" title="拼接字符串和反转"></a>拼接字符串和反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">        String res = reverseString(str);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length()-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            res += str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金额转换"><a href="#金额转换" class="headerlink" title="金额转换"></a>金额转换</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071552245.png" alt="image-20231207155247595"></p><h3 id="手机号加密"><a href="#手机号加密" class="headerlink" title="手机号加密"></a>手机号加密</h3><p>15011111871 –&gt; 150****1871</p><p>使用到<code>substring</code>方法</p><p><code>substring</code>共有两种重载</p><ul><li><p>该方法作用是获取从beginIndex开始到字符串末尾的子字符串并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span></span><br></pre></td></tr></table></figure></li><li><p>该方法作用是获取从beginIndex开始到endIndex之间的子字符串，注意是==左闭右开==，类似于Python中的<strong>切片</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入您的手机号：&quot;</span>);</span><br><span class="line">            String phonenumber = sc.next();</span><br><span class="line">            <span class="keyword">if</span> (phonenumber.length() == <span class="number">11</span>) &#123;</span><br><span class="line">                res = phoneModify(phonenumber);</span><br><span class="line">                System.out.println(<span class="string">&quot;加密后的手机号为：&quot;</span> + res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的手机号格式不对！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">phoneModify</span><span class="params">(String phonenumber)</span> </span>&#123;</span><br><span class="line">        String start = phonenumber.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        String end = phonenumber.substring(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> start + <span class="string">&quot;****&quot;</span> + end;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="敏感词替换"><a href="#敏感词替换" class="headerlink" title="敏感词替换"></a>敏感词替换</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071649974.png" alt="image-20231207164918544"></p><p>String replace(旧值, 新值) 替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo10</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 敏感词替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、获取说到的话</span></span><br><span class="line">        String talk = <span class="string">&quot;你真好，以后不要再玩了，TMD，CNM!&quot;</span>;</span><br><span class="line">        <span class="comment">//2、定义敏感词库</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;TMD&quot;</span>,<span class="string">&quot;CNM&quot;</span>,<span class="string">&quot;SB&quot;</span>,<span class="string">&quot;MLGB&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            talk = talk.replace(arr[i],<span class="string">&quot;****&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(talk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串拼接</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            s = s+<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个代码中进行字符串拼接会消耗很长的时间，但是如果使用StringBuilder可以很快的得到最终的结果</p><p>StringBuilder可以看成是一个容器，创建之后里面的内容是可变的</p><ul><li>作用：提高字符串操作效率</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071711899.png" alt="image-20231207171103441"></p><h3 id="Stringbuilder的构造方法"><a href="#Stringbuilder的构造方法" class="headerlink" title="Stringbuilder的构造方法"></a>Stringbuilder的构造方法</h3><ul><li>空参构造：创建一个空白的可变字符串对象，不包含任何内容</li><li>有参构造：根据字符串内容，来创建可变字符串对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071713527.png" alt="image-20231207171138575"></p><h3 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h3><ul><li>append(任意类型)   往容器中添加内容，并返回容器本身</li><li>reverse()        反转容器中的内容</li><li>length()          返回长度（字符出现的个数）</li><li>toString()       将StringBuilder类型转换为String</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071713641.png" alt="image-20231207171317248"></p><p>StringBuilder是Java已经写好的类，Java在底层对他做了一些特殊处理，打印对象不是地址值而是==属性值==</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="对称字符串"><a href="#对称字符串" class="headerlink" title="对称字符串"></a>对称字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071729695.png" alt="image-20231207172936473"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo03</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串是否对称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;123321a&quot;</span>;</span><br><span class="line">        System.out.println(judgeString(str));</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        System.out.println(judgeString2(sb));</span><br><span class="line">        System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        String inputstr = sc.next();</span><br><span class="line">        String res = <span class="keyword">new</span> StringBuilder().append(inputstr).reverse().toString();</span><br><span class="line">        System.out.println(inputstr.equals(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judgeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left) != str.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judgeString2</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        StringBuilder newsb = sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> newsb.equals(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用StringBuilder的场景</p><ul><li>字符串的拼接</li><li>字符串的反转</li></ul><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081319525.png" alt="image-20231207173940210"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071815990.png" alt="image-20231207181551456"></p><h2 id="Stringjoiner"><a href="#Stringjoiner" class="headerlink" title="Stringjoiner"></a>Stringjoiner</h2><p>Stringjoiner跟StringBuilder一样可以看成是一个容器，创建之后里面的内容是可变的</p><ul><li>作用：提高字符串的操作效率，代码编写简洁，但是目前市场上很少人用</li><li>JDK8以后才有的</li></ul><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081319121.png" alt="image-20231207191344247"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li>add()</li><li>length()</li><li>toString()   ：返回一个字符串，字符串就是拼接之后的结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081320802.png" alt="image-20231207191555277"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringjoinerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个对象，并指定中间的间隔符号</span></span><br><span class="line">        StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(sj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081320836.png" alt="image-20231207192326166"></p><p>字符串对象的总结</p><ol><li>String</li><li>StringBuilder</li><li>StringJoiner</li></ol><h2 id="字符串相关类的底层实现原理"><a href="#字符串相关类的底层实现原理" class="headerlink" title="字符串相关类的底层实现原理"></a>字符串相关类的底层实现原理</h2><ul><li><h3 id="字符串存储的内存原理"><a href="#字符串存储的内存原理" class="headerlink" title="字符串存储的内存原理"></a>字符串存储的内存原理</h3><ul><li>直接赋值可以服用字符串常量池中的字符串</li><li>new出来的不会复用，而是开辟一个新的空间（在堆内存中）</li></ul></li><li><h3 id="号比较的到底是什么？"><a href="#号比较的到底是什么？" class="headerlink" title="==号比较的到底是什么？"></a><code>==</code>号比较的到底是什么？</h3><ul><li>比较<strong>基本数据类型</strong>的时候比较数据值</li><li>比较<strong>引用数据类型</strong>的时候比较地址值</li></ul></li><li><h3 id="字符串拼接的底层原理"><a href="#字符串拼接的底层原理" class="headerlink" title="字符串拼接的底层原理"></a>字符串拼接的底层原理</h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081320112.png" alt="image-20231207193118571"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121935382.png" alt="image-20231207193529735"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081321328.png" alt="image-20231207193554024"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121935614.png" alt="image-20231207193947303"></p><p>JDK8之后的拼接原理</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121935993.png" alt="image-20231207194206504"></p><p>字符串拼接的时候不要直接+，会在底层创建多个对象，浪费时间和性能</p><ul><li><h3 id="StringBuilder提高效率的原理图"><a href="#StringBuilder提高效率的原理图" class="headerlink" title="StringBuilder提高效率的原理图"></a>StringBuilder提高效率的原理图</h3></li></ul><p>所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936287.png" alt="image-20231207194554171"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936431.png" alt="image-20231207194753052"></p><ul><li><h3 id="StringBuilder源码分析"><a href="#StringBuilder源码分析" class="headerlink" title="StringBuilder源码分析"></a>StringBuilder源码分析</h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936043.png" alt="image-20231207195128824"></p><p>容量：最多装多少</p><p>长度：已经装了多少</p><ol><li>初始化时候默认的容量是16   ==长度为16字节数组==</li><li>添加的内容长度小于16，则会直接存       </li><li>添加的内容长度大于16会进行扩容（老容量*2 + 2 = 34）</li><li>如果扩容之后还不够，则以实际长度为准</li></ol><p>toString()方法的底层是new了一个字符串对象</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ul><li><h4 id="调整字符串"><a href="#调整字符串" class="headerlink" title="调整字符串"></a>调整字符串</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936991.png" alt="image-20231207201453668"></p><p>修改字符串中的内容思路：</p><ul><li>subString</li><li>转换为字符数组来实现</li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>存放多个元素 –&gt; 数组</p><p>数组长度不可变，一旦定义了就不能改变，而集合就可以解决这个问题，集体的特点就是可以进行自动扩容</p><p>==自动扩容==</p><p>数组可以存放基本数据类型和引用数据类型</p><p>ArrayList</p><p>集合 vs 数组</p><ul><li>长度</li><li>存储类型<ul><li>数组可以存放基本数据类型和引用数据类型</li><li>集合只能存<strong>引用数据类型</strong>，如果需要存基本数据类型的话，需要改成所对应的<strong>包装类</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052102055.png" alt="image-20231205210214373"></p><p>集合包括</p><ul><li>ArrayList</li><li></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121959517.png" alt="image-20231205210231887"></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>&lt;E&gt;   泛型</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052107692.png" alt="image-20231205210702202"></p><h3 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h3><ul><li>ArrayList()<ul><li>构造一个初始容量为10的空列表</li></ul></li><li>ArrayList(int initialCapacity)<ul><li>构造具有指定初始容量的空列表</li></ul></li><li>ArrayList(Collection&lt;? extends E&gt; c)</li></ul><h3 id="ArrayList成员方法"><a href="#ArrayList成员方法" class="headerlink" title="ArrayList成员方法"></a>ArrayList成员方法</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052107983.png" alt="image-20231205210746377"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403041552702.png" alt="image-20240304155249479"></p><p>基本数据类型对应的包装类</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052124783.png" alt="image-20231205212425609"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建自定义对象的ArrayList"><a href="#创建自定义对象的ArrayList" class="headerlink" title="创建自定义对象的ArrayList"></a>创建自定义对象的ArrayList</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312052130160.png" alt="image-20231205213010427">、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建集合</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.创建学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="comment">//3.添加元素</span></span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Student stu = list.get(i);</span><br><span class="line">            System.out.println(stu.getAge()+stu.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><p>==Ctrl + P 可以查看有什么参数==</p><p>==Ctrl + Alt + T 查看包裹函数==</p><p>Ctrl + Alt + V 自动生成左边</p><p>Ctrl + N   搜索界面  查找相关的类或者包 点击即可查看源代码</p><p>shift + F6  批量修改变量名</p><p>Ctrl + Shift + U   小写转大写</p><p>Ctrl + H 查看继承树</p><h1 id="IDEA设置修改"><a href="#IDEA设置修改" class="headerlink" title="IDEA设置修改"></a>IDEA设置修改</h1><p>注释的时候从每一行开头进行注释修改为只从第一个字符前面开始</p><p>勾选掉方框中的勾和下面截图保持一致即可</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936229.png" alt="在这里插入图片描述"></p><p> 设置鼠标滚轮加Ctrl进行缩放</p><h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312062051863.png" alt="image-20231206205114664"></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static表示静态，是java中的一个修饰符，可以修饰成员方法、成员变量</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li>被该类所有对象共享</li><li>不属于对象，属于类</li><li>随着类的加载而加载，优先于对象而存在</li></ul><p>调用方式</p><ul><li>类名调用**==（推荐）==**</li><li>对象名调用</li></ul><p>static内存图</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121936979.png" alt="image-20231206211910028"></p><p>==共享的属性可以被定义为静态==</p><ul><li>比如同一个班级中每一个学生的老师姓名是可以使用static方法设置为静态变量的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312062120894.png" alt="image-20231206212017754"></p><p><code>teacherName</code>可以被定义为静态</p><h3 id="静态方法和工具类"><a href="#静态方法和工具类" class="headerlink" title="静态方法和工具类"></a>静态方法和工具类</h3><p>特点</p><ul><li>多用在测试类和工具类</li><li>Javabean类中很少会用</li></ul><p>调用方式</p><ul><li>类名调用（推荐）</li><li>对象名调用</li></ul><ul><li><h4 id="javabean类"><a href="#javabean类" class="headerlink" title="javabean类"></a>javabean类</h4><ul><li>用来描述一类事物的类，如Student、Teacher、Dog、Cat</li></ul></li><li><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><ul><li>之前写的main方法可以称之为测试类</li></ul></li><li><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ul><li>帮我们做一些事情，但是不描述任何事物的类<ul><li>类名见名知意   例如 printArr 表示打印数组</li><li>私有化构造方法 private</li><li><strong>方法定义为静态</strong></li></ul></li></ul></li></ul><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><h4 id="定义数组工具类"><a href="#定义数组工具类" class="headerlink" title="定义数组工具类"></a>定义数组工具类</h4><p>需求：在实际开发中，经常会遇到一些数组使用的工具类</p><p>请按照如下要求编写一个数组的工具类：ArrayUtil</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312062131823.png" alt="image-20231206213156251"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.面向对象进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ArrayUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印数组工具类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算数组平均数工具类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">double</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum / arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="学生工具类"><a href="#学生工具类" class="headerlink" title="学生工具类"></a>学生工具类</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000681.png" alt="image-20231208132527030"></p><h2 id="Static注意事项"><a href="#Static注意事项" class="headerlink" title="Static注意事项"></a>Static注意事项</h2><ul><li>==静态方法只能访问静态变量和静态方法==<ul><li>不能访问成员变量和成员方法</li><li>不能访问定义在同一个类中的成员变量和成员方法</li></ul></li><li>非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态成员方法</li><li>静态方法中是没有<code>this</code>关键字的</li></ul><p>this：表示当前方法调用者的地址值</p><p>这个this是由虚拟机赋值的，在调用的时候也不需要加上这个参数</p><p>非静态变量也被称之为实例变量</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081508634.png" alt="image-20231208150814971"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000233.png" alt="image-20231208151222017"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081514952.png" alt="image-20231208151357262"></p><p>单例设计模式是在多线程阶段进行讲解</p><h2 id="重新认识main方法"><a href="#重新认识main方法" class="headerlink" title="重新认识main方法"></a>重新认识main方法</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081516341.png" alt="image-20231208151603731"></p><p>如果想要在idea中添加参数运行程序，可以在edit configuration中进行配置</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081519960.png" alt="image-20231208151858441"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装：对象代表什么，就封装对应的数据并提供数据对应的行为</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000957.png" alt="image-20231208152022072"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000939.png" alt="image-20231208152234063"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000485.png" alt="image-20231208152250256"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000392.png" alt="image-20231208152308564"></p><p>在Java中提供了一个关键字<code>extends</code>，用这个关键字，我们可以让一个类和另一个类建立起继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Student称之为子类（派生类），Person称为父类（基类或超类）</li></ul><p>==继承的好处：==</p><ul><li>可以把多个子类中重复的代码抽取到父类中，提高代码的复用性</li><li>子类可以在父类的基础上，增加其他的功能，使子类更强大</li></ul><p>继承需要学习的点：</p><ul><li>自己设计</li><li>使用别人的代码(使用别人写好的)</li></ul><p>什么时候用继承？</p><p>①当类和类之间存在相同的内容，②并且满足子类是父类的一种，就可以考虑使用继承来优化代码</p><p>例如学生和老师类都可以继承自<code>Person</code>类</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000541.png" alt="image-20231208153053657"></p><p>​    <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000472.png" alt="image-20231208153902869"></p><h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><p>Java只支持单继承，不支持多继承，但支持==多层继承==</p><ul><li><h4 id="单继承：一个子类只能继承一个父类"><a href="#单继承：一个子类只能继承一个父类" class="headerlink" title="单继承：一个子类只能继承一个父类"></a>单继承：一个子类只能继承一个父类</h4></li><li><h4 id="不支持多继承：一个子类不能同事继承多个父类"><a href="#不支持多继承：一个子类不能同事继承多个父类" class="headerlink" title="不支持多继承：一个子类不能同事继承多个父类"></a>不支持多继承：一个子类不能同事继承多个父类</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122000674.png" alt="image-20231208154546575"></p><p>在上面这个例子中，如果Java有多继承就会导致方法的混乱</p><ul><li><h4 id="多层继承：子类A继承父类B，父类B可以继承父类C"><a href="#多层继承：子类A继承父类B，父类B可以继承父类C" class="headerlink" title="多层继承：子类A继承父类B，父类B可以继承父类C"></a>多层继承：子类A继承父类B，父类B可以继承父类C</h4></li></ul><p>C是A的间接父类，B是A的直接父类</p><p>每一个类都直接或者间接继承自Object</p><p>如果自己定义的一个类没有继承自某个父类，Java虚拟机在运行的过程中会自动添加一个Object父类</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081549820.png" alt="image-20231208154928418"></p><p>子类可以使用直接父类或者间接父类中的内容，但是叔叔类中的内容是不可以使用的</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081709778.png" alt="image-20231208155030322"></p><p>设计继承类</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081708341.png" alt="image-20231208160332658"></p><p>父类中方法的权限修饰符如果是private，则子类就无法进行继承了</p><p>private 私有的：只能在本类中进行访问</p><p>注意事项：</p><ul><li>子类只能访问父类中非自由的成员（成员变量 | 成员方法）</li></ul><h3 id="子类可以从父类中继承哪些内容？（内存图-内存分析工具）"><a href="#子类可以从父类中继承哪些内容？（内存图-内存分析工具）" class="headerlink" title="子类可以从父类中继承哪些内容？（内存图/内存分析工具）"></a>子类可以从父类中继承哪些内容？（内存图/内存分析工具）</h3><p>注意继承和调用是两个概念 | </p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081708359.png" alt="image-20231208161336929"></p><ul><li><h4 id="构造方法是否可以被继承？"><a href="#构造方法是否可以被继承？" class="headerlink" title="构造方法是否可以被继承？"></a>构造方法是否可以被继承？</h4><ul><li>不管是私有还是非私有的都无法继承</li><li>构造方法的规定就是方法名必须和类名一致，继承过来的话类名就不相同了</li></ul></li><li></li></ul><p>如果一个类中没有构造方法，虚拟机会自动给你添加一个默认的空参构造</p><ul><li><h4 id="成员变量是否可以继承"><a href="#成员变量是否可以继承" class="headerlink" title="成员变量是否可以继承"></a>成员变量是否可以继承</h4><ul><li>不管是私有的成员变量还是非私有的成员变量，子类都是可以继承的</li><li>私有的成员变量是可以使用get set方法进行使用</li><li></li></ul></li><li><h4 id="成员方法是否可以继承"><a href="#成员方法是否可以继承" class="headerlink" title="成员方法是否可以继承"></a>成员方法是否可以继承</h4><ul><li>虚方法表  可以被继承</li><li>否则不能被继承</li></ul></li></ul><p>虚方法表</p><p>非private修饰的方法</p><p>非final修饰的方法</p><p>非static修饰的方法</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312081708490.png" alt="image-20231208154032889"></p><h3 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h3><ul><li><strong>就近原则</strong></li></ul><p>现在局部位置找，然后在本类成员变量找，父类成员位置找，逐级向上</p><p>this 表示当前类的属性或者方法  指向的是调用类的实际内存地址  不写this也是默认是当前类</p><p>super 表示调用父类的方法</p><ul><li>如果出现重名的成员变量<ul><li>name<ul><li>从局部的位置往上去找</li></ul></li><li>this.name<ul><li>从本类成员位置往上找</li></ul></li><li>super.name<ul><li>从父类的成员位置往上找</li></ul></li></ul></li></ul><h3 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h3><p>就近原则    </p><p>方法的重写：</p><p>重写的本质是覆盖了虚方法表中的方法而已</p><p>应用场景：当父类的方法不能满足子类现在的需求时，需要进行方法的重写</p><p>子类中出现和父类一模一样的方法声明，我们就称之为方法的重写</p><p>@Override重写注解</p><ol><li>@Override是放在重写后的方法上的，校验子类重写时语法是否正确</li><li>加上注解后如果有红色的波浪线，表示语法错误</li><li>建议重写的方法都加上@Override注解，代码安全、优雅</li></ol><p>方法重写的注意事项和要求：</p><ul><li>重写方法的名称、形参列表必须和父类一致</li><li>子类重写父类方法时，访问权限子类必须大于等于父类（空着不写&lt;protected&lt;public）</li><li>子类重写父类方法时，返回值类型子类必须小于等于父类</li><li>建议：重写的方法尽量和父类保持一致</li><li>只有被添加到虚方法表中的方法才能被重写</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111031728.png" alt="image-20231211102920665"></p><p> <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111047337.png" alt="image-20231211104741907"></p><h3 id="继承中构造方法的特点"><a href="#继承中构造方法的特点" class="headerlink" title="继承中构造方法的特点"></a>继承中构造方法的特点</h3><ul><li>父类中的构造方法不会被子类继承</li><li>子类中的所有构造方法都会默认先访问父类中的无参构造，再执行自己</li></ul><p>为什么？</p><ul><li>子类在初始化的时候，有可能会调用父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据</li><li>子类初始化之前一定要调用父类构造方法先完成父类数据空间的初始化</li></ul><p>怎么调用父类的构造方法的？</p><ul><li>子类构造方法的第一行语句默认都是 super()  不写也存在且必须在第一行</li><li>如果想要调用父类有参构造，必须手动写super进行调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111055494.png" alt="image-20231211105542753"></p><p>继承中构造方法的访问特点</p><ul><li>子类不能继承父类的构造方法，但可以通过super调用</li><li>子类构造方法的第一行，有一个默认的super()</li><li>默认先访问父类中无参构造方法，在执行自己</li><li>如果要访问农夫类的有参构造，必须手动书写（参考上图，参数写在super的括号中）</li></ul><h3 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h3><ul><li>this 理解为一个变量 表示当前方法调用者的地址值</li><li>super 表示父类的存储空间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111101582.png" alt="image-20231211110154442"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111110802.png" alt="image-20231211111037142"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111117602.png" alt="image-20231211111714824"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>对象多种形态</p><p>什么是多态</p><ul><li>同类型的对象表现出的不同形态</li></ul><p>多态的表现形式</p><ul><li><strong>父类类型 对象名称 = 子类对象</strong>        </li></ul><p>多态的前提</p><ul><li><p>有<strong>继承</strong>、<strong>实现</strong>关系</p><ul><li>例如使用List&lt;String&gt; list = new ArrayList&lt;&gt;();这样的方式去定义一个list</li></ul></li><li><p>有父类引用指向子类对象   等于号左边是父类 右边是子类</p></li><li><p>有方法的重写</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111120957.png" alt="image-20231211112043584"></p><p>代码冗余</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001271.png" alt="image-20231211112207850"></p><p>现在需要一个通用的注册方法</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001370.png" alt="image-20231211112233751"></p><p>多态的好处：</p><ul><li>使用父类型作为参数，可以接收所有的子类对象</li><li>体现多态的扩展性与便利性</li></ul><h3 id="多态调用成员的特点"><a href="#多态调用成员的特点" class="headerlink" title="多态调用成员的特点"></a>多态调用成员的特点</h3><ul><li><strong>==变量调用：编译看左边，运行也看左边==</strong></li><li>==<strong>方法调用：编译看左边，运行看右边</strong>==</li></ul><h3 id="多态的优点和弊端"><a href="#多态的优点和弊端" class="headerlink" title="多态的优点和弊端"></a>多态的优点和弊端</h3><ul><li>在多态形势下，右边对象可以实现解耦合，便于扩展和维护</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.work(); <span class="comment">//业务逻辑发生改变时，后续代码无需修改</span></span><br></pre></td></tr></table></figure><ul><li>定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性和便利</li></ul><h4 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h4><ul><li><strong>不能调用子类的特有功能</strong></li></ul><p>编译看左边，检查父类是否有这个方法，如果没有则直接报错</p><p>解决方案：将调用者A直接变成子类型即可。转换的时候不能随便转，会报错</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111508744.png" alt="image-20231211150852695"></p><p><code>instance of</code>    判断是否是所对应的类型</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111512604.png" alt="image-20231211151217760"></p><p>引用类型的类型转换</p><ul><li>自动类型转换 （由小变大–&gt; 将子类对象赋值给父类对象）</li><li>强制类型转换 （父类转换为子类对象）<ul><li>可以转为真正子类类型，从而调用子类独有的功能</li><li>强制类型转换的时候转换类型与真实对象类型不一致会报错</li><li>转换的时候用<code>instanceof</code>关键字进行判断</li></ul></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包就是文件夹。用来管理各种不同功能的java类，方柏霓后期代码维护</p><ul><li><p>包名规则：公司域名反写 + 包的作用，需要全部英文年小写，见名知意  com.itheima.domain</p><ul><li>domain 表示文件夹内都存放javabean类</li></ul><p>使用import导入包</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001693.png" alt="image-20231211210944422"></p><h3 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h3><ul><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类时，不需要导包</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类，需要使用全类名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001240.png" alt="image-20231211212119446"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>不能被修改的</p><ul><li>方法<ul><li>表明该方法是最终方法，==不能被重写==</li></ul></li><li>类<ul><li>最终类，==不能被继承==</li></ul></li><li>变量<ul><li>常量，==只能被赋值一次==</li><li>Math包中的PI  表示圆周率就用final修饰</li></ul></li></ul><p>在实际开发中常量一般作为系统的配置信息，方便维护，提高可读性</p><p>常量的命名规范：</p><ul><li>单个单词：全部大写</li><li>多个单词：全部大写，单词之间用下划线隔开</li></ul><p>细节：</p><ul><li>final修饰的变量是基本类型：那么变量存储的地址值不能发生改变</li><li>final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部可以改变</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112156985.png" alt="image-20231211215612100"></p><p>对象的地址值不能修改，但是对象内部的成员属性是可以修改的</p><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><ul><li>权限修饰符：用来控制一个成员能够被访问的范围</li><li>可以修饰成员变量、方法、构造方法、内部类</li></ul><p>Java中有四种权限修饰符</p><p>作用范围从小到大 private &lt; 空着不写 &lt; protected &lt; public </p><p>private  私房钱，只能自己用</p><p>默认/缺省/空着不写 ： 只能在本包中使用</p><p>protected：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312121457632.png" alt="image-20231212145710104"></p><p>使用规则</p><p>实际开发中一般只用private和public</p><ul><li>成员变量私有</li><li>方法公开</li></ul><p>特例：如果方法中代码是抽取其他方法中共性代码的，这个方法一般也私有</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>{</p><p>}</p><p>括号中的代码，称之为代码块，共有如下几种情况：</p><ul><li>局部代码块</li><li>构造代码块</li><li>静态代码块</li></ul><h3 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h3><p>提前结束变量的生命周期 ==<strong>已淘汰</strong>==</p><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><ol><li>写在成员位置的代码块</li><li>作用：可以把多个构造反复噶种的重复代码抽取出来</li><li>执行时机：在创建本类对象的时候，会先执行构造代码块再执行构造方法</li></ol><p>渐渐淘汰了…  不够灵活</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001026.png" alt="image-20231212152326355"></p><p>优化方法：<br><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001391.png" alt="image-20231212152406876"></p><h3 id="静态代码块（-）"><a href="#静态代码块（-）" class="headerlink" title="静态代码块（*）"></a>静态代码块（*）</h3><p>格式：static{}</p><p>特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发，==<strong>只执行一次</strong>==</p><p>适用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用         </p><p>学生管理系统的时候可以初始化一些用户数据，</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象方法子类必须要重写，否则子类报错</p><p>抽象方法所在的类是抽象类</p><p>将共性的方法抽取到父类之后，由于每一个子类执行的内容不一样，父类中无法确定具体的方法体，就可以定义抽象方法</p><p>一个类中如果存在抽象方法，那么该类就必须声明为抽象类</p><h3 id="抽象类的定义格式"><a href="#抽象类的定义格式" class="headerlink" title="抽象类的定义格式"></a>抽象类的定义格式</h3><p>抽象方法的定义格式</p><ul><li>public abstract 返回值类型 方法名(参数列表);</li></ul><p>抽象类的定义格式：</p><ul><li>public abstract class 类名 {}</li></ul><p>抽象类和抽象方法的注意事项</p><ul><li>抽象类不能实例化</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类，可以有非抽象方法</li><li>抽象类可以有构造方法</li><li>抽象类的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><p>共性的内容放在父类，这样可以使得团队开发的时候 方法更加规范</p><h3 id="抽象类的定义方法"><a href="#抽象类的定义方法" class="headerlink" title="抽象类的定义方法"></a>抽象类的定义方法</h3><h3 id="子类继承抽象类之后如何重写抽象方法"><a href="#子类继承抽象类之后如何重写抽象方法" class="headerlink" title="子类继承抽象类之后如何重写抽象方法"></a>子类继承抽象类之后如何重写抽象方法</h3><h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><ul><li>定义抽象方法，作为一个规范</li><li>作为模板，强制子类去实现特定的行为</li><li>代码的复用和扩展</li><li>实现多态性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001445.png" alt="image-20231212194641135"></p><p>抽象类可以先定子类方法书写的格式</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>为什么要有接口？</p><p>游泳</p><p>理解为一个</p><p>接口的应用</p><ul><li><p>==<strong>接口就是一个规则，是对行为的抽象</strong>==</p></li></ul><p>接口和抽象类的区别？</p><p>接口的定义和使用</p><ul><li>接口使用关键字interface来进行定义的<ul><li>public ==interface== 接口名 {}</li></ul></li><li>接口不能实例化</li><li>接口和类之间是实现关系，通过implements关键字来表示<ul><li>public class 类名 ==implements== 接口名 {}</li></ul></li><li>接口的子类（实现类）<ul><li>要么实现接口中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><p>注意1：接口和类之间是实现关系，可以单实现，也可以多实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名1， 接口名2 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意2：实现类可以在继承一个类的同时实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口名1, 接口名2 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>接口是一种纯粹的抽象类型，只能包含抽象方法和常量</p><p>接口不能包含成员变量，但可以包含常量 stacic  final类型的变量</p><p>一个类可以同时继承一个类并实现多个接口</p><h3 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h3><ul><li><p>成员变量</p><ul><li>只能是常量</li><li>默认修饰符 public static final （Java自动添加的 通过内存分析工具可以查看）</li></ul></li><li><p>构造方法</p><ul><li>没有构造方法</li></ul></li><li><p>成员方法</p><ul><li>只能是抽象方法</li><li>默认修饰符 public abstract  如果没有写 会自动添加</li></ul></li><li><p>JDK7以前：接口中只能定义抽象方法</p></li><li><p>JDK8的新特性：接口中可以定义有方法体的方法</p></li><li><p>JDK9的新特性：接口中可以定义私有方法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122001895.png" alt="image-20231213204835976"></p><h3 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h3><ul><li>类和类之间的关系<ul><li>继承关系，只能单继承，不能多继承，但是可以多层继承</li></ul></li><li>类和接口的关系<ul><li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的时候同时实现多个接口</li></ul></li><li>接口和接口的关系<ul><li>继承关系，可以单继承，也可以==多继承==</li><li>如果接口是实现最下面的接口的时候，就需要实现整个体系中的所有抽象方法</li></ul></li></ul><h3 id="接口练习"><a href="#接口练习" class="headerlink" title="接口练习"></a>接口练习</h3><p> 一个父类中所有的子类需要是同一种事物</p><p> <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122002944.png" alt="image-20231213211720861"></p><h3 id="接口中新增方法"><a href="#接口中新增方法" class="headerlink" title="接口中新增方法"></a>接口中新增方法</h3><p>在jdk7之前如果都是使用抽象方法的话，如果在父接口中新增一个抽象方法，就需要在所有继承自其的子接口中实现该抽象方法，导致牵一发而动全身。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122002803.png" alt="image-20231213212322978"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122002893.png" alt="image-20231213212632689"></p><p>JDK8以后</p><ul><li>允许在接口中定义默认方法，需要使用关键字default修饰<ul><li>作用：解决接口升级的问题</li></ul></li><li>接口中默认方法的定义格式：<ul><li>格式：public ==default== 返回值类型 方法名(参数列表) { }</li><li>示例：public ==default== void show()P{ }</li></ul></li></ul><p>接口中默认方法的注意事项：</p><ul><li><p>默认方法不是抽象方法，所以不强制被重写，重写的时候去掉default关键字</p></li><li><p>public可以省略，default不能省略  省略了会被当成是抽象方法</p></li><li><p><strong>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</strong></p><p>静态方法</p></li><li><p>静态方法不能被重写</p></li><li><p>如果有一个同名的函数 且没有Override，只是有一个同名的方法而已</p></li></ul><p>重写是指子类把父类继承下来的虚方法表里面的方法进行覆盖了，这才叫重写</p><p>JDK9以后得私有方法</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312140951721.png" alt="image-20231214095112172"></p><p>私有方法不能被重写</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312140957403.png" alt="image-20231214095710778"></p><h3 id="接口应用"><a href="#接口应用" class="headerlink" title="接口应用"></a>接口应用</h3><p>跑步、游泳、说英语</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141004151.png" alt="image-20231214100426709"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141004747.png" alt="image-20231214100438560"></p><ul><li> 接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。</li><li> 当一个方法的参数是接口时，可以额传递接口所有实现类的对象，这种方式称之为接口多态</li></ul><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><p>设计模式是一套被反复使用，多数人知晓、经过分类边牧的、代码设计经验的总结</p><p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性、程序的重用性。</p><p>简单理解：设计模式就是各种套路</p><p>适配器设计模式：解决接口与接口实现类之间的矛盾问题</p><p>在实现类和接口之间添加了一个第三者，并且将其设定为abstract类型接口，所有的方法全部空实现</p><p>在实现类中只实现该接口，然后只使用method5即可。</p><p>Inter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.适配器模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method9</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method10</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的需求是我需要使用当前接口中的第五个抽象方法， 在实现类中，就需要将其余的抽象方法全部实现，完全没有必要。这时候引入一个适配器</p><p>InterAdapter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.适配器模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InterAdapter</span> <span class="keyword">implements</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method9</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method10</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在适配器中重写Inter中的全部方法，然后在真正需要使用的类中继承这个实现类重写method5即可。适配器中只是对接口的空实现，外界创建它的对象是没有意义的，因此将其设置为抽象类类型。</p><p>InterImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.适配器模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intermpl</span> <span class="keyword">extends</span> <span class="title">InterAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要用到哪个方法就重写哪个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个接口中抽象方法过多，但是我只需要使用其中的一部分的时候，就可以使用适配器模式。</p><h4 id="书写模式"><a href="#书写模式" class="headerlink" title="书写模式"></a>书写模式</h4><ul><li>编写中间类xxxAdapter，实现对应的接口</li><li>对接口中的抽象方法进行空实现</li><li>让真正的实现类继承中间类，并重写需要使用到的方法</li><li>为了避免其他类创建适配器类的对象，中间的适配器类需要使用abstract进行修饰</li><li>实现类如果有父类的话，可以让中间类继承其父类</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><p>类的五大成员</p><p>属性、方法、构造方法、代码块、内部类</p><p>在一个类里面，再定义一个类，在A类的内部定义B类，B类就被称为内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141027363.png" alt="image-20231214102744677"></p><p>为什么要学习内部类？</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141029508.png" alt="image-20231214102923712"></p><ul><li>内部表示的事物是外部类的一部分</li><li>内部类单独出现没有意义</li></ul><p>内部类的访问特点：</p><ul><li><strong>内部类可以直接访问外部类成员，包括私有</strong></li><li>外部类要访问内部类的成员，必须创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop内部类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="keyword">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        Engine e = <span class="keyword">new</span> Engine();</span><br><span class="line">        System.out.println(e.engineName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="keyword">int</span> engineAge;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(engineName);</span><br><span class="line">            System.out.println(carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类表示的事物是A类的一部分，且B单独存在没有意义</p><p>比如汽车发动机，ArrayList的迭代器，人的心脏等</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121937962.png" alt="image-20231214104142326"></p><p>内部类分类</p><ul><li>成员内部类（了解）</li><li>静态内部类（了解）</li><li>局部内部类（了解）</li><li>匿名内部类==（掌握）==</li></ul><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ol><li>成员内部类的代码如何写？</li><li>如何创建内部类对象</li><li>成员内部类如何获取外部类的成员变量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121937861.png" alt="image-20231214105317494"></p><p>获取内部类对象的方法</p><ul><li>在外部类中编写方法，对外提供内部类对象<ul><li>当内部类对象的修饰符为private的时候使用</li></ul></li><li>直接创建格式：外部类名.内部类名 = 对象名 = 外部类对象.内部类对象<ul><li>没有使用private修饰内部类对象的时候使用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop内部类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">//获取成员内部类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果修饰符被定为private，则可以在外部类中创建一个返回值类型为内部类的方法，该方法就是用来创建内部类的对象实例。然后在测试类中就可以使用getInstance()方法进行调用。或者直接修改其修饰符类型为public</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121937906.png" alt="image-20231214110306235"></p><p>内部类内存图</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121937213.png" alt="image-20231214141954339"></p><p>内部类对象中会记录外部类对象的地址值</p><p>对于下面的程序，想要打印30、20、10，应该如何实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop内部类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out2er</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">30</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在局部变量中的<code>a=10</code>，在内部类中的<code>a=20</code>，在外部类中的成员变量<code>a=10</code></p><p>如果想要输出30，直接打印a即可</p><p>如果想要输出20，就需要在前面加上this.a，因为this指向的是002地址对应的的对象，其中的a=20</p><p>如果想要输出10，就需要使用Outer.this.a，因为Outer.this指向的是外部类对象，其成员变量a=10</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141431524.png" alt="image-20231214143114508"></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122003700.png" alt="image-20231214143149167"></p><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象</p><p>注意事项：</p><ul><li>静态内部类也是成员内部类的一种</li><li>静态内部类只能访问外部类中的静态变量和静态方法</li></ul><p>创建静态内部类对象的格式：</p><p>外部类名.内部类名  对象名  =  new   外部类名.内部类名()</p><p>调用静态方法的格式：</p><p>外部类名.内部类名.方法名()</p><p><strong>类对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oopinterfacedemo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;非静态的方法被调用了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;《静态》的方法被调用了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oopinterfacedemo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        oi.show1();</span><br><span class="line"><span class="comment">//oi.show2();</span></span><br><span class="line">        Outer.Inner.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new的是外部类.内部类对象</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ol><li>将内部类定义在方法里面的就叫做局部内部类，类似于方法里面的局部变量</li><li>外界无法直接使用，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>隐藏名字的内部类</p><p>如果前面是类就是继承关系，如果前面是接口就是实现关系，之后需要在自己内部重写所有的抽象</p><p><strong>什么是匿名内部类？</strong></p><ul><li>隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置</li></ul><p><strong>匿名内部类的格式？</strong></p><ul><li><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122003365.png" alt="image-20231214152024714"></li></ul><p><strong>格式的细节？</strong></p><p>包含了继承或者实现，方法重写和创建对象</p><p>整体就是一个类的子类或者接口的实现类对象</p><p><strong>使用场景是什么？</strong></p><p>当方法的参数是接口或者类的时候，以接口为例，可以传递这个接口的实现类对象</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122003850.png" alt="image-20231214152223868"></p><h1 id="面向对象项目（拼图游戏）"><a href="#面向对象项目（拼图游戏）" class="headerlink" title="面向对象项目（拼图游戏）"></a>面向对象项目（拼图游戏）</h1><h1 id="Arrays常见API"><a href="#Arrays常见API" class="headerlink" title="Arrays常见API"></a>Arrays常见API</h1><ul><li>Arrays.sort() </li></ul><p>该方法默认是进行升序排序，传入一个数组即可。当然也可以进行降序排序，需要传入第二个参数表示规则</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>最明显的作用就是简化匿名内部类</p><p>例如进行在进行排序的时候，刚刚在进行升序排序的时候，可以用lambda表达式替代</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>Lambda表达式是JDK8开始后的一种新的语法形式</p><p>注意点：</p><ul><li>Lambda表达式可以用来简化匿名内部类的书写</li><li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li><li>函数式接口：<ul><li>有且仅有一个抽象方法的接口叫做<strong>函数式接口</strong>，接口上方可以加@Functionalface注解</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403092028503.png" alt="image-20240309202828284"></p><p>Lambda的省略规则：</p><ul><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时<code>()</code>也可以省略</li><li>如果Lambda表达式的方法体只有一行，大括号、分号、return可以省略不写</li></ul><h1 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h1><ul><li>集合体系结构</li><li>Collections集合</li></ul><h2 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h2><p>下面的部分中，斜体加粗为接口，正常的格式为实现类</p><ul><li>单列集合（**<em>Collection**</em>）<ul><li><strong><em>List</em></strong><ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li></ul></li><li><strong><em>Set</em></strong><ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>双列集合（Map）</li></ul><p>双列集合的特点：</p><ul><li>双列集合一次需要存一对数据，分别为键和值</li><li>键不能重复，值可以重复</li><li>键和值是一一对应的，每一个键只能找到自己对应的值</li><li>键+值这个整体，我们称之为”键值对“或者”键值对对象“，在Java中叫做”Entry“对象</li></ul><p><strong>List系列集合</strong>：添加的元素是有序【存和取的顺序是一样的】、可重复、有索引</p><p><strong>Set系列集合：</strong>添加的元素是无序、不重复（可以利用这个特点进行去重）、无索引</p><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都是可以继承使用的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403041602930.png" alt="image-20240304160209440"></p><p>注意：Collection是一个接口，我们不能直接创建它的对象，只能创建它的实现类的对象</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403041605622.png" alt="Java 集合框架概览"></p><p>实现类：ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、添加元素</span></span><br><span class="line"><span class="comment">// 细节1：如果我们要往List系列集合中添加数据，那么方法永远返回true，因为List系列是允许元素重复的</span></span><br><span class="line"><span class="comment">// 细节2：如果我们要往Set系列集合中添加数据，如果当前添加元素不存在，方法返回true，表示添加成功</span></span><br><span class="line"><span class="comment">//             如果当前要添加的元素已经存在，方法返回false，表示添加失败，因为Set系列的集合不允许重复。</span></span><br><span class="line">coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"><span class="comment">// 2、清空</span></span><br><span class="line"><span class="comment">// coll.clear();</span></span><br><span class="line"><span class="comment">// System.out.println(coll);</span></span><br><span class="line"><span class="comment">// 3、删除</span></span><br><span class="line">System.out.println(coll.remove(<span class="string">&quot;aaaa&quot;</span>));</span><br><span class="line">System.out.println(coll);</span><br></pre></td></tr></table></figure><h2 id="Collection的遍历方式"><a href="#Collection的遍历方式" class="headerlink" title="Collection的遍历方式"></a>Collection的遍历方式</h2><ul><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式遍历</li></ul><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403041622990.png" alt="image-20240304162213501"></p><p>五种遍历方式对比</p><ul><li><p>迭代器遍历</p><ul><li><p>在比那里的过程中需要删除元素，请使用迭代器。</p></li><li><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 列表迭代器</span><br><span class="line"></span><br><span class="line">  + 在遍历的过程中需要添加元素，请使用列表迭代器。</span><br><span class="line"></span><br><span class="line">  + &#96;&#96;&#96;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>增强for遍历</p><ul><li><p>仅仅想遍历，那么使用这个或者lambda都可以</p></li><li><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Lambda表达式</span><br><span class="line"></span><br><span class="line">  + &#96;&#96;&#96;java</span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>普通for</p><ul><li><p>如果遍历的时候想要操作索引，可以使用普通for</p></li><li><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实现类 | 数据结构</span><br><span class="line"></span><br><span class="line">## ArrayList源码分析</span><br><span class="line"></span><br><span class="line">ArrayList是一种有序的集合</span><br><span class="line"></span><br><span class="line">底层原理</span><br><span class="line"></span><br><span class="line">+ 利用空参创建的集合，Java会在底层创建一个默认长度为**0**的数组</span><br><span class="line">+ 添加第一个元素时，底层会创建一个新的长度为**10**的数组</span><br><span class="line">+ 存满时，会扩容**1.5**倍</span><br><span class="line">+ 如果一次添加多个元素，**1.5**倍放不下，则会创建新数组的长度以实际大小为准</span><br><span class="line"></span><br><span class="line">里面有个成员变量**size**，表示**元素个数**和**下一次元素存入的位置**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">oldCapacity &gt;&gt; 1 </span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="Map常见API"><a href="#Map常见API" class="headerlink" title="Map常见API"></a>Map常见API</h2><p>Map是双列集合的顶层接口，他的功能是全部双列集合都可以继承使用的</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403121944751.png" alt="image-20240312194407477"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072011358.png" alt="image-20240307201125322"></p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">V <strong>put</strong>(K key, V value)</td><td align="center">添加元素</td></tr><tr><td align="center">V <strong>remove</strong>(Object key)</td><td align="center">根据键删除键值对元素</td></tr><tr><td align="center">void <strong>clear</strong>()</td><td align="center">移除所有的键值对元素</td></tr><tr><td align="center">boolean <strong>containsKey</strong>(Object key)</td><td align="center">判断集合是否包含指定的键</td></tr><tr><td align="center">boolean <strong>containsValue</strong>(Object value)</td><td align="center">判断集合是否包含指定的值</td></tr><tr><td align="center">boolean <strong>isEmpty</strong>()</td><td align="center">判断集合是否为空</td></tr><tr><td align="center">int <strong>size</strong>()</td><td align="center">集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><p>在添加数据的时候，如果键不存在，则直接将键值对对象添加到map集合中；如果键是存在的，那么会把原有的键值对对象覆盖，会把覆盖的值进行返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">String put = map.put(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">System.out.println(put);</span><br><span class="line">map.put(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>例如上面的代码第一行输出的内容就是原本被覆盖的内容**”123”**</p><p><code>put</code>方法如果在进行覆盖的时候是有返回值的，返回值是被覆盖的元素值。如果是第一次存的时候，返回值为<code>null</code></p><h3 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h3><h4 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String put = map.put(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;222&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">System.out.println(put);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(map.get(&quot;111&quot;));</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用api</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V   get(Object key)</td><td>根据键获取值</td></tr><tr><td>Set<K>   keySet()</td><td>获取所有键的集合</td></tr><tr><td>Collection<V>   values()</td><td>获取所有值的集合</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;   entrySet()</td><td>获取所有键值对对象的集合</td></tr></tbody></table><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><p>其中最后一个方法返回值类型是一个包含键值对的对象，用<code>getKey()</code>获取键，用<code>getValue()</code>获取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>即forEach遍历</p><p>修改为lambda表达式之前先可以改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;鲁迅&quot;</span>, <span class="string">&quot;11111&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;222&quot;</span>, <span class="string">&quot;222222&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;333&quot;</span>, <span class="string">&quot;333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">&quot; = &quot;</span> + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中BiConsumer是一个函数式接口，满足修改为lambda表达式的要求</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap是一个散列表，它存储的内容是键值对（key-value）映射。</p><p>HashMap实现了Map接口，根据键的HashCode值存储数据，<strong>具有很快的访问速度</strong>，最多允许一条记录为null，不支持线程同步。</p><p>HashMap中的元素实际上是对象，一些常见的基本类型需要使用给他们所对应的包装类。</p><p>HashMap是无序的，不会记录插入的顺序</p><p>HashMap继承与AbstractMap，实现了Map、Cloneable、Java.io.Serializable</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051042989.png" alt="img"></p><p>HashMap的key与value类型可以相同也可以不同，可以是字符串（String）类型，也可以是整型（Integer）</p><h3 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h3><ul><li><p>HashMap是Map里面的一个实现类</p></li><li><p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了</p></li><li><p>特点都是由键决定的：无序、不重复、无索引</p></li><li><p>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构</p></li></ul><p>HashMap底层原理</p><p>底层是长度为<strong>16</strong>，默认加载因子为<strong>0.75</strong>的数组</p><p>利用键计算哈希值，跟值无关。</p><p>当链表的长度超过8 &amp; 数组长度&gt;=64，自动转成红黑树</p><p>HashMap底层是哈希表结构</p><p>依赖hashCode方法和equals方法保持键的唯一</p><p>如果键存储的是自定义对象，需要重写hashCode和equals方法</p><p>如果值存储的是自定义对象，不需要重写hashCode和equals方法</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122003821.png" alt="image-20240312195755389"></p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><ul><li>lambda</li><li>entrySet</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>需求：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122033961.png" alt="image-20240312200912775"></p><p>核心：HashMap的键位置如果存储的事自定义对象，需要重写hashCode和equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建HashMap对象</span></span><br><span class="line">        HashMap&lt;Student, String&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建三个学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;lsii&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;lsii&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.添加元素</span></span><br><span class="line">        hm.put(s1, <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        hm.put(s2, <span class="string">&quot;浙江&quot;</span>);</span><br><span class="line">        hm.put(s3, <span class="string">&quot;福建&quot;</span>);</span><br><span class="line">        hm.put(s3, <span class="string">&quot;山东&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; keys = hm.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Student key : keys) &#123;</span><br><span class="line">            String value = hm.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Student, String&gt; studentStringEntry : hm.entrySet()) &#123;</span><br><span class="line">            Student key = studentStringEntry.getKey();</span><br><span class="line">            String value = studentStringEntry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">        hm.forEach(</span><br><span class="line">                (student, s) -&gt; System.out.println(student + <span class="string">&quot; = &quot;</span> + s)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122034292.png" alt="image-20240312200921761"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个数组，存储四个经典</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 利用随机数模拟80个同学进行投票，并把投票的结果存储起来</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = r.nextInt(arr.length);</span><br><span class="line">            <span class="comment">// System.out.println(arr[index]);</span></span><br><span class="line">            list.add(arr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.containsKey(name)) &#123;</span><br><span class="line">                <span class="comment">// 先获取当前经典已经被投票的次数</span></span><br><span class="line">                <span class="keyword">int</span> count = hm.get(name);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 把新的次数在添加到集合中</span></span><br><span class="line">                hm.put(name, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不存在</span></span><br><span class="line">                hm.put(name, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hm.forEach((key, value) -&gt; System.out.println(key + &quot; = &quot; + value));</span></span><br><span class="line">        System.out.println(hm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hm.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                max = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断哪个景点和最大值一样</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (count == max) &#123;</span><br><span class="line">                System.out.println(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>特点：</p><ul><li><p><strong>由键决定：有序</strong>、不重复、无索引</p></li><li><p>这里的有序是指保证存储和取出的元素顺序一致</p></li><li><p>原理：底层数据结构是哈希表，只是每个键值对元素又额外多了一个双链表的机制记录存储的顺序</p></li></ul><p>数组+双向链表</p><p>LRU缓存–&gt;用Python实现过的代码也可以基于LinkedHashMap进行代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put()</code>方法有两个功能：</p><ul><li>添加</li><li>覆盖</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403122138353.png" alt="image-20240312213820871"></p><p>特点：</p><ul><li>TreeMap跟TreeSet底层原理一样，都是红黑树结构的。</li><li>由键决定特性：不重复、无索引、可排序</li><li>可排序：对键进行排序</li><li>注意默认按照键从小到大进行排序，也可以自己规定键的排序规则</li></ul><p>代码书写两种排序规则：</p><ul><li>实现Comparable接口，指定比较规则</li><li>创建集合时传递Comparator比较器对象，指定比较规则。【两个都写了会以第二种为准】</li></ul><h1 id="Java中数据结构总结"><a href="#Java中数据结构总结" class="headerlink" title="Java中数据结构总结"></a>Java中数据结构总结</h1><p><a href="https://www.runoob.com/java/java-data-structures.html">https://www.runoob.com/java/java-data-structures.html</a></p><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h3><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h2 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap"></a>TreeMap</h3><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查</p><p>泛型的格式：&lt;数据类型&gt;</p><p>注意：泛型只能支持引用数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>jdk5之前集合是可以存放任意类型的数据元素的，</p><p>多态的弊端是不能访问子类的特有功能</p><h2 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h2><ul><li>统一数据类型</li><li>把运行时期的问题提前到了编译使其，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来了。</li></ul><p>==Java中的泛型是伪泛型==</p><p>泛型的擦除</p><h2 id="泛型的细节"><a href="#泛型的细节" class="headerlink" title="泛型的细节"></a>泛型的细节</h2><ul><li>泛型中不能写基本数据类（只能写成其对应的包装类）</li><li>指定泛型的具体类型后，传递数据时，可以传入该类型或者其子类类型</li><li>如果不写泛型，类型默认是Object</li></ul><p>泛型可以在很多地方进行定义</p><ul><li>类后面<ul><li>泛型类</li></ul></li><li>方法上面<ul><li>泛型方法</li></ul></li><li>接口上面<ul><li>泛型接口</li></ul></li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>使用场景：当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>方法中形参类型不确定，可以使用类名后面定义的泛型<E></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403071542788.png" alt="image-20240307154226291"></p><p>方法中参数类型不确定时，</p><p>方案1：使用类名后面定义的泛型，所有方法都可以使用</p><p>方案2：在方法申明上定义自己的泛型，只有本方法能用，需要使用在修饰符的后面（注意是最后一个修饰符的后面）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;E&gt; list)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;E&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法中的类型是在调用方法的时候就确定了</p><h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><p>定义一个工具类：ListUtil</p><p>类中定义一个静态方法addAll，用来添加多个集合的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ListUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：集合</span></span><br><span class="line"><span class="comment">     * 参数二：要添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;E&gt; list, E... e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : e) &#123;</span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(ArrayList&lt;E&gt; list, E e1, E e2, E e3, E e4)</span> </span>&#123;</span><br><span class="line">        list.add(e1);</span><br><span class="line">        list.add(e2);</span><br><span class="line">        list.add(e3);</span><br><span class="line">        list.add(e4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayLIstDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListUtil.addAll(list,<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>格式：</p><p>修饰符 interface 接口名&lt;类型&gt; {</p><p>}</p><p>举例：</p><p>public interface List<E> {</p><p>}</p><p>重点：如何使用一个带泛型的接口</p><p>方式1：实现类给出具体类型</p><p>方式2：实现类延续泛型，创建对象时再确定</p><h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><ul><li>泛型不具备继承性，但是数据具备继承性</li><li></li></ul><p>利用泛型方法有一个小弊端，此时它可以接收任意的数据类型</p><p>但是我想要的是方法可以接收不确定的数据类型，但是希望只能传递Ye Fu Zi</p><p>此时就可以使用泛型的通配符 ？</p><p>它可以进行类型的限定</p><ul><li>? extends E：表示可以传递E或者E所有子类类型</li><li>? super E：表示可以传递E或者E所有父类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 泛型不具备继承性，但是数据具备继承性</span></span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2); <span class="comment">// 这个会报错  泛型不具备继承性</span></span><br><span class="line">        </span><br><span class="line">        list1.add(<span class="keyword">new</span> Ye());</span><br><span class="line">        list1.add(<span class="keyword">new</span> Fu()); <span class="comment">// 数据具备继承性</span></span><br><span class="line">        list1.add(<span class="keyword">new</span> Zi()); <span class="comment">// 数据具备继承性</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(ArrayList&lt;? extends Ye&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><ol><li>如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义<strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>泛型接口</strong>。</li><li>如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型通配符。</li></ol><p>关键点：可以限定类型的范围。</p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul><li><strong>可变参数在本质上就是一个数组</strong></li><li>作用：在形参中接收多个参数</li><li>格式：数据类型… 参数名称</li><li>举例说明：int… a</li></ul><p>注意事项：</p><ul><li><strong>在方法的形参中最多可以写一个可变参数</strong></li><li>在方法当中如果除了可变参数以外，还有其他形参，那么可变参数要写在最后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgsDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(getSum(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        System.out.println(arr); <span class="comment">// [I@1b6d3586 数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h1><p>Collections是集合工具类</p><p>常用API</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403182107749.png" alt="image-20240318210708519"></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>addAll</td><td>批量添加元素</td></tr><tr><td>shuffle</td><td>打乱List集合元素顺序</td></tr></tbody></table><p>集合嵌套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.集合;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 集合嵌套 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, ArrayList&lt;String&gt;&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; city1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(city1, <span class="string">&quot;南京市&quot;</span>, <span class="string">&quot;无锡市&quot;</span>, <span class="string">&quot;徐州市&quot;</span>, <span class="string">&quot;淮安市&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; city2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(city2, <span class="string">&quot;武汉市&quot;</span>, <span class="string">&quot;孝感市&quot;</span>, <span class="string">&quot;shiyan徐州市&quot;</span>, <span class="string">&quot;ezhou&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; city3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(city3, <span class="string">&quot;石家庄&quot;</span>, <span class="string">&quot;2222&quot;</span>, <span class="string">&quot;3333&quot;</span>, <span class="string">&quot;444&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hm.put(<span class="string">&quot;江苏省&quot;</span>, city1);</span><br><span class="line">        hm.put(<span class="string">&quot;湖北省&quot;</span>, city2);</span><br><span class="line">        hm.put(<span class="string">&quot;河北省&quot;</span>, city3);</span><br><span class="line"></span><br><span class="line">        hm.forEach((key, value) -&gt; &#123;</span><br><span class="line">            StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String s : value) &#123;</span><br><span class="line">                sj.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + sj);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合进阶-1"><a href="#集合进阶-1" class="headerlink" title="集合进阶"></a>集合进阶</h1><h2 id="创建不可变集合"><a href="#创建不可变集合" class="headerlink" title="创建不可变集合"></a>创建不可变集合</h2><p>不可变集合：不能被修改的集合？ <strong>tuple</strong>?</p><p>应用场景：</p><ul><li>如果某个数据不能被修改，将其放进不可变集合比较防御性；</li><li>当集合对象被不可信的库调用时，不可变形式是安全的。</li></ul><p>使用<code>.of()</code>方法可以直接创建一个不可变的集合，这一点可以用在不进行修改的集合的使用场景，如斗地主的牌数固定就可以使用这个方法进行创建。</p><h3 id="创建list不可变集合"><a href="#创建list不可变集合" class="headerlink" title="创建list不可变集合"></a>创建list不可变集合</h3><h3 id="创建Map不可变集合"><a href="#创建Map不可变集合" class="headerlink" title="创建Map不可变集合"></a>创建Map不可变集合</h3><p>细节：</p><ul><li>键不能重复</li><li>Map里面的of方法参数是有上限的，最多只能传递20个参数，<strong>即10个键值对</strong>？<ul><li>为什么会这样进行设计呢？</li><li>因为如果需要设计成可变长度的，那么键和值都需要这么设计，但是在Java中形参最多只能有一个可变参数所以无法进行这样设计，但是对于List和Set集合而言，就可以进行这样的设计了，因为他们不是键值对类型的</li><li>如果需要添加的键值对个数超过了10个，则可以使用<code>Map.ofEntries()</code>方法</li></ul></li></ul><p>Map集合中有一个方法<code>Map.copyOf()</code>，这个方法可以直接传递一个集合进去，但是该方法是jdk10之后才有的，所以如果版本低的话只能自己手动创建。</p><p>使用<code>Map.ofEntries()</code>方法自己手动创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">copyOf</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map <span class="keyword">instanceof</span> ImmutableCollections.AbstractImmutableMap) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map&lt;K,V&gt;)map;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map&lt;K,V&gt;)Map.ofEntries(map.entrySet().toArray(<span class="keyword">new</span> Entry[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 不可变集合<span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = Map.of(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;nanjing&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;beijing&quot;</span>, <span class="string">&quot;wnagwu&quot;</span>, <span class="string">&quot;tianjing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照下面的要求完成集合的创建和遍历</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - 创建一个集合，存储多个字符串元素</span></span><br><span class="line"><span class="comment">         * - 把集合中所有以&quot;张&quot;开头的元素存储到一个新的集合</span></span><br><span class="line"><span class="comment">         * - 把&quot;张&quot;开头的集合中的长度为3的元素存储到一个新的集合</span></span><br><span class="line"><span class="comment">         * - 遍历上一步得到的集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>));</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        list1.stream().filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="number">3</span>).forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stream流的作用：结合Lambda表达式，简化集合、数组的操作</p><p>使用步骤：</p><ul><li>先得到stream流，并把数据放上去</li><li>使用stream流中的API进行各种操作<ul><li>中间方法：过滤、转换，方法调用完毕后，还可以调用其他方法</li><li>终结方法：统计、打印，最后一步，调用完毕之后，不能调用其他方法</li></ul></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>先得到一条stream流，并把数据放上去</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403191325704.png" alt="image-20240319132550921"></p><h4 id="单列集合获取stream流"><a href="#单列集合获取stream流" class="headerlink" title="单列集合获取stream流"></a>单列集合获取stream流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单列集合获取Stream流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">// Stream&lt;String&gt; stream = list.stream();</span></span><br><span class="line">        <span class="comment">// stream.forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line">        <span class="comment">//     @Override</span></span><br><span class="line">        <span class="comment">//     public void accept(String s) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.println(s);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        list.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双列集合获取stream流"><a href="#双列集合获取stream流" class="headerlink" title="双列集合获取stream流"></a>双列集合获取stream流</h4><p>双列集合中是没有stream方法的，但是可以使用<code>keySet()</code>方法或者<code>entrySet()</code>方法之后再调用相应的stream流方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 双列集合获取Stream流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;aaa&quot;</span>, <span class="number">111</span>);</span><br><span class="line">        map.put(<span class="string">&quot;bbb&quot;</span>, <span class="number">222</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ccc&quot;</span>, <span class="number">333</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ddd&quot;</span>, <span class="number">444</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种获取Stream流的方法</span></span><br><span class="line">        map.keySet().stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种获取Stream流的方法</span></span><br><span class="line">        map.entrySet().stream().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="string">&quot; = &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以对于双列集合而言，总共有两种获取stream流的方法</p><h4 id="数组获取stream流方法"><a href="#数组获取stream流方法" class="headerlink" title="数组获取stream流方法"></a>数组获取stream流方法</h4><p>数组中默认也是没有获取stream流方法的，但是我们可以通过使用Arrays工具类中的stream流方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数组获取Stream流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.创建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取stream流</span></span><br><span class="line">        Arrays.stream(arr).forEach(a -&gt; System.out.println(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零散数据获取stream流方法"><a href="#零散数据获取stream流方法" class="headerlink" title="零散数据获取stream流方法"></a>零散数据获取stream流方法</h4><p>这里需要注意零散的数据类型必须都是相同的，不可以是不同的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 零散数据获取Stream流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">        Stream.of(<span class="string">&quot;1,2,3,4,5,6,7&quot;</span>,<span class="string">&quot;123123&quot;</span>,<span class="string">&quot;adads &quot;</span>).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>stream接口中静态方法of的细节</p><p>方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组</p><p>但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做成一个元素放到Stream流中</p><h3 id="stream流的中间方法"><a href="#stream流的中间方法" class="headerlink" title="stream流的中间方法"></a>stream流的中间方法</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403191354250.png" alt="image-20240319135408725"></p><p>注意1：中间方法返回新的stream流，<strong>原来的stream流只能使用一次</strong>，建议使用链式编程</p><p>注意2：修改stream流中的数据，不会影响原来的集合或者数组中的数据</p><ul><li><p>filter</p></li><li><p>limit</p></li></ul><p>这里括号中的参数就是表示几个的含义。所以下面这行代码就会打印list中的前三个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张良&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>skip</li></ul><p>跳过括号中个数的元素，下面这行代码将会跳过list中前四个元素，打印剩余的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip(<span class="number">4</span>).forEach(s-&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>练习：打印出张翠山、王二麻子、张良</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>distinct：元素去重，依赖hashCode和equals方法，<strong>如果需要使用自定义数据类型的时候，需要重写这两个方法</strong></li><li>concat：合并a和b两个流为一个流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王祖贤&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求1：取前4个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream().limit(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：跳过2个数据组成一个流</span></span><br><span class="line">        Stream&lt;String&gt; s2 = list.stream().skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求3：合并需求1和需求2得到的流，并把结果在控制台输出</span></span><br><span class="line"><span class="comment">//        Stream.concat(s1,s2).forEach(s-&gt; System.out.println(s));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复</span></span><br><span class="line">        Stream.concat(s1,s2).distinct().forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map： 转换流中的数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * map</span></span><br><span class="line"><span class="comment">         * 需求：获取字符串中的数值并打印输出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张无忌-20&quot;</span>,<span class="string">&quot;张无忌-30&quot;</span>,<span class="string">&quot;张无忌-40&quot;</span>,<span class="string">&quot;张无忌-50&quot;</span>,<span class="string">&quot;张无忌-60&quot;</span>,<span class="string">&quot;赵敏-10&quot;</span>);</span><br><span class="line">        <span class="comment">// Function的第一个类型：流中的原本类型；第二个数据类型：想要转换后的类型</span></span><br><span class="line">        list.stream().map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// apply方法的形参s表示流里面的每一个数据</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                String[] arr = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                String ageString = arr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> age = Integer.parseInt(ageString);</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).forEach(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stream流的终结方法"><a href="#stream流的终结方法" class="headerlink" title="stream流的终结方法"></a>stream流的终结方法</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403191518393.png" alt="image-20240319151817482"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * void   forEach(Consumer action)  遍历</span></span><br><span class="line"><span class="comment">         * long count()  统计</span></span><br><span class="line"><span class="comment">         * toArray()     收集流中的数据，放到数组中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream().forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count = list.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toArray()  收集流中的数据，放到数组中</span></span><br><span class="line"></span><br><span class="line">        Object[] objects = list.stream().toArray();</span><br><span class="line">        System.out.println(Arrays.toString(objects));</span><br><span class="line">        <span class="comment">//IntFunction的泛型：具体类型的数组</span></span><br><span class="line">        <span class="comment">//apply的形参：流中数据的个数，要跟数组的长度保持一致</span></span><br><span class="line">        <span class="comment">//apply的返回值：具体类型的数组</span></span><br><span class="line">        <span class="comment">//方法体：就是创建数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// toArray方法的参数的作用：负责创建一个指定类型的数组</span></span><br><span class="line">        <span class="comment">// toArray方法的底层，会依次得到流里面的每一个数字，并把数据放到数组当中</span></span><br><span class="line">        <span class="comment">// toArray方法的返回值：是一个装着流里面素有数据的数组</span></span><br><span class="line">        String[] strings = list.stream().toArray(<span class="keyword">new</span> IntFunction&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="keyword">int</span> value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line"></span><br><span class="line">        String[] strings1 = list.stream().toArray(value -&gt; <span class="keyword">new</span> String[value]);</span><br><span class="line">        System.out.println(Arrays.toString(strings1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合进阶;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jdi.Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span>流<span class="title">Demo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * collect(Collector collector)   收集六中的数据，放到集合中（List Set Map)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;0张无忌-男-15&quot;</span>, <span class="string">&quot;1张无忌-女-15&quot;</span>, <span class="string">&quot;2张无忌-男-15&quot;</span>, <span class="string">&quot;3张无忌-女-15&quot;</span>, <span class="string">&quot;4张无忌-男-15&quot;</span>, <span class="string">&quot;5张无忌-女-15&quot;</span>);</span><br><span class="line">        <span class="comment">// 收集List集合中 所有的男性数据</span></span><br><span class="line">        <span class="comment">// 这里在进行比较的时候，一般情况下会把确定数据放在前面，因为不确定的数据有可能会是null而导致空指针异常</span></span><br><span class="line">        list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])).forEach(s -&gt; System.out.println(s));</span><br><span class="line">        List&lt;String&gt; myList = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(myList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 收集到set集合当中</span></span><br><span class="line">        Set&lt;String&gt; mySet = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两者的区别就是使用set可以去重，而使用list无法去重</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 收集到map集合中</span></span><br><span class="line">        <span class="comment">// 谁作为键？ 谁作为值   本题的需求是 姓名和年龄分别作为键和值</span></span><br><span class="line">        Map&lt;String, Integer&gt; myMap = list.stream()</span><br><span class="line">                .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * toMap 参数一表示键的生成规则</span></span><br><span class="line"><span class="comment">                 *       参数二表示值的生成规则</span></span><br><span class="line"><span class="comment">                 * 参数一：</span></span><br><span class="line"><span class="comment">                 *      Function泛型一：表示流中每一个数据的类型</span></span><br><span class="line"><span class="comment">                 *              泛型二：表示Map集合中键的数据类型</span></span><br><span class="line"><span class="comment">                 *      方法apply形参：依次表示发流里面的每一个数据</span></span><br><span class="line"><span class="comment">                 *                   方法体：生成键的代码</span></span><br><span class="line"><span class="comment">                 *                   返回值：已生成得键</span></span><br><span class="line"><span class="comment">                 * 参数二：</span></span><br><span class="line"><span class="comment">                 *      Function泛型一：表示流中每一个数据的类型</span></span><br><span class="line"><span class="comment">                 *              泛型二：表示Map集合中值的数据类型</span></span><br><span class="line"><span class="comment">                 *      方法apply形参：依次表示发流里面的每一个数据</span></span><br><span class="line"><span class="comment">                 *                   方法体：生成值的代码</span></span><br><span class="line"><span class="comment">                 *                   返回值：已生成得值</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .collect(Collectors.toMap(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">                                              <span class="meta">@Override</span></span><br><span class="line">                                              <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                                                  <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                                              &#125;</span><br><span class="line">                                          &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;));</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        <span class="comment">// System.out.println(42 == 42.0);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式形式：&quot;</span>);</span><br><span class="line">        list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        s -&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">                )).forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; = &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要收集到Map集合当中，键是不能够重复的，要确保唯一性。</p><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403191723537.png" alt="image-20240319172326994"></p><p>stream流练习</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h1 id="多线程-amp-JUC"><a href="#多线程-amp-JUC" class="headerlink" title="多线程&amp;JUC"></a>多线程&amp;JUC</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012142898.png" alt="image-20240319205904028"></p><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统中能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><p>应用软件中互相独立，可以同时运行的功能</p><p>CPU处理速度和内存读写速度不匹配，这是进程调度的根本原因</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是程序的基本执行实体</p><p>任务管理器中可以查看到运行的软件就是一个进程</p><p>有了多线程，就可以让程序做多件事情</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403192150355.png" alt="image-20240319215044507"></p><h2 id="并发与并行-1"><a href="#并发与并行-1" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一时刻，多个指令在CPU上交替执行</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>在同一时刻，多个指令在多个CPU上同时执行</p><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><ul><li>继承Thread类的方式实现</li><li>实现Runnable接口的方式实现</li><li>利用Callable接口和Future接口方式实现</li></ul><h3 id="继承Thread类的方式实现"><a href="#继承Thread类的方式实现" class="headerlink" title="继承Thread类的方式实现"></a>继承Thread类的方式实现</h3><ol><li>首先编写一个多线程类继承自Thread类</li><li>在该类中重写<code>run()</code>方法，将需要多进程进行的任务写在方法体中</li><li>编写测试类，进行测试</li></ol><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 书写线程要执行的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; : Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo01.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多线程的第一种启动方式：</span></span><br><span class="line"><span class="comment">         *      1.自己定义一个类继承Thread</span></span><br><span class="line"><span class="comment">         *      2.重写run方法</span></span><br><span class="line"><span class="comment">         *      3.创建子类的对象，并启动线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口类"><a href="#实现Runnable接口类" class="headerlink" title="实现Runnable接口类"></a>实现Runnable接口类</h3><p><code>MyThread02.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 书写线程要执行的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; HelloWolrd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo02.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *    多线程的第二种启动方式：</span></span><br><span class="line"><span class="comment">         *    1.自己定义一个类实现Runnable接口</span></span><br><span class="line"><span class="comment">         *    2.重写里面的run方法</span></span><br><span class="line"><span class="comment">         *    3.创建自己类的对象</span></span><br><span class="line"><span class="comment">         *    4.创建一个Thread类的对象，并开启线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyThread02 mythread02 = <span class="keyword">new</span> MyThread02();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mythread02);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mythread02);</span><br><span class="line">        t1.setName(<span class="string">&quot;111线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;222线程1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用Callable接口和Future接口方式实现"><a href="#利用Callable接口和Future接口方式实现" class="headerlink" title="利用Callable接口和Future接口方式实现"></a>利用Callable接口和Future接口方式实现</h3><ul><li>   多线程的第三种实现方式</li><li>特点：可以获取到多线程运行的结果<ul><li>   创建一个类MyThread实现callable接口，此时需要指定泛型的类型</li><li>   重写call（是有返回值的，表示多线程运行的结果），需要指定跟刚刚一样的泛型类型</li><li>   创建MyThread对象（表示多线程要执行的任务）</li><li>   创建FutureTask对象（作用是管理多线程运行的结果）</li><li>   创建Thread类对象，并启动（表示线程）</li></ul></li></ul><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread03</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 求1-100之间的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo03.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *    多线程的第三种实现方式</span></span><br><span class="line"><span class="comment">         *    特点：可以获取到多线程运行的结果</span></span><br><span class="line"><span class="comment">         *    1.创建一个类MyCallable实现callable接口</span></span><br><span class="line"><span class="comment">         *    2.重写call（是有返回值的，表示多线程运行的结果）</span></span><br><span class="line"><span class="comment">         *    3.创建MyCallable对象（表示多线程要执行的任务）</span></span><br><span class="line"><span class="comment">         *    4.创建FutureTask对象（作用是管理多线程运行的结果）</span></span><br><span class="line"><span class="comment">         *    5.创建Thread类对象，并启动（表示线程）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyThread03 myThread03 = <span class="keyword">new</span> MyThread03();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread03);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到多线程的结果</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程三种实现方式对比"><a href="#多线程三种实现方式对比" class="headerlink" title="多线程三种实现方式对比"></a>多线程三种实现方式对比</h2><p>分成两类</p><ul><li>不可以获取多线程的结果<ul><li>继承Thread类</li><li>实现Runnable接口</li></ul></li><li>可以获取多线程的结果<ul><li>实现Callable接口</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201010008.png" alt="image-20240320101053706"></p><h2 id="多线程中的成员方法"><a href="#多线程中的成员方法" class="headerlink" title="多线程中的成员方法"></a>多线程中的成员方法</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201012336.png" alt="image-20240320101235797"></p><p>前四个方法的练习：</p><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a04threadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; @ &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadMethodDemo01.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a04threadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      String getName()</span></span><br><span class="line"><span class="comment">         *      void setName(String name)    设置线程的名字（构造方法也可以设置名字）</span></span><br><span class="line"><span class="comment">         *          1.如果我们没有给线程设置名字，线程也是有默认名字的，格式：Thread-X (X为序号，从0开始）</span></span><br><span class="line"><span class="comment">         *          2.如果我们要给线程设置名字，可以使用setName这个方法，也可以直接使用构造方法进行设置，需要在子类中super()父类的构造方法</span></span><br><span class="line"><span class="comment">         *      static Thread currentThread() 获取到当前进程对象</span></span><br><span class="line"><span class="comment">         *          细节：</span></span><br><span class="line"><span class="comment">         *              当JVM虚拟机启动之后，会自动的启动多条线程</span></span><br><span class="line"><span class="comment">         *              其中有一条线程就叫main线程</span></span><br><span class="line"><span class="comment">         *              它的作用就是去调用main方法并执行里面的代码</span></span><br><span class="line"><span class="comment">         *              所以之前我们写的所有的代码其实都是运行在main线程中的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      static void sleep(long time)    让线程休眠指定时间，单位为毫秒</span></span><br><span class="line"><span class="comment">         *      细节：</span></span><br><span class="line"><span class="comment">         *          1.哪条线程执行到这个方法，那么哪条线程就会在这里停留对应的时间</span></span><br><span class="line"><span class="comment">         *          2.方法的参数：就表示睡眠的时间，单位为毫秒</span></span><br><span class="line"><span class="comment">         *              1秒 = 1000毫秒</span></span><br><span class="line"><span class="comment">         *          3.当时间到了之后，线程就会自动醒来，继续执行下面的其他代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mt.start();</span><br><span class="line">        mt2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thread t = Thread.currentThread();</span></span><br><span class="line">        <span class="comment">// System.out.println(t.getName());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(&quot;111111111&quot;);</span></span><br><span class="line">        <span class="comment">// Thread.sleep(5000);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;222222222&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的优先级：最小是1，最大是10，默认是5，优先级越大，抢占到CPU的概率就会越大</p><p>守护线程：备胎线程</p><p>礼让线程</p><p>插入线程</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201041412.png" alt="image-20240320104150840"></p><p>线程的调度</p><ul><li>抢占式调度（随机性）</li></ul><p>线程的优先级：最小是1，最大是10，默认是5，优先级越大，抢占到CPU的概率就会越大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a05threadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a05threadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      setPriority(int newPriority)  设置线程的优先级</span></span><br><span class="line"><span class="comment">         *      final int getPriority()       获取线程的优先级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;坦克&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getPriority());</span><br><span class="line">        System.out.println(t2.getPriority());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>final void setDaemon(boolean on)</code> 设置为守护线程</p><ul><li><pre><code> 细节：当其他的非守护线程执行完毕之后，守护线程会陆续结束</code></pre></li><li><pre><code> 通俗易懂：当女神线程结束了，备胎线程也就没必要存在了</code></pre></li></ul><p><code>Thread1.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a06threadMethod3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;@&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread2.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a06threadMethod3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;@&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a06threadMethod3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      final void setDaemon(boolean on) 设置为守护线程</span></span><br><span class="line"><span class="comment">         *      细节：当其他的非守护线程执行完毕之后，守护线程会陆续结束</span></span><br><span class="line"><span class="comment">         *      通俗易懂：</span></span><br><span class="line"><span class="comment">         *          当女神线程结束了，备胎线程也就没必要存在了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MyThread1 t1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread2 t2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;女神&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;备胎&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把第二个线程设置为守护线程</span></span><br><span class="line">        t2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>对于聊天的线程，如果我们把他关闭了，那么传输文件的线程也就没必要存在了</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201120120.png" alt="image-20240320112034100"></p><h2 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h2><p><code>public static void yield()</code></p><p>出让CPU执行权之后，是有可能在抢夺到的，所以这个方法的作用是尽可能的让结果更加均匀，但是不一定能保证完全均匀。</p><h2 id="插入线程"><a href="#插入线程" class="headerlink" title="插入线程"></a>插入线程</h2><p>可以改变线程执行的顺序</p><p>例如在主线程中之前执行自己的线程</p><p>t.join()：表示把t这个线程，插入到当前线程之前。</p><p>下例中：</p><p>t：土豆线程</p><p>当前线程：main线程</p><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a08threadMethod5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;@&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a08threadMethod5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.setName(<span class="string">&quot;土豆&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中如果不加上<code>t.join()</code>的话，程序会先执行main线程的输出语句；但是如果我们需要改变线程执行顺序，先让土豆线程执行的话，就可以使用t.join()语句来改变线程的执行顺序。这个就是<strong>插入线程/插队线程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201259370.png" alt="image-20240320125942828"></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201314497.png" alt="image-20240320131430097"></p><ul><li>线程初始状态：NEW</li><li>线程运行状态：RUNNABLE</li><li>线程阻塞状态：BLOCKED</li><li>线程等待状态：WATTING</li><li>超时等待状态：TIMED_WATTING</li><li>线程终止状态：TERMINATED</li></ul><h2 id="线程安全性问题"><a href="#线程安全性问题" class="headerlink" title="线程安全性问题"></a>线程安全性问题</h2><p>需求：某个电影院正在上映国产大片， 共有100张票，有3个售票窗口，设计一个程序模拟电影院卖票</p><h3 id="卖票案例中的问题："><a href="#卖票案例中的问题：" class="headerlink" title="卖票案例中的问题："></a>卖票案例中的问题：</h3><ul><li>可能会存在卖300张票的情况，每个线程都卖了100张票<ul><li>在类中将ticket定义为<code>static</code>静态类型，这样这个类的所有实例化对象都共享一个数据</li></ul></li><li>使用static进行修改后，仍然会出现卖<strong>相同的重复票</strong>或者<strong>超卖</strong>的情况，因为可能在ticket++之后，cpu执行权就被其他线程夺走了，然后其他线程也ticket++，然后再输出</li><li>卖重复票的原因：CPU在执行的时候会有随机性</li><li>超卖的原因：CPU在执行的时候会有随机性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201359749.png" alt="image-20240320135954612"></p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>修改思路：操作共享数据的代码代码块如果能加锁，在当前执行的时候，其他线程只能进行等待</p><p>同步代码块：把操作共享数据的代码锁起来。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁)&#123;</span><br><span class="line">操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>锁默认打开，有一个线程进去了，锁自动关闭</li><li>里面的代码全部执行完毕，线程出来，锁自动打开</li></ul><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a09threadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象一定要是唯一的</span></span><br><span class="line">    <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加上static，表示这个类所有的对象，都共享ticket数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 卖票的代码逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;正在卖&quot;</span> + ticket + <span class="string">&quot;张票！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程.a09threadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 多线程.a09threadSafe.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;111窗口111&quot;</span>);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;222窗口222&quot;</span>);</span><br><span class="line">        MyThread t3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;333窗口333&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小细节："><a href="#小细节：" class="headerlink" title="小细节："></a>小细节：</h3><ul><li>synchronized不能放在循环的外面，否则线程1会将所有的票卖完</li><li>synchronized锁对象一定要是唯一的，</li></ul><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>就是把<code>synchronized</code>关键字加到方法上</p><p>格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403201443294.png" alt="image-20240320140936324"></p><p>同步静态方法的锁对象一般是对象的字节码 即<code>类名.class</code></p><p>利用同步方法完成</p><ul><li><pre><code> 技巧：先写同步代码块，在抽取成方法</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>在字符串中有StringBuilder和StringBuffer，这两者的所有方法都是一模一样的，唯一的区别就是在StringBuffer的所有方法的前面都加上了synchronized，也就是说StringBuffer是线程安全的，而StringBuilder是非线程安全的。</p><p>单线程：直接无脑只用StringBuilder</p><p>多线程：需要考虑数据安全性的前提下，使用StringBuffer</p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>JDK5之后提供了一个新的锁对象Lock，这样可以更清晰的表达如何加锁和释放锁。</p><p>Lock()中提供了获得锁和释放锁的方法</p><p>void lock()：获得锁</p><p>void unlock()：释放锁</p><p>手动上锁、手动释放锁</p><p>Lock是接口不能直接实例化，这里采用他的实现类<code>ReentrantLock</code>来实例化</p><p>ReentrantLock的构造方法</p><p>ReentrantLock()：创建一个ReentrantLock的实例</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012146538.png" alt="image-20240320144357289"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>写锁的时候不要让两个锁嵌套起来</p><p>​           </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="生产者消费者-等待唤醒机制"><a href="#生产者消费者-等待唤醒机制" class="headerlink" title="生产者消费者|等待唤醒机制"></a>生产者消费者|等待唤醒机制</h2><p>生产者消费者模型师一个十分经典的多线程协作的模式</p><p>wait()</p><p>notify()</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211414527.png" alt="image-20240321141446981"></p><p>wait()当前线程等待，直到被其他线程唤醒</p><p>notify() 随机唤醒单个线程</p><p>notifyAll() 唤醒所有线程</p><p>消费者等待</p><h2 id="阻塞队列实现等待唤醒机制"><a href="#阻塞队列实现等待唤醒机制" class="headerlink" title="阻塞队列实现等待唤醒机制"></a>阻塞队列实现等待唤醒机制</h2><p>put数据时：放不进去，会等着，也叫做阻塞</p><p>take数据时：取出第一个数据，取不到会等着，也叫做阻塞。</p><p>阻塞队列的继承结构</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211505591.png" alt="image-20240321150515479"></p><h2 id="多线程的六种状态"><a href="#多线程的六种状态" class="headerlink" title="多线程的六种状态"></a>多线程的六种状态</h2><p>Java虚拟机中是没有定义运行状态的。因为当线程抢到CPU执行权的时候，Java虚拟机就将当前线程交给操作系统进行管理，虚拟机不管就不进行定义了。</p><p>类比：手机被偷了，后续手机坏了需要维修就与你无关了。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211526157.png" alt="image-20240321152622986"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211525918.png" alt="image-20240321152552399"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211525417.png" alt="image-20240321152457751"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是有上限的</p><h3 id="线程池的核心原理"><a href="#线程池的核心原理" class="headerlink" title="线程池的核心原理"></a>线程池的核心原理</h3><ul><li><p>创建一个池子，池子是空的</p></li><li><p>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下次再提交任务时，不需要创建新的线程，直线复用已有的线程即可。</p></li><li><p>如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</p></li></ul><h3 id="线程池代码实现"><a href="#线程池代码实现" class="headerlink" title="线程池代码实现"></a>线程池代码实现</h3><ul><li>创建线程池</li><li>提交任务</li><li>所有的任务全部执行完毕，关闭线程池【<strong>实际开发中一般不会关闭的</strong>，服务器是24小时不关】</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403231434323.png" alt="线程池代码实现"></p><p>第一个说是没有上限的线程池，实际上是是<code>int</code>的最大值2的31次方，21亿多</p><p><strong><em>public static ExecutorService newCachedThreadPool()</em></strong>    创建没有上限的线程池</p><p><strong><em>public static ExecutorService newFixedThreadPool(int nThreads)</em></strong>    创建有上限的线程池</p><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程_线程池;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyThreadDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程_线程池;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取线程池对象</span></span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  创建自定义线程池</span></span><br><span class="line"><span class="comment"> *  ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor</span></span><br><span class="line"><span class="comment"> *  参数一：核心线程数量，不能小于0</span></span><br><span class="line"><span class="comment"> *  参数二：最大线程数量，不能小于0，最大数量&gt;=核心线程数量</span></span><br><span class="line"><span class="comment"> *  参数三：空闲线程最大存活时间，不能小于0</span></span><br><span class="line"><span class="comment"> *  参数四：时间单位，用TimeUnit指定</span></span><br><span class="line"><span class="comment"> *  参数五：任务队列，不能为null</span></span><br><span class="line"><span class="comment"> *  参数六：创建线程工厂，不能为null</span></span><br><span class="line"><span class="comment"> *  参数七：任务的拒绝策略，不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="number">60</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), <span class="comment">//任务队列</span></span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">// 任务的拒绝策略</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里为什么定义拒绝策略为内部类？</span></span><br><span class="line"><span class="comment">         * 内部类是依赖外部类存在的，但是单独出现是没有任何意义的，并且内部类的本身又是一个独立的个体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>内部类：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012147515.png" alt="image-20240323133528823"></p><p>自定义线程池的工作原理</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012147520.png" alt="image-20240323134742179">+</p><ul><li>当核心线程满时，再提交任务就会排队</li><li>当核心线程满，队列也满了，就会创先临时线程（非核心线程）</li><li>当核心线程、队列和临时线程（非核心线程）都满了，就会触发任务拒绝策略。</li></ul><p>核心线程和临时线程</p><p>只有在核心线程都被用完了并且队列长度已经排满了才会启动非核心线程（临时线程） </p><p>自定义线程池（任务拒绝策略）</p><h3 id="线程池多大比较合适？"><a href="#线程池多大比较合适？" class="headerlink" title="线程池多大比较合适？"></a>线程池多大比较合适？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403281329342.png" alt="image-20240323140910215"></p><p>最大并行数：</p><p>4核8线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>查看最大核心线程 为8</p><ul><li>CPU密集型运算</li></ul><p>计算比较多，读取数据库IO比较少属于这种类型，<strong>最大并行数+1</strong>，+1的原因是保障当前项目因为页缺失故障或其他故障导致线程暂停，这个额外的线程就可以顶上去，保证CPU时钟周期不被浪费</p><ul><li>IO密集型运算</li></ul><p>操作数据库、RPC、IO操作的时候，CPU闲置下来</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403281329940.png" alt="image-20240323141846680"></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常体系介绍</p><p>java.lang.Throwable</p><ul><li>Error</li><li>Exception<ul><li>RuntimeException</li><li>其他异常</li></ul></li></ul><p>Exception：叫做异常，代表程序可能出现的问题</p><p>运行时异常：RuntimeError及其子类，编译阶段不会出现异常题型。运行时出现的异常（如数组索引越界异常）</p><p>编译时异常：编译阶段就会出现异常提醒的</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403281335772.png" alt="image-20240328133556336"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射允许对封装类的字段、方法和构造方法的信息进行编程访问</p><p>例如idea自动提示一个类中有哪些方法，或者方法括号中的形参参数类型是哪些？</p><p>通俗的话讲，反射就是可以从类中拿东西</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403281329137.png" alt="image-20240323143357686"></p><p>为什么要有反射？</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403281331008.png" alt="image-20240323144742904"></p><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p>静态初始化块，在类加载时执行，用于初始化静态成员变量或执行一些静态操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;1.94.65.33&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式</p><p> <code>JedisConnectionFactory</code> 类中的 <code>jedisPool</code> 属性被声明为 <code>static</code>，并在<strong>【静态代码块】</strong>的静态初始化块中初始化。这样做确保了在整个应用程序生命周期中只有一个 Jedis 连接池实例。</p><p>工厂模式</p><p>类中的getJedis()方法充当了工厂方法，用于创建Jedis对象。它封装了Jedis连接池的创建和配置细节，并提供了一个统一的接口来获取Jedis对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础（黑马）&quot;&gt;&lt;a href=&quot;#Java基础（黑马）&quot; class=&quot;headerlink&quot; title=&quot;Java基础（黑马）&quot;&gt;&lt;/a&gt;Java基础（黑马）&lt;/h1&gt;&lt;p&gt;提示忽略大小写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.j</summary>
      
    
    
    
    
    <category term="Java" scheme="https://guoxiansen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="https://guoxiansen.github.io/2024/03/11/LRU%E7%AE%97%E6%B3%95/"/>
    <id>https://guoxiansen.github.io/2024/03/11/LRU%E7%AE%97%E6%B3%95/</id>
    <published>2024-03-11T07:57:35.000Z</published>
    <updated>2024-03-12T02:10:16.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403111815278.png" alt="力扣LRU算法"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>LRU（Leasted Recently Used）缓存机制可以通过<strong>哈希表</strong>和辅助<strong>双向链表</strong>实现</p><ul><li>双向链表按照被使用的顺序存储了键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li><li>哈希表存储数据的键映射到其在双向链表中的位置。</li></ul><p>逻辑：</p><p>针对<code>get</code>操作：</p><ul><li>先判断哈希表cache中是否存在该key<ul><li>如果不存在则直接返回-1</li><li>如果存在，则将通过哈希表找到对应的结点并将该结点删除（<code>removeNode</code>）并在开头添加一个结点(（<code>addToHead</code>)，其中删除和添加操作只需要修改指针，因此时间复杂度为O(1)满足题目要求</li></ul></li></ul><p>针对<code>put</code>操作：</p><ul><li>判断哈希表cache中是否存在该key<ul><li>如果不存在该key则<ul><li>先以该key、value为键值对构建一个双向链表node</li><li>将该结点node添加到链表的开头（<code>addToHead</code>)</li><li>然后在哈希表中添加键key和值node</li><li>将self.size+1，并判断当前size大小是否超过capacity</li><li>如果没有超过则不进行任何操作</li><li>如果超过了，则需要进行淘汰，将双线链表的末尾的结点删除并将其对应的key从哈希表中删除</li></ul></li><li>如果存在该key<ul><li>则从哈希表cache中获取该key所对应的结点node</li><li>然后将node的value更新为最新的</li><li>然后将node结点移动到链表的最开头（<code>moveToHead</code>）</li></ul></li></ul></li></ul><h3 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key=<span class="number">0</span>,value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h3><p>哈希表的实现在Python中使用数组即可，需要注意，头尾节点的都是一个虚拟虚拟的伪结点，他们的中间才是真正的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 使用伪头结点和伪尾节点</span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key=<span class="number">0</span>,value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 使用伪头结点和伪尾节点</span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.cache[key] <span class="comment"># 通过哈希表找到node的位置</span></span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = DLinkedNode(key,value)</span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 缓存中有值 更新到最前面</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node <span class="comment"># 原本的第一个结点</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><p>链表的几个操作说明：</p><ul><li><p><code>addToHead(node)</code>：将node添加到双向链表的开头</p></li><li><p><code>moveToHead(node)</code>：将node结点移动到双向链表的开头（本质上是删除<code>removeNode</code>+添加<code>addToHead</code>）</p></li><li><p><code>removeNode(node)</code>：就node结点从双向链表中删除</p></li><li><p><code>removeTail()</code>：删除双向链表的最后一个结点并返回该结点</p></li></ul><h1 id="补充OrderDict"><a href="#补充OrderDict" class="headerlink" title="补充OrderDict"></a>补充OrderDict</h1><p>在Python中的collections中，有一个有序字典完美契合本题的要求，即<code>collections.OrderDict</code></p><p>特有方法：</p><ul><li><p><code>popitem(last=True)</code></p><ul><li>参数默认为True表示移除有序字典中的最后一个元素；如果参数为False则表示移除第一个元素；</li></ul></li><li><p><code>move_to_end(key,last=True)</code></p><ul><li>参数1为需要移动的关键字key</li><li>参数2为布尔值，默认为True，表示移动到末尾；如果为False的情况下，则表示移动到开头</li></ul></li></ul><p>使用该方法实现的代码：</p><p>让该类继承自collections.OrderedDict，然后就可以使用<code>move_to_end()</code>和<code>popitem()</code>两个方法了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params">collections.OrderedDict</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LRU算法&quot;&gt;&lt;a href=&quot;#LRU算法&quot; class=&quot;headerlink&quot; title=&quot;LRU算法&quot;&gt;&lt;/a&gt;LRU算法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@m</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="LRU" scheme="https://guoxiansen.github.io/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://guoxiansen.github.io/2024/03/08/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://guoxiansen.github.io/2024/03/08/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2024-03-08T09:25:40.000Z</published>
    <updated>2024-03-13T05:37:45.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>用途：用于快速判断一个元素是否出现在集合里</p><p>可以做到<code>O(1)</code>的时间复杂度</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>将两个元素都映射到索引相同的位置，这一现象叫做哈希碰撞。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>拉链法</li><li>线性探测法</li></ul><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="242、有效的字母异位词"><a href="#242、有效的字母异位词" class="headerlink" title="242、有效的字母异位词"></a>242、有效的字母异位词</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403081846195.png" alt="image-20240308184644623"></p><p>Python便捷解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="keyword">return</span> Counter(s)==Counter(t)</span><br></pre></td></tr></table></figure><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        set1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        set2 = <span class="built_in">set</span>(nums2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(set1&amp;set2)</span><br></pre></td></tr></table></figure><h2 id="202、快乐数"><a href="#202、快乐数" class="headerlink" title="202、快乐数"></a>202、快乐数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getnum</span>(<span class="params">n</span>):</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                n,r = <span class="built_in">divmod</span>(n,<span class="number">10</span>)</span><br><span class="line">                res+=r**<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        record = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = getnum(n)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record.add(n)     </span><br></pre></td></tr></table></figure><h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403131334178.png" alt="image-20240313133422160"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> myhash:</span><br><span class="line">                <span class="keyword">return</span> [index, myhash[target-num]]</span><br><span class="line">            myhash[num] = index</span><br></pre></td></tr></table></figure><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><p>方法1：使用哈希表</p><p>将三数之和问题转换为两数之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            myhash = &#123;&#125;</span><br><span class="line">            <span class="comment"># target = -nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> -nums[i]-nums[j] <span class="keyword">in</span> myhash:</span><br><span class="line">                    tmp = [nums[i],nums[j],myhash[-nums[i]-nums[j]]]</span><br><span class="line">                    <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(tmp)</span><br><span class="line">                myhash[nums[j]] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题新加了测试用例，该方法无法完全AC</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403131331172.png" alt="image-20240313133122928"></p><p>方法2：使用双指针</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;用途：用于快速判断一个元素是否出现在集合里&lt;/p&gt;
&lt;p&gt;可以做到&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="哈希表" scheme="https://guoxiansen.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>常见设计模式总结</title>
    <link href="https://guoxiansen.github.io/2024/03/08/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://guoxiansen.github.io/2024/03/08/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-03-08T02:05:59.000Z</published>
    <updated>2024-03-08T02:06:32.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式总结"><a href="#常见设计模式总结" class="headerlink" title="常见设计模式总结"></a>常见设计模式总结</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见设计模式总结&quot;&gt;&lt;a href=&quot;#常见设计模式总结&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式总结&quot;&gt;&lt;/a&gt;常见设计模式总结&lt;/h1&gt;&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://guoxiansen.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表相关知识</title>
    <link href="https://guoxiansen.github.io/2024/03/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://guoxiansen.github.io/2024/03/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2024-03-05T07:12:53.000Z</published>
    <updated>2024-03-14T03:04:33.560Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051513674.png" alt="image-20240305151347049"></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表是一种通过指针串联在一起的数据结构，每个节点由两个部分组成，一个是数据域，一个是指针域（存放指向下一个地址的指针），最后一个节点的指针域为空NULL。</p><p>链表的入口节点被称为链表的头结点，即head</p><p>首先定义单个结点的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>单个结点中，包含了一个结点值和下一个结点的指针域</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index = <span class="built_in">max</span>(<span class="number">0</span>, index)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.<span class="built_in">next</span> = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = to_add</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = pred.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h2 id="链表的代码定义"><a href="#链表的代码定义" class="headerlink" title="链表的代码定义"></a>链表的代码定义</h2><p>Java版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>链表的基本操作：</p><ul><li>获取链表的第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表的第index个节点前面插入一个节点</li><li>删除链表的第index个节点的数值</li></ul><h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><h2 id="203、移除链表元素"><a href="#203、移除链表元素" class="headerlink" title="203、移除链表元素"></a>203、移除链表元素</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051732870.png" alt="image-20240305173157403"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: Optional[ListNode], val: <span class="built_in">int</span></span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val==val:</span><br><span class="line">                p.<span class="built_in">next</span>=p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val==val)&#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="707、设计链表"><a href="#707、设计链表" class="headerlink" title="707、设计链表"></a>707、设计链表</h2><h2 id="206、反转链表"><a href="#206、反转链表" class="headerlink" title="206、反转链表"></a>206、反转链表</h2><p>本题如果重新定义一个新的链表会浪费存储空间，最好的思路是直接在链表本身上进行操作。</p><h3 id="思路1：头插法"><a href="#思路1：头插法" class="headerlink" title="思路1：头插法"></a>思路1：头插法</h3><p>需要先进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="comment"># 头插法</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = dummy.<span class="built_in">next</span></span><br><span class="line">            dummy.<span class="built_in">next</span> = p</span><br><span class="line">            p = tmp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>            </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403052153478.png" alt="image-20240305215248567"></p><p>java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = node.next;</span><br><span class="line">            node.next = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2：双指针"><a href="#思路2：双指针" class="headerlink" title="思路2：双指针"></a>思路2：双指针</h3><p>从头往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = p</span><br><span class="line">            p = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="92、反转链表II"><a href="#92、反转链表II" class="headerlink" title="92、反转链表II"></a>92、反转链表II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061326745.png" alt="image-20240306132653417"></p><p>本题和上一题的区别就在给定了需要反转的返回left到right</p><p>第一次尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: Optional[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="comment"># 记录left到right之间的位置 然后将其逆序再反转</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        p = dummy</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录1/2/3号节点位置</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> flag==left-<span class="number">1</span>:</span><br><span class="line">                cur_1 = p</span><br><span class="line">                cur_2 = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> flag==right:</span><br><span class="line">                cur_3 = p.<span class="built_in">next</span></span><br><span class="line">                p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">        dummy2 = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = cur_2</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            tmp = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">            dummy2.<span class="built_in">next</span> = p</span><br><span class="line">            p = tmp</span><br><span class="line">        <span class="comment"># print(&quot;cur_2:&quot;,cur_2)</span></span><br><span class="line">        <span class="comment"># print(&quot;dummy2:&quot;,dummy2)</span></span><br><span class="line">        cur_1.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span></span><br><span class="line">        cur_2.<span class="built_in">next</span> = cur_3</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>在上面的过程中，遍历的时候有所重复，因此我们可以尝试只进行一次遍历节省时间开销</p><p>我们首先遍历到<code>left</code>前一个节点的位置，然后当前的<code>p</code>指针指向的就是该节点，然后继续从<code>p.next</code>开始进行遍历【left-right+1】次，同时记录下当前一开始的位置<code>tail</code>（这个位置会在最后变成第二段的最后一个节点），然后循环结束之后进行三段拼接，得到最终调整好位置的链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: Optional[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="comment"># 记录left到right之间的位置 然后将其逆序再反转</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># p现在指向第一个中断点</span></span><br><span class="line">        cur = p.<span class="built_in">next</span></span><br><span class="line">        tail = cur</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left+<span class="number">1</span>):</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur <span class="comment"># 头指针，每次都指向新插入的节点</span></span><br><span class="line">            cur = tmp</span><br><span class="line">        p.<span class="built_in">next</span> = prev</span><br><span class="line">        tail.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061443327.png" alt="image-20240306144328323"></p><h2 id="234、回文链表"><a href="#234、回文链表" class="headerlink" title="234、回文链表"></a>234、回文链表</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403052205786.png" alt="image-20240305220500692"></p><p>思路：遍历一遍链表，然后使用双指针判断是否是回文的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; bool:</span></span><br><span class="line">        p = head</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res.append(p.val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res==res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="24、两两交换链表中的节点"><a href="#24、两两交换链表中的节点" class="headerlink" title="24、两两交换链表中的节点"></a>24、两两交换链表中的节点</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061605617.png" alt="image-20240306160543620"></p><p>思路就是直接修改指针</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061606291.png" alt="24.两两交换链表中的节点1"></p><p>然后指针每次前进两个到下一个需要进行逆序交换的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            temp = p.<span class="built_in">next</span></span><br><span class="line">            temp1 = p.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = temp</span><br><span class="line">            temp.<span class="built_in">next</span> = temp1</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="19、删除链表的倒数第N个节点（-）"><a href="#19、删除链表的倒数第N个节点（-）" class="headerlink" title="19、删除链表的倒数第N个节点（*）"></a>19、删除链表的倒数第N个节点（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061624508.png" alt="image-20240306162457715"></p><p>方法一：一次遍历+再次回头</p><p>利用哈希表存储链表，然后直接取哈希表中的链表进行操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: Optional[ListNode], n: <span class="built_in">int</span></span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        p = dummy</span><br><span class="line">        tag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            myhash[tag] = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            tag += <span class="number">1</span></span><br><span class="line">        <span class="comment"># tag和n的关系 利用myhash</span></span><br><span class="line">        <span class="comment"># print(tag-n)</span></span><br><span class="line">        <span class="keyword">if</span> tag-n==<span class="number">1</span> <span class="keyword">and</span> tag==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> myhash[tag-<span class="number">1</span>].<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            myhash[tag-n-<span class="number">1</span>].<span class="built_in">next</span> = myhash[tag-n-<span class="number">1</span>].<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>方法二：一次遍历</p><p>利用快慢指针来解决，<code>fast</code>指针多走<code>n+1</code>步，然后在没有到达末尾的情况下，<code>slow</code>和<code>fast</code>全部前进</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: Optional[ListNode], n: <span class="built_in">int</span></span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        slow = fast = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403061958926.png" alt="image-20240306195823473"></p><h2 id="160、链表相交"><a href="#160、链表相交" class="headerlink" title="160、链表相交"></a>160、链表相交</h2><p>利用哈希表来解决问题</p><p>这个方法的情况下时间空间复杂度都是O(n)级别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        p1 = headA</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            myhash[p1] = p1</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">        p2 = headB</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p2 <span class="keyword">in</span> myhash:</span><br><span class="line">                <span class="keyword">return</span> p2</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Java版本代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;ListNode,ListNode&gt; myhash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode p = headA;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            myhash.put(p,p);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (myhash.containsKey(p1)==<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="141、环形链表"><a href="#141、环形链表" class="headerlink" title="141、环形链表"></a>141、环形链表</h2><p>使用快慢指针进行判断</p><p>slow指针为慢指针，每次只走一步</p><p>fast指针为快指针，每次走两步</p><p>通过while循环，如果两个指针相遇了，说明链表中存在环，如果两个指针始终没有相遇并且fast指针到达链表的末尾了，即说明链表中不存在环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow!=fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="142、环形链表II"><a href="#142、环形链表II" class="headerlink" title="142、环形链表II"></a>142、环形链表II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403062104194.png" alt="image-20240306210409994"></p><p>哈希表解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> myhash:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            myhash[p] = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>        </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        HashMap&lt;ListNode,ListNode&gt; myhash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (myhash.containsKey(p))&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            myhash.put(p,p);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针法：</p><h2 id="83、删除排序链表中的重复值"><a href="#83、删除排序链表中的重复值" class="headerlink" title="83、删除排序链表中的重复值"></a>83、删除排序链表中的重复值</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403081444760.png" alt="image-20240308144411298"></p><p>本题中需要注意的是删除链表中重复元素并保留一位即可，因此不需要像82题那样在while循环中再加一个while循环来将所有的值全部删除。</p><p>注意本题中也是一样的，只有在当前结点值和下一个结点值不相等的情况下才需要移动指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummy = ListNode(<span class="number">101</span>, head)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val == p.<span class="built_in">next</span>.val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="82、删除排序链表中的重复元素II（-）"><a href="#82、删除排序链表中的重复元素II（-）" class="headerlink" title="82、删除排序链表中的重复元素II（*）"></a>82、删除排序链表中的重复元素II（*）</h2><p><img src="./images/image-20240308142819040.png" alt="image-20240308142819040"></p><p>哈希表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        dummy = ListNode(<span class="number">101</span>,head)</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            myhash[p.val] = myhash.get(p.val,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> myhash[p.val]&gt;<span class="number">1</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br></pre></td></tr></table></figure><p>一次遍历</p><p>注意，本题中只有<code>p.next.val</code>和<code>p.next.next.val</code>不相等的情况下，才需要移动p的指针（即在else中去移动p指针），否则就会出现的删除了前面的重复的元素，但是紧跟着的重复元素就不删除的情况，这样的写法如果测试用例中只有一处重复的元素，则不会报错。<strong>p指针只有在遇到不重复的指针的时候才进行移动。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">101</span>,head)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val == p.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                x = p.<span class="built_in">next</span>.val</span><br><span class="line">                <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.val==x:</span><br><span class="line">                    p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403141000558.png" alt="image-20240314100022897"></p><p>Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val==p.next.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.next.val;</span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.val==x)&#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051513674.png&quot; alt=&quot;image-20240305151347049&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;链表&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="链表" scheme="https://guoxiansen.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList底层源码分析</title>
    <link href="https://guoxiansen.github.io/2024/03/05/LinkedList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/05/LinkedList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-03-05T06:36:39.000Z</published>
    <updated>2024-03-07T12:02:50.788Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051438291.png" alt="image-20240305143822757"></p><h1 id="LinkedList底层源码分析"><a href="#LinkedList底层源码分析" class="headerlink" title="LinkedList底层源码分析"></a>LinkedList底层源码分析</h1><h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p>底层数据结构是双链表，查询慢，增删快，但如果操作的是首尾元素，速度也是极快的。</p><p>特有的API</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051441510.png" alt="image-20240305144059020"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>LinkedList底层是双向链表结构</p><p>节点对象<code>Node</code>的定义如下</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072002857.png" alt="image-20240306212711892"></p><p>核心步骤如下：</p><ol><li>刚开始创建的时候，底层创建了两个变量：一个记录头结点<code>first</code>，一个记录尾结点<code>last</code>，默认都为null</li><li>添加第一个元素时候，底层创建一个结点对象，<code>first</code>和<code>last</code>都记录这个结点的地址值</li><li>添加第二个元素时候，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，<code>last</code>会记录新结点的地址值。</li></ol><p>源代码流程：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072002368.png" alt="LinkedList源码分析"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051438291.png&quot; alt=&quot;image-20240305143822757&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Linked</summary>
      
    
    
    
    
    <category term="Java" scheme="https://guoxiansen.github.io/tags/Java/"/>
    
    <category term="源码" scheme="https://guoxiansen.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList底层源码分析</title>
    <link href="https://guoxiansen.github.io/2024/03/05/ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/05/ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-03-05T05:47:28.000Z</published>
    <updated>2024-03-25T06:14:38.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList底层源码分析"><a href="#ArrayList底层源码分析" class="headerlink" title="ArrayList底层源码分析"></a>ArrayList底层源码分析</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051435119.png" alt="image-20240305143529677"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul><li><p>创建使用ArrayList&lt;&gt;()创建空对象的时候，会在底层创建一个长度为0的数组。该数组的名称为<code>elementData</code>，定义变量<code>size</code></p><ul><li><code>size</code>变量有两层含义<ul><li>① 表示元素的个数，也就是集合的长度</li><li>② 表示下一个元素的存入位置</li></ul></li></ul></li></ul><ul><li>添加第一个元素之后，size++，同时底层会创建一个新的长度为<code>DEFAULT_CAPACITY</code>=10的数组</li><li>扩容机制1：<ul><li>当存满的时候，会创建一个新的数组，新数组的长度是原来的1.5倍，也就是长度为15。再把所有的元素拷贝到新数组中。如果继续添加数据，这个长度为15的数组也满了，那就会继续按照相同的方式扩容1.5倍。</li></ul></li><li>扩容时机2：<ul><li>当使用例如<code>addAll()</code>这样的方法一次性添加多个数据，扩容1.5倍的方法不够用时，则以扩容的实际大小为准。</li></ul></li></ul><p>  成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造器，最开始创建的是空数组，当添加第一个元素时初始化容量为10。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化容量，为0的话则创建空数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">   initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个集合，将该集合中的元素存到ArrayList中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">Object[] a = c.toArray();</span><br><span class="line"><span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">elementData = a;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// replace with empty array.</span></span><br><span class="line">elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add方法</p><ul><li>add(E e)：直接在ArrayList尾部追加元素</li><li>add(int index, E element)：在指定index位置追加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//记录结构上被修改的次数</span></span><br><span class="line">modCount++;</span><br><span class="line">add(e, elementData, size);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前数组长度等于ArrayList容量则扩容</span></span><br><span class="line"><span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">elementData = grow();</span><br><span class="line">elementData[s] = e;</span><br><span class="line">size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">//检查下标是否越界</span></span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">Object[] elementData;</span><br><span class="line"><span class="comment">//如果当前数组长度等于ArrayList容量则扩容</span></span><br><span class="line"><span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">elementData = grow();</span><br><span class="line"><span class="comment">//把index位置及其后的元素向后移动一位</span></span><br><span class="line">System.arraycopy(elementData, index,</span><br><span class="line"> elementData, index + <span class="number">1</span>,</span><br><span class="line"> s - index);</span><br><span class="line">elementData[index] = element;</span><br><span class="line">size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line"><span class="comment">//获取新容量大小</span></span><br><span class="line"><span class="comment">//oldCapacity右移一位即是原长度的一半，ArraysSupport.newLength方法选择minCapacity - oldCapacity或oldCapacity &gt;&gt; 1较大的一方与oldCapacity相加。</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">  minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">  oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line"><span class="comment">//将之前元素迁移到新数组，返回按照新容量扩容后的数组</span></span><br><span class="line"><span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果容量为0，则按照默认容量创建一个数组。</span></span><br><span class="line"><span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line"><span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加一个元素源码分析"><a href="#添加一个元素源码分析" class="headerlink" title="添加一个元素源码分析"></a>添加一个元素源码分析</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051427433.png" alt="第一次添加数据"></p><h2 id="添加多个元素源码分析"><a href="#添加多个元素源码分析" class="headerlink" title="添加多个元素源码分析"></a>添加多个元素源码分析</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051427534.png" alt="第11次添加数据"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList底层源码分析&quot;&gt;&lt;a href=&quot;#ArrayList底层源码分析&quot; class=&quot;headerlink&quot; title=&quot;ArrayList底层源码分析&quot;&gt;&lt;/a&gt;ArrayList底层源码分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://</summary>
      
    
    
    
    
    <category term="Java" scheme="https://guoxiansen.github.io/tags/Java/"/>
    
    <category term="源码" scheme="https://guoxiansen.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="https://guoxiansen.github.io/2024/01/23/%E5%9B%BE%E8%AE%BA/"/>
    <id>https://guoxiansen.github.io/2024/01/23/%E5%9B%BE%E8%AE%BA/</id>
    <published>2024-01-23T07:10:21.000Z</published>
    <updated>2024-03-15T01:53:19.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051525379.png" alt="image-20240305152551079"></p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>在图论中，主要的遍历方法就是深度优先搜索和广度优先搜索</p><p>图的存储方式主要有以下两种：</p><ul><li>邻接矩阵（二维数组）</li><li>邻接表</li></ul><h2 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h2><p>深搜三部曲</p><p>1、确定递归函数和参数</p><p>2、确定终止条件</p><p>3、处理目前搜索节点出发的路径</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    处理节点</span><br><span class="line">    dfs(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h2><p><strong>广度优先搜索适合用于解决两个点之间的最短路径问题</strong></p><p>在广度优先搜索中 ，可以使用队列也可以使用栈这样的数据结构，区别就是每一圈的顺序有所不同</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="797、所有可能的路径"><a href="#797、所有可能的路径" class="headerlink" title="797、所有可能的路径"></a>797、所有可能的路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312012122713.png" alt="image-20231201212235456"></p><p>三部曲：</p><ul><li>确定递归函数和参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph,path,x</span>):</span> <span class="comment"># graph这个图作为最外层传过来的一个参数，其实可以不写</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里的参数分别代表的含义是：遍历的图，当前已经存在的路径和当前遍历到的顶点序号<code>x</code></p><ul><li>确定终止条件</li></ul><p>题目中的要求是需要遍历从节点<code>0</code>到节点<code>n-1</code>，因此终止条件就是当前遍历的顶点序号为len(graph)-1时，即可将该路径path加入到res列表中</p><ul><li>处理目前搜索节点出发的路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph[x]:</span><br><span class="line">    path.append(node)</span><br><span class="line">    dfs(graph,path,node)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> graph:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph, path, x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="built_in">len</span>(graph)-<span class="number">1</span>: <span class="comment"># 遍历到最后一个结点之后 则回溯</span></span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[x]: <span class="comment"># 控制了不会出现重复的路径</span></span><br><span class="line">                path.append(node)</span><br><span class="line">                dfs(graph,path,node)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(graph,[<span class="number">0</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402012045443.png" alt="image-20240201204537616"></p><p>总结：</p><p>有向图路径问题比较适合用深度优先搜索。</p><p>深度优先搜索和广度优先搜索适合解决颜色类的问题</p><h2 id="200、岛屿数量"><a href="#200、岛屿数量" class="headerlink" title="200、岛屿数量"></a>200、岛屿数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402021034633.png" alt="image-20240202103424606"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402021034288.png" alt="image-20240202103445158"></p><p>DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment">#记录当前结点是否已经被访问过了</span></span><br><span class="line">        dirs = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>)]  <span class="comment"># 方向</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x,y</span>):</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">                nextx = x + d[<span class="number">0</span>]</span><br><span class="line">                nexty = y + d[<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= m <span class="keyword">or</span> nexty&lt;<span class="number">0</span> <span class="keyword">or</span> nexty &gt;=n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty] <span class="keyword">and</span> grid[nextx][nexty]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    dfs(nextx,nexty)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    visited[i][j] = <span class="literal">True</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    dfs(i,j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>BFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dirs = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">grid, i, j, visited</span>):</span></span><br><span class="line">            q = deque() <span class="comment"># </span></span><br><span class="line">            q.append((i,j))</span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                x,y = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> dirs:</span><br><span class="line">                    next_i = x + k[<span class="number">0</span>]</span><br><span class="line">                    next_j = y + k[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> next_i&lt;<span class="number">0</span> <span class="keyword">or</span> next_i&gt;=m <span class="keyword">or</span> next_j&lt;<span class="number">0</span> <span class="keyword">or</span> next_j&gt;=n <span class="keyword">or</span> visited[next_i][next_j] <span class="keyword">or</span> grid[next_i][next_j]==<span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    q.append((next_i,next_j))</span><br><span class="line">                    visited[next_i][next_j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    bfs(grid,i,j,visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="695、岛屿的最大面积"><a href="#695、岛屿的最大面积" class="headerlink" title="695、岛屿的最大面积"></a>695、岛屿的最大面积</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032222352.png" alt="image-20240203222220240"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032222175.png" alt="image-20240203222235246"></p><p>在bfs遍历过程中进行岛屿面积的求和，然后将得到的面积与res进行比较，取较大的那个。需要注意的是，在bfs函数一开始的时候，我们就访问了一个结点了，因此此时记录岛屿最大面积的tmp值应该加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dirs = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">grid, i, j, visited</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> tmp</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            tmp+=<span class="number">1</span></span><br><span class="line">            q = deque()</span><br><span class="line">            q.append((i,j))</span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                x,y = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> dirs:</span><br><span class="line">                    next_i = x + k[<span class="number">0</span>]</span><br><span class="line">                    next_j = y + k[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> next_i&lt;<span class="number">0</span> <span class="keyword">or</span> next_i&gt;=m:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> next_j&lt;<span class="number">0</span> <span class="keyword">or</span> next_j&gt;=n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> visited[next_i][next_j]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[next_i][next_j]==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    q.append((next_i,next_j))</span><br><span class="line">                    visited[next_i][next_j] = <span class="literal">True</span></span><br><span class="line">                    tmp+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    tmp=<span class="number">0</span></span><br><span class="line">                    bfs(grid,i,j,visited)</span><br><span class="line">                    res = <span class="built_in">max</span>(tmp,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="1020、飞地的数量"><a href="#1020、飞地的数量" class="headerlink" title="1020、飞地的数量"></a>1020、飞地的数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032218540.png" alt="image-20240203221823494"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032218790.png" alt="image-20240203221839899"></p><p>本题的思路就是从边缘四周进行遍历，然后将遍历得到的节点值全部赋为0（和边缘能连通的陆地的1全部修改为0），最后遍历整个图寻找其中值为1的个数有多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先从边缘进行遍历，最后统计在中间的岛屿数量</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            dfs(i-<span class="number">1</span>,j)</span><br><span class="line">            dfs(i+<span class="number">1</span>,j)</span><br><span class="line">            dfs(i,j-<span class="number">1</span>)</span><br><span class="line">            dfs(i,j+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        m,n = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span> <span class="keyword">or</span> i==m-<span class="number">1</span> <span class="keyword">or</span> j==n-<span class="number">1</span>) <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    dfs(i,j)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>总结：</p><p>无需记录每个结点是否被访问过了（这是和前几题的区别），只需要在最后统计出grid中值为1有多少个即为最终结果。</p><h2 id="130、被围绕的区域"><a href="#130、被围绕的区域" class="headerlink" title="130、被围绕的区域"></a>130、被围绕的区域</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032225869.png" alt="image-20240203222521581"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032225715.png" alt="image-20240203222540429"></p><p>本题的思路是首先将所有边缘能够遍历到的值为O的位置全部修改为A，然后再进行遍历这个图，将所有的O改为X，将所有的A改为O即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        dirs = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> board[x][y] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                board[x][y] = <span class="string">&quot;A&quot;</span></span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">                    dfs(x + d[<span class="number">0</span>], y + d[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == n - <span class="number">1</span>) <span class="keyword">and</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    dfs(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032229614.png" alt="image-20240203222906431"></p><h2 id="417、太平洋大西洋水流问题"><a href="#417、太平洋大西洋水流问题" class="headerlink" title="417、太平洋大西洋水流问题"></a>417、太平洋大西洋水流问题</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402041906117.png" alt="image-20240204190605437"></p><h2 id="827、最大人工岛"><a href="#827、最大人工岛" class="headerlink" title="827、最大人工岛"></a>827、最大人工岛</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402041948424.png" alt="image-20240204194827930"></p><h2 id="463、岛屿的周长"><a href="#463、岛屿的周长" class="headerlink" title="463、岛屿的周长"></a>463、岛屿的周长</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402042205818.png" alt="image-20240204220535567"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051525379.png&quot; alt=&quot;image-20240305152551079&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;图论&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="图" scheme="https://guoxiansen.github.io/tags/%E5%9B%BE/"/>
    
    <category term="DFS" scheme="https://guoxiansen.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://guoxiansen.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://guoxiansen.github.io/2023/12/12/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://guoxiansen.github.io/2023/12/12/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-12-12T05:13:39.000Z</published>
    <updated>2024-03-05T07:27:16.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051526964.png" alt="image-20240305152647958"></p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>通常针对一维数组的问题，如果需要寻找一个元素右边或者左边第一个比自己大或者小的元素的位置，就可以使用单调栈，时间复杂度为O(n)</p><p>单调栈的本质是空间换时间， 遍历的过程中需要使用一个栈记录右边第一个比当前元素高的值。优点是整个数组只需要遍历一次。</p><p>使用单调栈需要明确的几点：</p><ul><li>单调栈中存放的元素是什么？</li><li>单调栈里的元素是递增还是递减？</li></ul><p>单调栈中的元素可以是递增的也可以是递减的，具体需要看题目的需求。</p><p>单调栈中存放的元素最好是==<strong>下标</strong>==，这样具有更好的泛型</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="739、每日温度"><a href="#739、每日温度" class="headerlink" title="739、每日温度"></a>739、每日温度</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312121343526.png" alt="image-20231212134352911"></p><p>使用单调栈的方式==<strong>从前往后</strong>==进行遍历</p><p>栈中的元素从栈底到栈顶的顺序是递减的，直到找到一个比栈顶元素大的值，然后出栈。</p><p>栈中存放的是元素的下标，如果出现一个新的元素比栈中元素都要大的时候，就对栈中元素进行循环遍历，将其对应的res值修改为当前元素的下标和栈中存放的值的差值，这就是最终结果，到最后一个元素的时候，因为初始化结果列表中元素值都是0，姑不需要进行修改</p><p>初始化答案res为全0的列表，这样可以防止后面的元素没有下一个更大的元素，当然这一点要根据题目的要求来，因为有些题目会赋值为-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">0</span>]*<span class="built_in">len</span>(temperatures)</span><br><span class="line">        st = []</span><br><span class="line">        <span class="comment"># 从前往后进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> index,temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">            <span class="comment"># st不为空且温度大于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> temp&gt;temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                <span class="comment"># 题目中问的是下一个更高温度出现在几天之后 因此用下标之差表示即可</span></span><br><span class="line">                res[j] = index-j</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312121353512.png" alt="image-20231212135345977"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401211311511.png" alt="image-20240121131154516"></p><h2 id="496、下一个更大元素I"><a href="#496、下一个更大元素I" class="headerlink" title="496、下一个更大元素I"></a>496、下一个更大元素I</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051514436.png" alt="image-20240105151441966"></p><p>直接寻找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="comment"># 寻找下一个更大的元素</span></span><br><span class="line">        <span class="keyword">for</span> index,n1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1):</span><br><span class="line">            startindex = nums2.index(n1)</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums2[startindex+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> n&gt;n1:</span><br><span class="line">                    res[index] = n</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>使用单调栈</p><p>题目中有<strong>【需要寻找最近一个比其大的元素】</strong> 这样的字眼，就可以使用 <strong>【单调栈】</strong></p><p>本题需要注意的是题目中存在两个数组，寻找第一个数组在第二个数组元素中下一个比对应元素大的元素。题目中说了两个数组中是没有重复元素的，可以采用单调栈+哈希表的方式进行解决。</p><p>单调栈解决的是nums2中每个元素对应的下一个比其大的元素</p><p>哈希表解决的是用来存储每个元素对应的下一个元素值，这样方便对nums1进行遍历时的查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        st = []</span><br><span class="line">        res = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            <span class="comment"># print(index,num)</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> nums2[st[-<span class="number">1</span>]]&lt;num:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                res[j] = num</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="comment"># 使用zip通过两个可迭代的对象构造字典</span></span><br><span class="line">        myhash = <span class="built_in">dict</span>(<span class="built_in">zip</span>(nums2,res))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> n1 <span class="keyword">in</span> nums1:</span><br><span class="line">            ans.append(myhash[n1])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 使用哈希表记录对应元素的下一个位置的元素</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        st = []</span><br><span class="line">        <span class="comment"># res = [-1]*len(nums2)</span></span><br><span class="line">        <span class="keyword">for</span> index,n2 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> n2&gt;nums2[st[-<span class="number">1</span>]]:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                myhash[nums2[j]] = n2</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> index,n1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1):</span><br><span class="line">            ans.append(myhash.get(n1,-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201436404.png" alt="image-20240120143638324"></p><h2 id="503、下一个更大元素II"><a href="#503、下一个更大元素II" class="headerlink" title="503、下一个更大元素II"></a>503、下一个更大元素II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201437694.png" alt="image-20240120143718794"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201437805.png" alt="image-20240120143729232"></p><p>出现这种需要循环才能判断的情况，可以采用求余数的方法来多遍历一次。</p><p>类似的思路还有打家劫舍II中头尾不能同时偷的情况，就可以采用将数组（列表）进行拆分：0-n-1和1-n的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 如何解决循环的问题？</span></span><br><span class="line">        <span class="comment"># 循环也就最多循环一轮到自己本身</span></span><br><span class="line">        <span class="comment"># 用求余来表示</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>]*length</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> index,n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums*<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> n&gt;nums[st[-<span class="number">1</span>]]:</span><br><span class="line">                j = st.pop()</span><br><span class="line">                res[j] = n</span><br><span class="line">            st.append(index%length)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201446181.png" alt="image-20240120144607613"></p><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201453519.png" alt="image-20240120145358564"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401201454134.png" alt="image-20240120145411157"></p><p>在做本题之前，需要明确计算的方法是按照行进行计算还是按照列进行计算，这两个计算方法的不同会导致不同的做法。</p><p>按照行去计算的做法如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202102992.png" alt="42.接雨水2"></p><p>按照列去计算的做法如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202102761.png" alt="42.接雨水1"></p><p>按照列去计算的时候可以假设每一列的宽度为1，只需要逐列去进行累加即可得到最终结果，这个思路也衍生了下面的暴力算法：</p><ul><li><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3></li></ul><p>暴力算法的思路是一列一列的去记录能够装的雨水是多少，最终累加起来。</p><p>记录每个节点左边和右边的最大高度，然后用两个最大高度中的最小值减去当前高度，然后乘以宽度1，将这个值累加到res中。</p><p>当遍历到第一个柱子和最后一个柱子的时候，不需要计算面积。对于其余的柱子，需要寻找其左边和右边的最高的柱子，然后取两者中的最小值，用最小值的高度减去<code>height[i]</code>，得到差值就是可以装的雨水的高度，然后用这个高度再乘以宽度1，就是能装的雨水的体积。最后一直累加这个和，得到能装的最多的雨水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (<span class="built_in">min</span>(lHeight,rHeight)-height[i]) * <span class="number">1</span></span><br></pre></td></tr></table></figure><p>很不幸代码超时了。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202008841.png" alt="image-20240120200838854"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 暴力算法（从前往后进行遍历）记录当前位置左右的最高点</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            <span class="comment"># print(i)</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> i==<span class="built_in">len</span>(height)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            lHeight = height[i]</span><br><span class="line">            rHeight = height[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(height)):</span><br><span class="line">                <span class="keyword">if</span> height[j]&gt;rHeight:</span><br><span class="line">                    rHeight = height[j]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> height[j]&gt;lHeight:</span><br><span class="line">                    lHeight = height[j]</span><br><span class="line">            <span class="comment"># print(i,lHeight,rHeight)</span></span><br><span class="line">            res += <span class="built_in">min</span>(lHeight,rHeight)-height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3></li></ul><p>在暴力算法中，每轮循环都需要重复去寻找当前位置左右更高的高度，可以采用双指针的方法进行优化：</p><p>注意：双指针方法和暴力算法本质上都是==<strong>逐列进行累加</strong>==的。</p><p>通过两个单独的for循环，得到<code>lHeight</code>和<code>rHeight</code>数组（分别表示每个柱子左右两侧的最高的高度是多少），然后在通过一次循环，从1遍历到n-2位置的柱子，然后累加最终能够装的雨水的体积。</p><p>找到左边和右边的最高值，计算一列可以装的水有多少</p><p>记录每个柱子左边的最高高度和右边的最高高度，然后高度就是min(左边最高高度，右边最高高度)-height[i]，宽度就是1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        lheight = [<span class="number">0</span>]*n</span><br><span class="line">        rheight = [<span class="number">0</span>]*n</span><br><span class="line">        lheight[<span class="number">0</span>] = height[<span class="number">0</span>]   <span class="comment"># 进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">            lheight[i] = <span class="built_in">max</span>(lheight[i-<span class="number">1</span>],height[i])</span><br><span class="line">        rheight[n-<span class="number">1</span>] = height[n-<span class="number">1</span>] <span class="comment"># 进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            rheight[i] = <span class="built_in">max</span>(rheight[i+<span class="number">1</span>],height[i])</span><br><span class="line">        <span class="comment"># print(lheight,rheight)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">            res += <span class="built_in">min</span>(lheight[i],rheight[i])-height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202031943.png" alt="image-20240120203014116"></p><ul><li><h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3></li></ul><p>单调栈的核心思路是==<strong>逐行进行累加</strong>==</p><p>单调栈的思路就是如果栈为空，则先第一个柱子入栈，紧接着如果第二个柱子的高度低于栈中柱子的高度，则继续入栈。也就是说此时栈中的元素从栈顶到栈底是==<strong>从小到大</strong>==的顺序。只有从小到大的顺序才能够再下一次遇到一个比栈顶元素高的柱子的时候形成一个凹槽，然后计算能够装的雨水的体积是多少。</p><p>如果遇到相同高度的柱子，这时我们需要保存的是最新的下标，这里需要将原来的栈顶元素pop弹出，然后将当前的下标i放到栈顶中。</p><p>如果出现一种情况是当前遍历的高度高于栈顶元素的高度，那么弹出栈顶元素，此时如果栈不为空，则开始计算雨水。此时的栈顶的元素的高度就是凹槽的高度，当前遍历的就是凹槽右边的高度，然后栈顶的下一个元素就是左侧的较高的柱子。right-left-1就是宽度，乘以min(left,right)-height[i]就是最终的面积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        st = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index,h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> h&gt;height[st[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 需要计算高度了</span></span><br><span class="line">                j = st.pop()</span><br><span class="line">                <span class="keyword">if</span> st:</span><br><span class="line">                    res += (<span class="built_in">min</span>(h,height[st[-<span class="number">1</span>]])-height[j]) * (index-st[-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> h==height[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.pop()</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202151613.png" alt="image-20240120215152637"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401231310998.png" alt="image-20240123131038428"></p><h2 id="84、柱状图中最大的矩形"><a href="#84、柱状图中最大的矩形" class="headerlink" title="84、柱状图中最大的矩形"></a>84、柱状图中最大的矩形</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202153205.png" alt="image-20240120215320063"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202153653.png" alt="image-20240120215333944"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401202153776.png" alt="image-20240120215345777"></p><ul><li><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3></li></ul><p>在暴力解法中，从每个下标<code>i</code>位置出发，找到左右两侧比其高的位置，但是一旦出现比其低的位置直接break，记录下左右下边left和right，然后用right-left-1作为底面宽度，height[i]作为高度，得到最终的面积。将这个面积与sum_进行比较，取两者中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 暴力解法</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            left = i</span><br><span class="line">            right = i</span><br><span class="line">            <span class="keyword">while</span> left&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> heights[left]&lt;heights[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                left-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(heights):</span><br><span class="line">                <span class="keyword">if</span> heights[right]&lt;heights[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            sum_ = <span class="built_in">max</span>(sum_,(right-left-<span class="number">1</span>)*heights[i])</span><br><span class="line">        <span class="keyword">return</span> sum_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401211249128.png" alt="image-20240121124949045"></p><ul><li><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3></li></ul><p>记录每个柱子左边的第一个小于该柱子的下标，而不是记录左边第一个小于该柱子的高度</p><p>双指针的难点就在于如何去寻找当前位置<code>i</code>的左右两侧第一个比其低的柱子的下标</p><p>此部分的代码如下：</p><p>这里在寻找的时候需要进行初始化，不然的话while循环可能死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">minLeftIndex[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    t = i-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> t&gt;=<span class="number">0</span> <span class="keyword">and</span> heights[t]&gt;=heights[i]:</span><br><span class="line">        t = minLeftIndex[t]  <span class="comment"># 左移</span></span><br><span class="line">    minLeftIndex[i] = t</span><br><span class="line"><span class="comment"># print(minLeftIndex)</span></span><br><span class="line">minRightIndex[n-<span class="number">1</span>] = n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    t = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> t&lt;=n-<span class="number">1</span> <span class="keyword">and</span> heights[t]&gt;=heights[i]:</span><br><span class="line">        t = minRightIndex[t]</span><br><span class="line">    minRightIndex[i] = t</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 双指针法</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        minLeftIndex = [<span class="number">0</span>]*n</span><br><span class="line">        minRightIndex = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment"># 寻找左边的小于他的下标</span></span><br><span class="line">        minLeftIndex[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            t = i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> t&gt;=<span class="number">0</span> <span class="keyword">and</span> heights[t]&gt;=heights[i]:</span><br><span class="line">                t = minLeftIndex[t]  <span class="comment"># 左移</span></span><br><span class="line">            minLeftIndex[i] = t</span><br><span class="line">        <span class="comment"># print(minLeftIndex)</span></span><br><span class="line">        minRightIndex[n-<span class="number">1</span>] = n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            t = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> t&lt;=n-<span class="number">1</span> <span class="keyword">and</span> heights[t]&gt;=heights[i]:</span><br><span class="line">                t = minRightIndex[t]</span><br><span class="line">            minRightIndex[i] = t</span><br><span class="line">        <span class="comment"># print(minRightIndex)</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = <span class="built_in">max</span>(res,(minRightIndex[i]-minLeftIndex[i]-<span class="number">1</span>)*heights[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401221356227.png" alt="image-20240122135645235"></p><ul><li><h3 id="单调栈法"><a href="#单调栈法" class="headerlink" title="单调栈法"></a>单调栈法</h3></li></ul><p>单调栈中的顺序（从栈顶到栈底）应该是从大到小的。这样就方便找到每个节点的左边或者右边低于其高度的柱子。当遍历到下一个柱子的高度小于栈顶元素的时候，就可以进行弹出了。在弹出的时候计算高度即可得到最终的答案。</p><p>本质上这道题跟接雨水差不多，都可以分成如下三种情况：</p><ul><li>情况1：当前遍历的元素<code>height[i]</code>大于栈顶元素<code>height[st[-1]]</code>，此时需要入栈</li><li>情况2：当前遍历的元素<code>height[i]</code>等于栈顶元素<code>height[st[-1]]</code>，此时需要将栈顶元素弹出，然后更新最新的柱子高度对应的下标</li><li>情况3：当前遍历的元素<code>height[i]</code>小于栈顶元素<code>height[st[-1]]</code>，此时可以进行面积的计算了</li></ul><p>计算面积的时候，高度是中间的高度</p><p>本题还有一个需要注意的细节，就是需要再heights数组的开头和结尾加上一个0元素，这是因为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 单调栈</span></span><br><span class="line">        heights.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        stack = [<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">if</span> heights[i]&gt;heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> heights[i]==heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    mid = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        left_index = stack[-<span class="number">1</span>]</span><br><span class="line">                        right_index = i</span><br><span class="line">                        width = right_index - left_index - <span class="number">1</span></span><br><span class="line">                        height = heights[mid]</span><br><span class="line">                        res = <span class="built_in">max</span>(res,width*height)</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401221651253.png" alt="image-20240122165125227"></p><p>优化版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        heights.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        st = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index,h <span class="keyword">in</span> <span class="built_in">enumerate</span>(heights):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> h&lt;heights[st[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 开始进行计算面积</span></span><br><span class="line">                mid = st.pop()</span><br><span class="line">                <span class="keyword">if</span> st:</span><br><span class="line">                    left = st[-<span class="number">1</span>]</span><br><span class="line">                    right = index</span><br><span class="line">                    res = <span class="built_in">max</span>(res,heights[mid]*(right-left-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> heights[st[-<span class="number">1</span>]]==h:</span><br><span class="line">                st.pop()</span><br><span class="line">            st.append(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="1994、队列中可以看到的人数"><a href="#1994、队列中可以看到的人数" class="headerlink" title="1994、队列中可以看到的人数"></a>1994、队列中可以看到的人数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707266.png" alt="image-20240105170740011"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707699.png" alt="image-20240105170750651"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051708889.png" alt="image-20240105170804493"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canSeePersonsCount</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        ans = [<span class="number">0</span>]*n</span><br><span class="line">        st = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>]&lt;heights[i]:</span><br><span class="line">                st.pop()</span><br><span class="line">                ans[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[i]+=<span class="number">1</span></span><br><span class="line">            st.append(heights[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401051707618.png" alt="image-20240105170722984"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051526964.png&quot; alt=&quot;image-20240305152647958&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;单调栈&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="单调栈" scheme="https://guoxiansen.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣周赛20231210</title>
    <link href="https://guoxiansen.github.io/2023/12/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B20231210/"/>
    <id>https://guoxiansen.github.io/2023/12/10/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B20231210/</id>
    <published>2023-12-10T03:56:34.000Z</published>
    <updated>2023-12-10T04:00:15.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计已测试设备"><a href="#统计已测试设备" class="headerlink" title="统计已测试设备"></a>统计已测试设备</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101159415.png" alt="image-20231210115855304"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTestedDevices</span>(<span class="params">self, batteryPercentages: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(batteryPercentages)):</span><br><span class="line">            <span class="keyword">if</span> batteryPercentages[i] &gt; <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(batteryPercentages)):</span><br><span class="line">                    batteryPercentages[j] = <span class="built_in">max</span>(<span class="number">0</span>, batteryPercentages[j] - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># print(batteryPercentages)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="双模幂运算"><a href="#双模幂运算" class="headerlink" title="双模幂运算"></a>双模幂运算</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101159522.png" alt="image-20231210115921406"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGoodIndices</span>(<span class="params">self, variables: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(variables)):</span><br><span class="line">            <span class="keyword">if</span> ((variables[i][<span class="number">0</span>] ** variables[i][<span class="number">1</span>]) % <span class="number">10</span>) ** variables[i][<span class="number">2</span>] % variables[i][<span class="number">3</span>] == target:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统计最大元素出现至少-K-次的子数组"><a href="#统计最大元素出现至少-K-次的子数组" class="headerlink" title="统计最大元素出现至少 K 次的子数组"></a>统计最大元素出现至少 K 次的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个 <strong>正整数</strong> <code>k</code> 。</p><p>请你统计有多少满足 「 <code>nums</code> 中的 <strong>最大</strong> 元素」至少出现 <code>k</code> 次的子数组，并返回满足这一条件的子数组的数目。</p><p>子数组是数组中的一个连续元素序列。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101157791.png" alt="image-20231210115737423"></p><h2 id="统计好分割方案的数目"><a href="#统计好分割方案的数目" class="headerlink" title="统计好分割方案的数目"></a>统计好分割方案的数目</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312101158793.png" alt="image-20231210115820635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;统计已测试设备&quot;&gt;&lt;a href=&quot;#统计已测试设备&quot; class=&quot;headerlink&quot; title=&quot;统计已测试设备&quot;&gt;&lt;/a&gt;统计已测试设备&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/p</summary>
      
    
    
    
    
    <category term="力扣" scheme="https://guoxiansen.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode散题集合</title>
    <link href="https://guoxiansen.github.io/2023/11/29/Leetcode%E6%95%A3%E9%A2%98%E9%9B%86%E5%90%88/"/>
    <id>https://guoxiansen.github.io/2023/11/29/Leetcode%E6%95%A3%E9%A2%98%E9%9B%86%E5%90%88/</id>
    <published>2023-11-29T04:12:27.000Z</published>
    <updated>2024-01-09T05:57:43.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣散题集合"><a href="#力扣散题集合" class="headerlink" title="力扣散题集合"></a>力扣散题集合</h1><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h2 id="1200、最小绝对差"><a href="#1200、最小绝对差" class="headerlink" title="1200、最小绝对差"></a>1200、最小绝对差</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291531976.png" alt="image-20231129153157717"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291532290.png" alt="image-20231129153213057"></p><p>提示中可以得知数据量在10^5^，如果使用两层for循环判断必定超时，因此本题不能使用双层for循环进行判断</p><p>思路：</p><ul><li>对arr进行排序</li><li>因为要判断最小绝对差，所以只需要对排序后的数字进行判断相邻两数的差值即可，如果小则更新否则不更新</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = []</span><br><span class="line">        arr.sort() <span class="comment"># 排序之后从前往后进行遍历 排序之后找最小差值 只需要在相邻的两个数之间进行寻找判断即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> min_ &gt; <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>]):</span><br><span class="line">                min_ = <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>])</span><br><span class="line">                res = [[arr[i-<span class="number">1</span>],arr[i]]]</span><br><span class="line">            <span class="keyword">elif</span> min_== <span class="built_in">abs</span>(arr[i]-arr[i-<span class="number">1</span>]):</span><br><span class="line">                res.append([arr[i-<span class="number">1</span>],arr[i]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291534649.png" alt="image-20231129153424458"></p><h2 id="2843、统计对称整数的数目"><a href="#2843、统计对称整数的数目" class="headerlink" title="2843、统计对称整数的数目"></a>2843、统计对称整数的数目</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291534085.png" alt="image-20231129153456810"></p><p>数字转化为字符串进行判断再求和 复杂度较高 可以进行优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSymmetricIntegers</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">num</span>):</span></span><br><span class="line">            num = <span class="built_in">str</span>(num)</span><br><span class="line">            a = <span class="built_in">list</span>(num[:<span class="built_in">len</span>(num)//<span class="number">2</span>])</span><br><span class="line">            b = <span class="built_in">list</span>(num[<span class="built_in">len</span>(num)//<span class="number">2</span>:])</span><br><span class="line">            a = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">            b = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(a)==<span class="built_in">sum</span>(b)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low,high+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>(i))%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> judge(i):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h1><h2 id="2661、找出叠涂元素"><a href="#2661、找出叠涂元素" class="headerlink" title="2661、找出叠涂元素"></a>2661、找出叠涂元素</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011328233.png" alt="image-20231201132821370"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011329085.png" alt="image-20231201132859711"></p><p>题目理解：</p><p>注意关键词：arr中在mat的某一行<strong>或者</strong>某一列都被涂色且下标最小的元素返回其在arr中的下标</p><p>首先通过哈希表来对矩阵mat进行遍历，记录所有数字的键和值，其中键为矩阵中的数字，值为(i,j)元组，i和j分别表示该数字在矩阵中的行列下标。</p><p>注意题目中的<code>len(mat)</code> 表示矩阵共有多少行，<code>len(mat[0])</code>表示矩阵共有多少列</p><p>构建好哈希表之后，还需要一个for循环对arr数组进行遍历，然后需要将其中每一个数字的行列下标</p><p>这里是行满了或者列满了，用一个变量来记录当前行列被涂色的数量。</p><p>下面的代码中 c1 记录某行有多少个元素被涂色，即一共有多少列，c2记录某列有多少个元素被涂色，即一共有多少行。</p><p>判断c1[i]==len(mat[0]) or c2[j]=len(mat) 即可返回最终arr中的下标ii，注意这里i已经被用了，不能再使用i作为循环变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstCompleteIndex</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], mat: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">tuple</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># print(&quot;mat[&#123;&#125;][&#123;&#125;]=&#123;&#125;&quot;.format(i,j,mat[i][j]))</span></span><br><span class="line">                myhash[mat[i][j]] = (i,j)</span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        c1 = defaultdict(<span class="built_in">int</span>) <span class="comment"># 记录某行有多少个元素被涂色  ==》列</span></span><br><span class="line">        c2 = defaultdict(<span class="built_in">int</span>) <span class="comment"># 记录某列有多少个元素被涂色  ==》行</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            i,j = myhash[arr[ii]]</span><br><span class="line">            <span class="comment"># print(i,j)</span></span><br><span class="line">        </span><br><span class="line">            c1[i] += <span class="number">1</span></span><br><span class="line">            c2[j] += <span class="number">1</span>  <span class="comment"># c2[j] 表示该列有多少个元素 即 多少行元素</span></span><br><span class="line">            <span class="comment"># len(mat[0])表示有多少行  len(mat) 表示有多少列</span></span><br><span class="line">            <span class="comment"># print(c1[i],c2[j], len(mat),len(mat[0]))</span></span><br><span class="line">            <span class="keyword">if</span> c1[i]==<span class="built_in">len</span>(mat[<span class="number">0</span>]) <span class="keyword">or</span> c2[j]==<span class="built_in">len</span>(mat):</span><br><span class="line">                <span class="keyword">return</span> ii</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>优化代码：</p><p>避免重复使用len(mat)这样的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstCompleteIndex</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], mat: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])   <span class="comment"># m表示行  n表示列</span></span><br><span class="line">        myhash = &#123;mat[i][j]:(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        c1,c2 = [<span class="number">0</span>]*m,[<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(m*n):</span><br><span class="line">            i,j = myhash[arr[ii]]</span><br><span class="line">            c1[i] += <span class="number">1</span></span><br><span class="line">            c2[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c1[i]==n <span class="keyword">or</span> c2[j]==m:</span><br><span class="line">                <span class="keyword">return</span> ii</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011534524.png" alt="image-20231201153403415"></p><h2 id="1094、拼车"><a href="#1094、拼车" class="headerlink" title="1094、拼车"></a>1094、拼车</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312022123053.png" alt="image-20231202212343674"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312022124364.png" alt="image-20231202212410014"></p><h2 id="241、为运算表达式设计优先级"><a href="#241、为运算表达式设计优先级" class="headerlink" title="241、为运算表达式设计优先级"></a>241、为运算表达式设计优先级</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401091357205.png" alt="image-20231206103039562"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401091357430.png" alt="image-20231206103054281"></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h1 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;力扣散题集合&quot;&gt;&lt;a href=&quot;#力扣散题集合&quot; class=&quot;headerlink&quot; title=&quot;力扣散题集合&quot;&gt;&lt;/a&gt;力扣散题集合&lt;/h1&gt;&lt;h1 id=&quot;简单&quot;&gt;&lt;a href=&quot;#简单&quot; class=&quot;headerlink&quot; title=&quot;简单&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="散题" scheme="https://guoxiansen.github.io/tags/%E6%95%A3%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://guoxiansen.github.io/2023/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://guoxiansen.github.io/2023/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-11-25T07:20:40.000Z</published>
    <updated>2024-03-30T04:11:30.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051527105.png" alt="image-20240305152747919"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949273.jpg" alt="img"></p><p>如果某一个问题有重叠的子问题，则使用动态规划进行求解是最有效的。</p><p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点区别于贪心算法</p><p>动态规划五部曲</p><ul><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何进行初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><ul><li>01背包</li><li>完全背包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949940.png" alt="416.分割等和子集1"></p><h3 id="01背包-二维数组进行求解"><a href="#01背包-二维数组进行求解" class="headerlink" title="01背包 | 二维数组进行求解"></a>01背包 | 二维数组进行求解</h3><p>有n个物品和最多能背重量为w的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code>。<strong>每件物品只能用一次</strong>，求解将哪些物品装进背包里面价值总和最大。</p><p>递归五部曲</p><ul><li><h4 id="确定dp数组含义"><a href="#确定dp数组含义" class="headerlink" title="确定dp数组含义"></a>确定dp数组含义</h4></li></ul><p>dp[i][j]表示从下标<code>0</code>-<code>i</code>的物品中任意选取，放进容量为<code>j</code>的背包中，价值总和最大是多少</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949496.png" alt="动态规划-背包问题1"></p><ul><li><h4 id="确定递推公式"><a href="#确定递推公式" class="headerlink" title="确定递推公式"></a>确定递推公式</h4><ul><li>有两种情况：<ul><li>不放物品<ul><li>dp[i][j] = dp[i-1][j]   即当前dp数组的上一个的位置。这个含义就是，容量为<code>j</code>但是不放入<code>i</code>物品，只选择前<code>i-1</code>个物品</li></ul></li><li>放物品<ul><li><strong>dp[i][j] = dp[i-1][j-weight[i]] + value[i]**。位于当前位置的左上方，不一定正好是左上角，有可能是左上角的前面的位置。这里的含义就是需要将当前位置的重量减去，然后再加上当前位置的物品价值。注意这里是</strong>dp[i-1][j-weight[i]]**而不是dp[i][j-weight[i]]</li><li>当前的最大总价值应该取二者中的最大值，即dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); </li></ul></li></ul></li></ul></li></ul><p>并且需要注意，如果j&lt;weight[i]的时候，是不能放物品的，<strong>因为这样的情况是无法作为数组的下标的。</strong></p><p>放物品时候的理解：当i放进去的时候，背包的总重量为j，前i-1个能放的物品剩余重量就只剩下j-weight[i]，前i-1个物品中能够获得的最大价值为dp[i-1][j-weight[i]]，再加上当前物品i放进去的价值value[i]。这是当前放物品能够获得的最大价值。</p><ul><li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br></pre></td></tr></table></figure><p>当<code>j=0</code>的时候，表示当前背包能够载重为0，此时不管选择几号物品，dp[i][j]都等于0</p><p>当<code>i=0</code>的时候，表示当前只取物品0，此时只有在j&gt;=weight[0]的时候，dp[0][j]=value[0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], n+<span class="number">1</span>):</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><h4 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li></ul><p>先遍历物品或者先遍历背包都是可以的，为了和滚动数组一致，先遍历物品（几号物品）再遍历背包（背包的重量/容量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m代表材料的数量，n代表背包载重</span></span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># M 代表研究材料的种类 N代表行李空间</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表重量</span></span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部初始化为0</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化dp数组第一列  下面这部分代码可以不写 ，因为在初始化的时候就全部初始化为0了</span></span><br><span class="line"><span class="comment"># for i in range(m):</span></span><br><span class="line"><span class="comment">#     dp[i][0] = 0</span></span><br><span class="line"><span class="comment"># 初始化dp数组第一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], n + <span class="number">1</span>):</span><br><span class="line">    dp[<span class="number">0</span>][i] = value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(weight)</span></span><br><span class="line"><span class="comment"># print(value)</span></span><br><span class="line"><span class="comment"># for i in dp:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line">print(dp[m - <span class="number">1</span>][n])</span><br></pre></td></tr></table></figure><h3 id="滚动数组-01背包-二维降到一维"><a href="#滚动数组-01背包-二维降到一维" class="headerlink" title="滚动数组 | 01背包 二维降到一维"></a>滚动数组 | 01背包 二维降到一维</h3><ul><li><h4 id="dp数组含义"><a href="#dp数组含义" class="headerlink" title="dp数组含义"></a>dp数组含义</h4></li></ul><p>dp[j]表示当容量为j的时候背包所背的物品最大价值</p><ul><li><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4></li></ul><p>跟使用二维数组的时候一样，通过两种方式获得dp[j]：</p><p>放物品<code>i</code></p><p>​    当放物品i的时候，dp[j] = dp[j-weight[i]] + value[i]</p><p>不放物品<code>i</code></p><p>​    当不放物品i的时候dp[j] = dp[j-1]</p><p>递推公式为</p><p>dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</p><ul><li><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4></li></ul><p>dp[j]表示背包容量为j的时候所背物品的最大价值，则dp[0]表示物品容量为0，结果必然为0</p><p>其余的下标都是通过递推的方式从dp[0]推出，因此全部初始化为0即可</p><ul><li><h4 id="遍历顺序-1"><a href="#遍历顺序-1" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li><li><h5 id="为什么需要先遍历物品在遍历重量？"><a href="#为什么需要先遍历物品在遍历重量？" class="headerlink" title="==为什么需要先遍历物品在遍历重量？=="></a>==为什么需要先遍历物品在遍历重量？==</h5></li></ul><p>如果遍历背包容量放在外层，则每个dp[j]只会放一个物品，即背包里只放了一个物品。</p><p>针对一维dp数组，背包容量需要倒序进行遍历，如果遍历背包放在上一层，那么每个dp[j]只会放入一个物品，即背包里只装一个物品</p><ul><li><h5 id="为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）"><a href="#为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）" class="headerlink" title="为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）"></a>为什么在遍历重量的时候需要倒序遍历？（即背包重量从大到小进行遍历）</h5></li></ul><p>假设现在背包的情况是这样的</p><table><thead><tr><th align="center"></th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">物品0</td><td align="center">1</td><td align="center">15</td></tr><tr><td align="center">物品1</td><td align="center">3</td><td align="center">20</td></tr><tr><td align="center">物品2</td><td align="center">4</td><td align="center">30</td></tr></tbody></table><p>遍历部分的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>dp数组初始化为全0，如果我们从后开始进行遍历的话，当遍历物品0时，weight[0] = 1，value[0] = 15</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111706802.png" alt="image-20231211170639827"></p><p>dp[1] = max(dp[1], dp[1-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[2] = max(dp[2], dp[2-weight[0]] + value[0]) = max(0, 15+15) = 30</p><p>此时重复往背包中放入物品0了</p><p>如果我们从后往前进行遍历的话，情况如下：</p><p>dp[4] = max(dp[4], dp[4-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[3] = max(dp[3], dp[3-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[2] = max(dp[2], dp[2-weight[0]] + value[0]) = max(0, 15) = 15</p><p>dp[1] = max(dp[1], dp[1-weight[0]] + value[0]) = max(0, 15) = 15</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111711402.png" alt="image-20231211171139340"></p><p>这样循环往复就可以得到最终的dp数组，而dp[n]也就是最终结果</p><p>倒序进行遍历是因为每个背包只能放进去一次，正序遍历的时候会重复使用符合条件的背包价值。</p><p>遍历的代码部分中，倒序遍历的时候开始和结束的下标分别为n和weight[i]-1，n很好理解，就是dp数组中的元素个数，weight[i]-1表示什么含义呢？</p><p>因为题目中涉及到j-weight[i]这个操作，因此遍历到物品i的时候我们的结束下标j一定是等于weight[i]的</p><p>在Python的循环中，左闭右开，为了遍历到weight[i]这个重量，需要再减去1</p><p>例如当我们在遍历物品0的时候，即当前的i=0，此时weight[i]=1，为了能够用j模拟其能够开始推导递推公式，需要j-weight[i]&gt;=0，因此j最小下标应该就是weight[i]，又由于range()的范围是左闭右开，所以结束下标应该是weight[i]-1，此时结束下标就是0，即0的时候不会在进行循环体部分。</p><p>倒序遍历原因本质上还是对二维数组的遍历，右下角的值依赖于左上角的值，因此需要保证左边的值仍然是上一层的，从右往左进行覆盖</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111651393.png" alt="动态规划-背包问题9"></p><p><a href="https://kamacoder.com/problempage.php?pid=1046">题目链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312111654000.png" alt="image-20231211165420367"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m代表材料的数量，n代表背包载重</span></span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># M 代表研究材料的种类 N代表行李空间</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表重量</span></span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 代表价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部初始化为0   表示背包重量从0-n 共计n+1个数字</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m):  <span class="comment"># 先遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 再遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line">print(dp[n])</span><br></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包和01背包的区别就在于物品是否可以重复选取，如果每个物品只能取一次，则是01背包问题，否则是完全背包问题。他们两个的区别就在于内层循环背包重量的时候，01背包中需要<strong>从后往前</strong>进行遍历防止每个物品被重复选择，而重复选择恰好是完全背包所需要的，因此完全背包需要从前往后进行遍历。</p><p><strong>而对于完全背包问题而言，两个for循环的嵌套顺序是无所谓的</strong></p><p>先遍历物品再遍历背包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):  <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight[i], bagWeight + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>先遍历背包再遍历物品：</p><p>先遍历背包的时候，需要判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>): <span class="comment"># 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> j&gt;=num:</span><br><span class="line">            dp[j] += dp[j-num]</span><br></pre></td></tr></table></figure><p>==<strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。==</p><p>==<strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。==</p><p>爬楼梯进阶版：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142126656.png" alt="image-20231214212639400"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 背包容量为n, 物品为m</span></span><br><span class="line">dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):<span class="comment"># 遍历物品</span></span><br><span class="line">        dp[j] += dp[j-i]</span><br><span class="line">print(dp[n])</span><br></pre></td></tr></table></figure><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>多重背包的描述如下：</p><p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p><p>多重背包问题可以通过将物品数量大于1个的展开，这样就可以构成01背包问题，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191628062.png" alt="image-20231219162833785"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C为背包容量 N为类型</span></span><br><span class="line">C, N = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># weight = []</span></span><br><span class="line"><span class="comment"># price = []</span></span><br><span class="line"><span class="comment"># nums = []</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">price = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 构造01背包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nums[i] - <span class="number">1</span>):</span><br><span class="line">            weight.append(weight[i])</span><br><span class="line">            price.append(price[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(weight, price)</span></span><br><span class="line"></span><br><span class="line">dp = [<span class="number">0</span>] * (C + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">sum</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + price[i])</span><br><span class="line">print(dp[C])</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="509、斐波那契数列"><a href="#509、斐波那契数列" class="headerlink" title="509、斐波那契数列"></a>509、斐波那契数列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032022036.png" alt="image-20231203202205635"></p><p>递归解法（时间复杂度较高）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fib(n-<span class="number">1</span>)+ self.fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032030416.png" alt="image-20231203203047210"></p><p>动态规划解法</p><p>这里使用滚动数组的方式，定义了初始化值，然后进行递推，由于题目已经给出了递推公式，所以我们直接使用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dpn = dp0+dp1</span><br><span class="line">            dp0 = dp1</span><br><span class="line">            dp1 = dpn</span><br><span class="line">        <span class="keyword">return</span> dpn</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032030644.png" alt="image-20231203203032337"></p><h2 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">70、爬楼梯</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032033253.png" alt="image-20231203203303353"></p><ol><li><p><strong>确定dp数组及其下标含义</strong></p><p>dp[i]：爬到第i层楼梯，有dp[i]种方法</p></li><li><p><strong>确定递推公式</strong></p><p>dp[i]可以从两个方向进行递推，有两种情况可以到达该层：</p><ul><li>从dp[i-1]跨 <strong>1</strong> 步即可到达</li><li>从dp[i-2]跨 <strong>2</strong> 步即可到达</li></ul><p>所以dp[i]=dp[i-1]+dp[i-2]，即爬到第i层的方法是爬到第i-1层的方法总数加上爬到第i-2层的方法总数之和。</p></li><li><p><strong>dp数组如何进行初始化</strong></p><p>题目给定了n的范围&gt;=1，初始化的时候只需要从1开始初始化即可</p><p>i=0时，dp[i]=0</p><p>i=1时，dp[1]=1，表示踏上一层楼梯有一种方法，即跨一步</p><p>i=2时，dp[2]=2，表示踏上二层台阶有两种方案，即跨两次一步或者直接跨两步</p></li><li><p><strong>确定遍历顺序</strong></p><p>从前往后进行遍历</p></li><li><p><strong>举例推导dp数组</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp0 = <span class="number">1</span></span><br><span class="line">        dp1 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dpn = dp0 + dp1</span><br><span class="line">            dp0 = dp1</span><br><span class="line">            dp1 = dpn</span><br><span class="line">        <span class="keyword">return</span> dpn</span><br></pre></td></tr></table></figure><p>本题和斐波那契数列递推公式一样。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032058657.png" alt="image-20231203205804580"></p><h2 id="746、使用最小花费爬楼梯"><a href="#746、使用最小花费爬楼梯" class="headerlink" title="746、使用最小花费爬楼梯"></a>746、使用最小花费爬楼梯</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032100542.png" alt="image-20231203210026019"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312032100903.png" alt="image-20231203210050812"></p><ol><li><p><strong>确定dp数组及其下标含义</strong></p><p>dp[i]：爬到第<code>i</code>层的花费</p></li><li><p><strong>确定递推公式</strong></p><p>dp[i]可以从两个方向进行递推</p><ul><li>从dp[i-1]跨一步即可到达 dp[i] = dp[i-1]+cost[i-1]</li><li>从dp[i-2]跨两步即可到达 dp[i] = dp[i-2]+cost[i-2]</li></ul><p>因为需要最小的花销，所以取二者其中的最小值</p><p>dp[i] = min(dp[i-1]+cost[i-1],dp[i-1]+cost[i-2])</p></li><li><p><strong>dp数组如何进行初始化</strong></p><p>题目中说了你可以从下标为0或者下标为1的台阶开始爬楼梯，所以按照下面的进行计算</p><p>i=0时，dp[i]=0</p><p>i=1时，dp[i]=0</p><p>i&gt;=2时，dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</p><p>注意本题在进行初始化的时候dp数组长度为<code>len(cost)+1</code>，因为需要跨过一级</p></li><li><p><strong>确定遍历顺序</strong></p><p>从前往后进行遍历</p></li><li><p><strong>举例推导dp数组</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(cost) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost) + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403301133797.png" alt="image-20240330113311399"></p><h2 id="118、杨辉三角"><a href="#118、杨辉三角" class="headerlink" title="118、杨辉三角"></a>118、杨辉三角</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403301137224.png" alt="image-20240330113712219"></p><h2 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、不同路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312050946038.png" alt="image-20231205094642112"></p><p>动态规划</p><p>从[0][0]到[m][n]共有多少条路径，其中机器人每次只能向下或者向右移动一步。</p><ul><li>确定dp数组</li></ul><p>dp[i][j]表示从0,0出发到i,j共有多少条路径</p><ul><li>确定递推公式</li></ul><p>dp[i][j]只能从其上方或者下方走过来，就可以写成累加的形式，表示可以从dp[i-1][j]这个位置走一步或者从dp[i][j-1]这个位置走一步过来</p><p><strong>dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p><ul><li>dp数组初始化</li></ul><p>dp[i][0]和dp[0][j]都为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>确定遍历顺序</li></ul><p>都是从上方或者左方推导过来的，从左到右一层一层进行遍历即可</p><ul><li>举例推导dp数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp = [[0]*n]*m</span></span><br><span class="line">        <span class="comment"># 在Python中[[0]*n]*m表示使用相同的行列表示m次 这样实际所有行的引用都指向一个对象 </span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051015104.png" alt="image-20231205101538038"></p><h2 id="63、不同路径II"><a href="#63、不同路径II" class="headerlink" title="63、不同路径II"></a>63、不同路径II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051038974.png" alt="image-20231205102614842"></p><p>本题和上一题的区别就在于地图中有障碍物影响了行走，但是本题只需要保证障碍物的位置处，dp[i][j]始终保持为0即可。</p><ul><li>dp数组含义</li></ul><p>dp[i]][j]从下标为0,0的起点出发，到下标为i,j的位置，总共有多少条路径</p><ul><li>递推公式</li></ul><p>递推公式和上一题一样：**dp[i][j] = dp[i-1][j] + dp[i][j-1]**，区别就在于必须是在没有障碍物的位置才能够更新dp[i][j]</p><ul><li>dp数组初始化</li></ul><p>本题在进行初始化的时候需要注意，在碰到障碍物之后，就没有路了，如下图所示</p><p>所以需要进行特殊处理，即当碰到有障碍物的地方就直接设置为0，需要对第一行和第一列进行这样的特殊处理，其余的位置可以不用进行处理。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051037536.png" alt="63.不同路径II"></p><ul><li>确定遍历顺序</li></ul><p>从左到右进行遍历</p><p>在遍历的时候，如果到了障碍物的位置，直接continue</p><ul><li>举例推导dp数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># for i in dp:</span></span><br><span class="line">        <span class="comment">#     print(i)</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051037165.png" alt="image-20231205103751967"></p><h2 id="343、整数拆分（-）"><a href="#343、整数拆分（-）" class="headerlink" title="343、整数拆分（*）"></a><a href="https://leetcode.cn/problems/integer-break/description/">343、整数拆分</a>（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312051038256.png" alt="image-20231205103826968"></p><ul><li><p>dp数组表示什么含义</p><ul><li>dp[i] 表示i能拆分得到的最大乘积</li></ul></li><li><p>dp数组递推公式</p><ul><li>dp[i]可以由两个方向得到</li><li>j*（i-j)    这个的含义是i-j不进行拆分，直接相乘</li><li>j*dp[i-j]  这个的含义是i-j也进行拆分，并用拆分后的最大值与之相乘</li></ul></li><li><p>dp数组初始化</p><ul><li>dp[0]和dp[1]没有实际意义 题目也说了n&gt;=2</li><li>dp[2] = 1</li><li>循环<code>i</code>从3开始</li></ul></li><li><p>遍历遍历顺序</p><ul><li>从前往后进行遍历</li></ul></li><li><p>举例</p></li></ul><p>注意代码在进行拆分的时候j是从1到i//2+1范围的，python中for循环遍历的范围是前闭后开的所以要加上1，这里可以以4为例，4//2=2，取开区间只能取到1，不符合要求了。</p><p>假设正整数i拆分出来的第一个正整数为j  （1&lt;=j&lt;i）有下面两种方案</p><ul><li>将i拆分乘j和i-j的和，且i-j不再拆分成多个正整数 此时乘积是 *<em>j * (i-j)*</em></li><li>将i拆分成j和i-j的和，且i-j还需拆分成多个正整数 此时乘积是 *<em>j * dp[i-j]*</em></li></ul><p><strong>代码中嵌套的max的外层max是为了防止在内层j为循环变量的循环过程中覆盖掉原本dp[i]</strong></p><p>因为有的时候两个数接近的时候乘积会比较大，但是一旦两个数数值相差较大的时候，就会变小，因此需要在每一次遍历的过程中保证dp[i]最大。</p><p>两层for循环是为了从前往后进行遍历</p><ul><li>外层for的循环变量i从3开始 一直到n+1（开区间）</li><li>内存for的循环变量j从1开始 一直到i//2+1<ul><li>j代表的是数字<code>i</code>可以从1开始进行拆分成j和i-j</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j* dp[i - j], j * (i - j)))</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071144917.png" alt="image-20231207114438394"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403180927684.png" alt="image-20240318092717172"></p><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;(<span class="keyword">int</span>)i/<span class="number">2</span>+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="96、不同的二叉搜索树（-）"><a href="#96、不同的二叉搜索树（-）" class="headerlink" title="96、不同的二叉搜索树（*）"></a>96、不同的二叉搜索树（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312071203005.png" alt="image-20231207120330823"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949898.png" alt="96.不同的二叉搜索树"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949699.png" alt="96.不同的二叉搜索树1"></p><p>dp[3] 表示1-3节点组成的二叉搜索树的个数，可以分成下面三种情况</p><p>元素1作为根结点的数量 = 右子树有2个元素的搜索树的个数 + 左子树有0个元素的搜索树的个数</p><p>元素2作为根节点的数量 = 右子树有1个元素的搜索树的个数 + 左子树有1个元素的搜索树的个数</p><p>元素3作为根节点的数量 = 右子树有0个元素的搜索树的个数 + 左子树有2个元素的搜索树的个数</p><p>dp[3] = 元素1作为根结点的数量 + 元素2作为根结点的数量 + 元素3作为根结点的数量</p><p>有两个元素的搜索树是dp[2]</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211100503.png" alt="96.不同的二叉搜索树2"></p><ul><li><h4 id="确定dp数组含义-1"><a href="#确定dp数组含义-1" class="headerlink" title="确定dp数组含义"></a>确定dp数组含义</h4></li></ul><p>dp[i] 表示1到<code>i</code>结点组成的二叉搜索树的个数为dp[i]</p><ul><li><h4 id="确定递推公式-1"><a href="#确定递推公式-1" class="headerlink" title="确定递推公式"></a>确定递推公式</h4></li></ul><p>*<em>dp[i] += dp[j - 1] * dp[i - j];*</em></p><p><code>j-1</code>为<code>j</code>为头结点左子树节点数量，<code>i-j</code>为以<code>j</code>为头结点右子树节点数量</p><p><code>j</code>相当于是头结点的元素，从1遍历到<code>i</code>结束（题目中说了这个二叉搜索树由<code>n</code>个节点<code>1-n</code>组成）</p><ul><li><h4 id="dp数组如何进行初始化"><a href="#dp数组如何进行初始化" class="headerlink" title="dp数组如何进行初始化"></a>dp数组如何进行初始化</h4></li></ul><p>dp[0] = 1    不能为0 否则在乘法运算中结果就是0了</p><p>空节点的二叉树也是一颗二叉搜索树</p><ul><li><h4 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312072115635.png" alt="image-20231207211554597"></p><h2 id="416、分割等和子集（-）"><a href="#416、分割等和子集（-）" class="headerlink" title="416、分割等和子集（*）"></a>416、分割等和子集（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112023767.png" alt="image-20231211202314677"></p><p>本题需要判断数组中是否能够出现总和为<code>sum/2</code>的子集。这里需要有一个前提条件，如果数组的和为奇数是无法分成两个子集的，只有在数组和为偶数的情况下才能够划分两个子集。</p><p>所以可以根据这个条件先进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line"><span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>转换为01背包问题，每个元素只能放入一次的问题是01背包，如果可以多次放入的话，属于完全背包问题。</p><ul><li>背包的体积为<strong>sum/2</strong>，Python中是sum//2【取整】</li><li>背包放入的商品重量就是元素值，价值也是元素值</li><li>背包如果刚好装满，则找到总和为sum/2的子集</li><li>背包中的每一个元素是不可以重复放入的</li></ul><p>背包容量是多少？本题中背包最大容量为sum//2</p><ul><li><h4 id="dp数组含义-1"><a href="#dp数组含义-1" class="headerlink" title="dp数组含义"></a>dp数组含义</h4></li></ul><p>dp[j]表示容量为j的背包所能背的物品最大价值，这里的价值就是元素对应的值</p><p><strong>本题中每个元素的元素值既是价值又是重量</strong></p><p>dp[j]表示背包总容量是j，放进物品之后背的最大重量为dp[j]</p><p>如果最后的<code>dp[-1] == target</code> 则满足题意</p><ul><li><h4 id="递推公式-1"><a href="#递推公式-1" class="headerlink" title="递推公式"></a>递推公式</h4></li></ul><p>01背包问题中，遍历到某个元素的时候，有两个原则，放与不放，递推公式是一致的。</p><p>dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</p><ul><li><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4></li></ul><p>dp[0] = 0，因为在容量为0的时候是无法放物品的</p><ul><li><h4 id="遍历顺序-2"><a href="#遍历顺序-2" class="headerlink" title="遍历顺序"></a>遍历顺序</h4></li></ul><p>外层循环遍历物品，遍历下标从1-n-1【Python范围1-n】，n为物品数量，本题中指数组长度len(nums)</p><p>内存循环遍历重量，遍历下标从target-nums[i]【【Python范围target-nums[i]-1】】，target为背包最大容量</p><p>如何将问题转换为01背包问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 满足条件  背包重量设为 sum_//2</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)  <span class="comment"># 物品数量</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target,nums[i]-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i])</span><br><span class="line">                <span class="keyword">if</span> dp[-<span class="number">1</span>]==target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]==target</span><br></pre></td></tr></table></figure><p>01背包相对于本题，主要要理解，题目中物品是<code>nums[i]</code>，重量是<code>nums[i]</code>，价值也是<code>nums[i]</code>，背包体积是<code>sum//2</code>。</p><p><strong>本题主要判断的是背包是否能够装满target</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141705462.png" alt="image-20231214170551121"></p><p>优化版本：</p><p>本题如果上面的方法时间开销较大，可能存在一定的弊端，因此我们可以进行优化，优化的思路：</p><ul><li>将原本存数字的dp数组转变为存储布尔值的数组</li><li>剪枝</li></ul><p>布尔数组的初始化需要注意了，当j为0的时候，也就是背包容量为0的时候，需要赋值为True表示可以进行分割，否则后面都是False了</p><p>dp[j]表示容量为j的背包，是否能够分割成等和子集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span>  <span class="comment"># 背包容量大小</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span>  </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num&gt;target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = dp[j] <span class="keyword">or</span> dp[j-num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211121995.png" alt="image-20240321111254752"></p><h2 id="1049、最后一块石头的重量II（-）"><a href="#1049、最后一块石头的重量II（-）" class="headerlink" title="1049、最后一块石头的重量II（*）"></a>1049、最后一块石头的重量II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112053463.png" alt="image-20231211205340977"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312112054401.png" alt="image-20231211205350848"></p><p>题目含义是：尽量让石头分成重量相等的两堆，相撞之后剩下的石头最小。</p><p>本题中，物品重量为<code>stones[i]</code>，物品价值为<code>stones[i]</code></p><p>最终需要返回的事剩余石头的最小重量，如果来可以分成相等的两堆，则说明没有返回值为0</p><ul><li><h4 id="dp数组含义是什么？"><a href="#dp数组含义是什么？" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[j]表示容量为j的背包可以背的最大重量是多少</p><ul><li><h4 id="递推公式是什么？"><a href="#递推公式是什么？" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p><strong>dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</strong></p><ul><li><h4 id="如何进行初始化？"><a href="#如何进行初始化？" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>背包的最大容量为sum(stones)//2</p><ul><li><h4 id="遍历顺序是什么？"><a href="#遍历顺序是什么？" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层循环遍历背包（即石头数组）</span></span><br><span class="line"><span class="comment"># 内存循环遍历重量</span></span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span>(<span class="params">self, stones: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        total = <span class="built_in">sum</span>(stones)</span><br><span class="line">        weight = total // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (weight + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight, stone - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stone] + stone)</span><br><span class="line">        <span class="keyword">return</span> total - <span class="number">2</span> * dp[weight]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211121838.png" alt="image-20240321112126877"></p><h2 id="494、目标和（-）"><a href="#494、目标和（-）" class="headerlink" title="494、目标和（*）"></a>494、目标和（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131947748.png" alt="image-20231213194712596"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131947502.png" alt="image-20231213194725271"></p><p>分割等和子集 就是判断背包是否能装满</p><p>最后一块石头的重量II 就是看背包最大能装多少</p><p>本题就是看装满背包我们总共有多少种方式</p><p>本题中有几个先决条件，如果<code>target</code>大于<code>nums</code>数组的总和（当然<code>target</code>可能为负数所以这里加上绝对值），则没有这样的组合方式</p><p>本题中，我们假设全部为正的表达式值为<code>left</code>，全部为负的表达式值为<code>right</code>，则<code>left+right=target</code>，其中<code>right=sum-left</code>，可以得出<code>left=(sum+target)/2</code>，如果<code>sum+target</code>不为偶数则也没有这样的组合方式。</p><p>这里的背包容量大小是<code>left</code>大小，因为这里只需要计算组合方式，只需要算出<code>left</code>有多少种方式即可</p><p>问题转换为 装满容量为<code>left</code>的背包最多有多少种方法</p><p>本题也是计算有多少种方式，使用层层累加的形式。</p><ul><li><h4 id="dp数组含义是什么？-1"><a href="#dp数组含义是什么？-1" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>装满容量为j的背包最多有dp[j]种方法</p><ul><li><h4 id="递推公式是什么？-1"><a href="#递推公式是什么？-1" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[j] += dp[j-nums[i]]</p><ul><li><h4 id="如何进行初始化？-1"><a href="#如何进行初始化？-1" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[0] = 1，根据递推公式，如果dp[0]为0，则后续所有的值都是0</p><ul><li><h4 id="遍历顺序是什么？-1"><a href="#遍历顺序是什么？-1" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>背包模板 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target)&gt;sum_:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (sum_+target)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        bagSize = (sum_+target)//<span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (bagSize+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bagSize,num-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                dp[j]+=dp[j-num]</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312141740352.png" alt="image-20231214174054274"></p><h2 id="474、一和零（-）"><a href="#474、一和零（-）" class="headerlink" title="474、一和零（*）"></a>474、一和零（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131948691.png" alt="image-20231213194842864"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312131949442.png" alt="image-20231213194906205"></p><p><code>strs</code>中的元素就是物品，m和n相当于两个背包，二维的01背包。</p><p>题目要求找出<code>strs</code>中的最大子集长度</p><ul><li><h4 id="dp数组含义是什么？-2"><a href="#dp数组含义是什么？-2" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>有两个维度，本题中的m和n可以理解为一个背包，只不过这个背包是两个维度的</p><p>dp[i][j]表示最多有<code>i</code>个0和<code>j</code>个1的<code>strs</code>的最大子集的大小为dp[i][j]</p><ul><li><h4 id="递推公式是什么？-2"><a href="#递推公式是什么？-2" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[i][j]可以由前一个字符串推出</p><p><strong>dp[i][j] = dp[i-zeroNum][j-oneNum] + 1</strong></p><p><strong>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</strong></p><p>递推公式中的**+1**，加的是物品的数量</p><ul><li><h4 id="如何进行初始化？-2"><a href="#如何进行初始化？-2" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>如果物品的价格不会出现负数，就初始化为0即可，保证在后面递推的过程中不会出现覆盖</p><ul><li><h4 id="遍历顺序是什么？-2"><a href="#遍历顺序是什么？-2" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历物品再遍历背包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            zero = s.count(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 计算0的个数</span></span><br><span class="line">            one = <span class="built_in">len</span>(s)-zero    <span class="comment"># 相减得到1的个数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,one-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m,zero-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-one][j-zero]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure><p>上面的代码中使用s.count()方法时间复杂度还可以进行优化：使用collections模块中的内置Counter进行统计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            zero = Counter(s)[<span class="string">&quot;0&quot;</span>]</span><br><span class="line">            one = <span class="built_in">len</span>(s) - zero</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, zero - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, one - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142003630.png" alt="image-20231214200339571"></p><p>本题是给定背包容量，看装满背包之后有多少物品，求的是最大的物品数量，所以这里在递推公式中+1是加的物品数量</p><h2 id="518、零钱兑换II（-）"><a href="#518、零钱兑换II（-）" class="headerlink" title="518、零钱兑换II（*）"></a>518、零钱兑换II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142039614.png" alt="image-20231214203043800"></p><p>本题属于完全背包问题，也就是跟01背包问题滚动数组的内层循环相异，需要从前往后进行遍历，所有面额的硬币都是可以进行重复选取的，所以这里的处理方式与01背包恰恰相反。</p><p>同时本题是求组合数的，方案之间是没有顺序的。组合问题在回溯中也是无序的。</p><p>本题是需要找有多少个这样的方案，所以应该是用层层累加的形式。</p><ul><li><h4 id="dp数组含义是什么？-3"><a href="#dp数组含义是什么？-3" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示表示凑成总金额为<code>i</code>的所有组合方案共有dp[i]种</p><ul><li><h4 id="递推公式是什么？-3"><a href="#递推公式是什么？-3" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>对于完全背包，并且是需要计算方案数有多少的题目，需要从前往后进行累加。因此递推公式如下所示：</p><p><strong>dp[j] += dp[j-coins[i]]</strong> </p><ul><li><h4 id="如何进行初始化？-3"><a href="#如何进行初始化？-3" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>对于dp[0]，也就是全部凑成0，总共有一种方案也就是全部都不取，那么dp[0] = 1</p><ul><li><h4 id="遍历顺序是什么？-3"><a href="#遍历顺序是什么？-3" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>内层循环和外层循环都需要从前往后进行遍历。组合问题需要先遍历物品，再遍历背包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j - coin]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142039502.png" alt="image-20231214203913852"></p><h2 id="377、组合总数IV"><a href="#377、组合总数IV" class="headerlink" title="377、组合总数IV"></a>377、组合总数IV</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142113377.png" alt="image-20231214211310288"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142113461.png" alt="image-20231214211325922"></p><p>这里需要注意<em>顺序不同的序列也被看做是不同的组合</em>，所以这属于<strong>排列</strong>问题。</p><p>对于排列问题，for循环的嵌套顺序就有说法了</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><ul><li><h4 id="dp数组含义是什么？-4"><a href="#dp数组含义是什么？-4" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[j]表示组合和为j的共有dp[j]种</p><ul><li><h4 id="递推公式是什么？-4"><a href="#递推公式是什么？-4" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[j] += dp[j-nums[i]]</p><ul><li><h4 id="如何进行初始化？-4"><a href="#如何进行初始化？-4" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>有递推公式可得，dp[0] = 1</p><ul><li><h4 id="遍历顺序是什么？-4"><a href="#遍历顺序是什么？-4" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>因为是排列问题，所以先遍历背包再遍历物品，注意这里需要处理num&gt;j的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &gt; j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[j] += dp[j - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211400294.png" alt="image-20240321140031983"></p><h2 id="爬楼梯进阶版"><a href="#爬楼梯进阶版" class="headerlink" title="爬楼梯进阶版"></a>爬楼梯进阶版</h2><p>完全背包问题，需要先遍历背包再遍历物品。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i-j&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        dp[i] += dp[i-j]</span><br><span class="line">print(dp[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="322、零钱兑换"><a href="#322、零钱兑换" class="headerlink" title="322、零钱兑换"></a>322、零钱兑换</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312142140878.png" alt="image-20231214214057266"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080950430.png" alt="image-20231214214109014"></p><ul><li><h4 id="dp数组含义是什么？-5"><a href="#dp数组含义是什么？-5" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[j]表示凑成总金额数为<code>j</code>所需要的最少硬币数</p><ul><li><h4 id="递推公式是什么？-5"><a href="#递推公式是什么？-5" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>递推公式为dp[j] = min(dp[j], dp[j-coin] + 1)</p><ul><li><h4 id="如何进行初始化？-5"><a href="#如何进行初始化？-5" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>当j==0的时候需要的最少硬币为0，所以dp[0] = 0，对于除了0以外的dp数组，需要将其初始化为一个非负的最大值，所以这里全部初始化为最大值<code>float(&quot;inf&quot;)</code></p><ul><li><h4 id="遍历顺序是什么？-5"><a href="#遍历顺序是什么？-5" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># res = float(&quot;inf&quot;)</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> j - coin &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[-<span class="number">1</span>] == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212028857.png" alt="image-20240321202818292"></p><h2 id="279、完全平方数"><a href="#279、完全平方数" class="headerlink" title="279、完全平方数"></a>279、完全平方数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212123149.png" alt="image-20240321212326626"></p><ul><li><h4 id="dp数组含义是什么？-6"><a href="#dp数组含义是什么？-6" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i] 和为i的完全平方数的最少数量</p><ul><li><h4 id="递推公式是什么？-6"><a href="#递推公式是什么？-6" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[j] = min(dp[j], dp[j-i*i]+1)</p><ul><li><h4 id="如何进行初始化？-6"><a href="#如何进行初始化？-6" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>因为需要求最少数量，所以初始化的时候全部为float(“inf”)，而dp[0] = 0</p><ul><li><h4 id="遍历顺序是什么？-6"><a href="#遍历顺序是什么？-6" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历背包，再遍历物品，本题中背包大小为n，物品是平方数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(j**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i * i] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212130221.png" alt="image-20240321213034913"></p><h2 id="139、单词拆分"><a href="#139、单词拆分" class="headerlink" title="139、单词拆分"></a>139、单词拆分</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212140865.png" alt="image-20240321214017825"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212140029.png" alt="image-20240321214030955"></p><p>如何转换为背包问题？</p><p>拆分时可以重复使用字典中的单词，所以是完全背包问题。</p><p>字符串<code>s</code>是背包，物品是单词<code>wordDict</code>，同时对于示例二而言，apple+pen+apple和apple+apple+pen是不一样的，所以属于排列问题，需要先遍历背包，在遍历物品。</p><ul><li><h4 id="dp数组含义是什么？-7"><a href="#dp数组含义是什么？-7" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i] 表示字符串长度为<code>i</code>的话，dp[i]=true，表示可以拆分为一个或多个在字典中出现的单词</p><ul><li><h4 id="递推公式是什么？-7"><a href="#递推公式是什么？-7" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><ul><li><h4 id="如何进行初始化？-7"><a href="#如何进行初始化？-7" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>全部初始化为False</p><ul><li><h4 id="遍历顺序是什么？-7"><a href="#遍历顺序是什么？-7" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历背包再遍历物品</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212209718.jpg" alt="139.单词拆分"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212246043.png" alt="image-20240321224602210"></p><h2 id="198、打家劫舍"><a href="#198、打家劫舍" class="headerlink" title="198、打家劫舍"></a>198、打家劫舍</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191852126.png" alt="image-20231219185241808"></p><p>一层for循环往后进行遍历</p><ul><li><h4 id="dp数组含义是什么？-8"><a href="#dp数组含义是什么？-8" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示当前到第i家的为止，最多可以偷的最大的价值</p><ul><li><h4 id="递推公式是什么？-8"><a href="#递推公式是什么？-8" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4><ul><li><p>偷第i家 dp[i] = dp[i-2]+nums[i]</p></li><li><p>不偷第i家 dp[i] = dp[i-1]</p></li></ul></li><li><h4 id="如何进行初始化？-8"><a href="#如何进行初始化？-8" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4><ul><li><p>第1位dp[0]初始值为nums[0]</p></li><li><p>第2位dp[1]初始值为前两个数字中的最大值</p></li></ul></li><li><h4 id="遍历顺序是什么？-8"><a href="#遍历顺序是什么？-8" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 如果没有房屋，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        prev_max = <span class="number">0</span>  <span class="comment"># 上一个房屋的最大金额</span></span><br><span class="line">        curr_max = <span class="number">0</span>  <span class="comment"># 当前房屋的最大金额</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            temp = curr_max  <span class="comment"># 临时变量保存当前房屋的最大金额</span></span><br><span class="line">            curr_max = <span class="built_in">max</span>(prev_max + num, curr_max)  <span class="comment"># 更新当前房屋的最大金额</span></span><br><span class="line">            prev_max = temp  <span class="comment"># 更新上一个房屋的最大金额</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr_max  <span class="comment"># 返回最后一个房屋中可抢劫的最大金额</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403301210784.png" alt="image-20240330121056542"></p><h2 id="213、打家劫舍II"><a href="#213、打家劫舍II" class="headerlink" title="213、打家劫舍II"></a>213、打家劫舍II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191907068.png" alt="image-20231219190730068"></p><p>本题的关键在于如何处理<strong>圆环问题</strong>，可以将1-n分成1-n-1和2-n这两个区间，然后在对应的区间使用打家劫舍中的方法去找到最大值即可。</p><ul><li><h4 id="dp数组含义是什么？-9"><a href="#dp数组含义是什么？-9" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示当前到第i家的为止，最多可以偷的最大的价值</p><ul><li><h4 id="递推公式是什么？-9"><a href="#递推公式是什么？-9" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4><ul><li><p>偷第i家 dp[i] = dp[i-2]+nums[i]</p></li><li><p>不偷第i家 dp[i] = dp[i-1]</p></li></ul></li></ul><p>​    dp[i] = max(dp[i-1], dp[i-2]+nums[i])</p><ul><li><h4 id="如何进行初始化？-9"><a href="#如何进行初始化？-9" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4><ul><li><p>第1位dp[0]初始值为nums[0]</p></li><li><p>第2位dp[1]初始值为前两个数字中的最大值 max(nums[0], nums[1])</p></li></ul></li><li><h4 id="遍历顺序是什么？-9"><a href="#遍历顺序是什么？-9" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myrob</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">            dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">            dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">            <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(myrob(nums[:-<span class="number">1</span>]), myrob(nums[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 优化重复代码</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">robHouse</span>(<span class="params">nums</span>):</span></span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            pre_max = <span class="number">0</span></span><br><span class="line">            cur_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                tmp = cur_max</span><br><span class="line">                cur_max = <span class="built_in">max</span>(pre_max+num,cur_max)</span><br><span class="line">                pre_max = tmp</span><br><span class="line">            <span class="keyword">return</span> cur_max</span><br><span class="line">        <span class="comment"># 1-n-1 和2-n</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># elif n==2:</span></span><br><span class="line">        <span class="comment">#     return max(nums)</span></span><br><span class="line">        nums1 = nums[:n-<span class="number">1</span>]</span><br><span class="line">        nums2 = nums[<span class="number">1</span>:]</span><br><span class="line">        dp1 = robHouse(nums1)</span><br><span class="line">        <span class="comment"># print(dp1)</span></span><br><span class="line">        dp2 = robHouse(nums2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1,dp2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312191907170.png" alt="image-20231219190719927"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201142738.png" alt="image-20231220114200545"></p><h2 id="337、打家劫舍III"><a href="#337、打家劫舍III" class="headerlink" title="337、打家劫舍III"></a>337、打家劫舍III</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201143760.png" alt="image-20231220114356451"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312201144470.png" alt="image-20231220114414309"></p><p>本题可以使用暴力算法进行求解，但求解的时候需要使用到<strong>后序遍历</strong></p><p>动态规划解法：</p><p>dp数组表示的含义 下标为0表示不偷该节点得到的最大金钱，下标为1表示偷该节点得到的最大金钱</p><p><strong>dp数组是一个长度为2的数组</strong></p><p>递归三部曲</p><ul><li><h4 id="确定递归的参数和返回值"><a href="#确定递归的参数和返回值" class="headerlink" title="确定递归的参数和返回值"></a>确定递归的参数和返回值</h4></li></ul><p>递归的参数是当前所遍历到的节点</p><p>返回值是长度为2的dp数组</p><ul><li><h4 id="确定终止条件"><a href="#确定终止条件" class="headerlink" title="确定终止条件"></a>确定终止条件</h4></li></ul><p>如果遍历到空节点，则返回[0, 0]</p><p>这也相当于dp数组的初始化</p><ul><li><h4 id="确定遍历顺序-1"><a href="#确定遍历顺序-1" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4></li></ul><p>后序遍历</p><p>通过递归左节点获得左节点偷与不偷的金钱</p><p>通过递归右节点获得右节点偷与不偷的金钱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 下标<span class="number">0</span>：不偷，下标<span class="number">1</span>：偷</span><br><span class="line">left = robTree(cur.left) // 左</span><br><span class="line">right = robTree(cur.right) // 右</span><br><span class="line">// 中</span><br></pre></td></tr></table></figure><ul><li><h4 id="单层递归逻辑"><a href="#单层递归逻辑" class="headerlink" title="单层递归逻辑"></a>单层递归逻辑</h4></li></ul><p>如果偷当前结点的话，左右孩子结点就不能偷</p><p>val1 = cur.val + left[0] + right[0]</p><p>如果不偷当前结点的话，左右孩子结点就可以偷</p><p>val2 = max(left[0],left[1])+max(right[0], right[1])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            left = traverse(node.left)</span><br><span class="line">            right = traverse(node.right)</span><br><span class="line">            <span class="comment"># 不偷当前节点</span></span><br><span class="line">            val1 = <span class="built_in">max</span>(left[<span class="number">0</span>],left[<span class="number">1</span>])+<span class="built_in">max</span>(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 偷当前节点</span></span><br><span class="line">            val2 = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> [val1,val2]</span><br><span class="line">        dp = traverse(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312220943201.png" alt="image-20231222094326982"></p><h2 id="121、买卖股票的最佳时机（-）"><a href="#121、买卖股票的最佳时机（-）" class="headerlink" title="121、买卖股票的最佳时机（*）"></a>121、买卖股票的最佳时机（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312220946679.png" alt="image-20231222094618700"></p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法的思路就是<strong>取左边的最小值</strong>，然后每次计算当前值与当前最小值的差值，然后再取差值和res本身的最大值作为res值，直到循环结束，即得出最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 贪心算法  左边最小 右边最大</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_ = <span class="built_in">min</span>(min_,p)</span><br><span class="line">            res = <span class="built_in">max</span>(res,p-min_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><h4 id="dp数组含义是什么？-10"><a href="#dp数组含义是什么？-10" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>和打家劫舍III一样，本题中的dp数组只有两列，所代表的含义如下：   二维dp数组</p><p>dp[i][0]表示第<code>i</code>天持有股票所得最多现金</p><p>dp[i][1]表示第<code>i</code>天不再持有股票最多现金</p><ul><li><h4 id="递推公式是什么？-10"><a href="#递推公式是什么？-10" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>dp[i][0]表示如果第<code>i</code>天持有股票，可以由两个状态推导出来：</p><ul><li><p>第<code>i-1</code>天就持有股票，则维持现状，即dp[i-1][0]</p></li><li><p>第<code>i-1</code>天没有持有股票，第i天需要买入，所得现金就是买入今天股票的现金：**-price[i]**</p></li></ul><p>那么dp[i][0]应该选所得现金最大的，所以<strong>dp[i][0] = max(dp[i - 1][0], -prices[i])</strong>;</p><p>dp[i][1]表示：第<code>i</code>天不再持有股票，可以由两个状态推导出来：</p><ul><li>第<code>i-1</code>天已经出售股票，维持现状，dp[i][1] = dp[i-1][1]</li><li>第<code>i</code>天出售股票，就按照今天的价格卖出股票后得到的现金，也就是第<code>i-1</code>天持有股票的现金加上<code>i</code>天卖出股票的价格，dp[i][1] = dp[i-1][0]+prices[i]    </li></ul><p>dp[i][1]也应该选择现金大的，所以<strong>dp[i][1] = max(dp[i - 1][1], dp[i-1][0]+prices[i])</strong>; </p><ul><li><h4 id="如何进行初始化？-10"><a href="#如何进行初始化？-10" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化的时候，dp[0][0]=-prices[0]表示第0天持有股票的现金，dp[0][1] = 0，股票还没卖所以为0</p><ul><li><h4 id="遍历顺序是什么？-10"><a href="#遍历顺序是什么？-10" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>因为后面的状态依赖于前面的状态，所以便利的顺序是从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用滚动数组来节省空间（上面的二维数组其实有很多空间都是浪费的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp0 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0, -prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0+prices[i]) <span class="comment"># 因为dp0始终是小于dp1的，所以这里使用更新后的dp0也不会有影响</span></span><br><span class="line">        <span class="keyword">return</span> dp1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312221610187.png" alt="image-20231222161015785"></p><h2 id="122、买卖股票的最佳时机II（-）"><a href="#122、买卖股票的最佳时机II（-）" class="headerlink" title="122、买卖股票的最佳时机II（*）"></a>122、买卖股票的最佳时机II（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312221611651.png" alt="image-20231222161107215"></p><p>这道题在贪心算法章节已经使用贪心算法解决问题，贪心算法的核心思想就是将差值中的正值作为利润累加起来，出现负值则不作更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 贪心算法</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            res += <span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这里使用动态规划进行求解</p><p>本题中的股票是可以多次买入和出售的，在第<code>i</code>天买入股票的时候，所持有的现金可能会包含之前买卖过的利润。</p><p>第<code>i</code>天如果买入股票，所的现金就是昨天不持有股票所得的现金今天的股票价格</p><p>dp[i-1][0] - prices[i]</p><p>本题可以多次进行股票的买卖，但是最多持有一只股票</p><ul><li><h4 id="dp数组含义是什么？-11"><a href="#dp数组含义是什么？-11" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp数组的含义与上一题一致</p><p>**dp[i][0]**表示第<code>i</code>天持有股票的最多现金</p><p>**dp[i][1]**表示第<code>i</code>天不持有股票所得最多现金</p><ul><li><h4 id="递推公式是什么？-11"><a href="#递推公式是什么？-11" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>**==dp[i][0] 如果在第i天买入股票，所得现金就是昨天不持有股票的金额减去今天股票的价格==**（这是本题的核心）</p><p>在上一个问题中，买入股票的时候因为只能进行一次交易，所以等价于用0-prices[i]，而在本题中实际上是用第i-1天手中不持有现金的情况下减去今天的股票价格，就是当前持有股票的现金。</p><p>dp[i][0]可以从两个维度上进行推导</p><ul><li>第<code>i-1</code>天就持有股票，维持状态，拥有的金额为dp[i-1][0]</li><li>第<code>i-1</code>天不持有股票，第i天买入股票，拥有的金额为第i-1天不拥有股票的金额减去股票价格，dp[i][0] = dp[i-1][1]  - prices[i]</li></ul><p><strong>dp[i][0] = max(dp[i-1][1], dp[i-1][1]-prices[i])</strong></p><p>dp[i][1]的递推公式同上题 从两个状态得出，第i-1天就不持有股票以及第i天卖出股票即前一天持有股票拥有的最大现金加上当天的股票价格</p><p><strong>dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</strong></p><ul><li><h4 id="如何进行初始化？-11"><a href="#如何进行初始化？-11" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[0][0]表示持有股票拥有的现金 初始化为-prices[0]</p><p>dp[0][1]表示不持有股票拥有的现金 初始化为0  即一开始啥都没有</p><ul><li><h4 id="遍历顺序是什么？-11"><a href="#遍历顺序是什么？-11" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上面的代码中，使用二维数组的方式就会导致很多层的空间浪费，导致不必要的性能开销，因此可以使用滚动数组进行优化。</p><p>使用滚动数组</p><ul><li><code>dp0</code>代表持有股票拥有的最大现金</li><li><code>dp1</code>代表不持有股票拥有的最大现金</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用滚动数组版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp0 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0,dp1-prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1,dp0+prices[i]) <span class="comment"># 因为dp0始终是小于dp1的，所以这里使用更新后的dp0也不会有影响</span></span><br><span class="line">        <span class="keyword">return</span> dp1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080948042.png" alt="image-20231222165532772"></p><h2 id="123、买卖股票的最佳时机III（-）"><a href="#123、买卖股票的最佳时机III（-）" class="headerlink" title="123、买卖股票的最佳时机III（*）"></a>123、买卖股票的最佳时机III（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401080949668.png" alt="image-20240102210539304"></p><p>题目中说了最多可以完成两笔交易，即可以只交易一次，或者交易两次</p><p>同时不能同时参与多笔交易，即最多手里只能有持有一次股票</p><ul><li><h4 id="dp数组含义是什么？-12"><a href="#dp数组含义是什么？-12" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>共有五个状态：尚未进行操作的状态、第一次持有股票、第一次卖出股票、第二次持有股票、第二次卖出股票</p><p>dp[i][0]-dp[i][4] 分别表示</p><table><thead><tr><th align="center">下标</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">dp[i][0]</td><td align="center">不进行操作持有的最大现金（该状态不设置也可以）</td></tr><tr><td align="center">dp[i][1]</td><td align="center">第一次持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][2]</td><td align="center">第一次不再持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][3]</td><td align="center">第二次持有股票拥有的最大现金</td></tr><tr><td align="center">dp[i][4]</td><td align="center">第二次不再持有股票拥有的最大现金</td></tr></tbody></table><p>dp[i][j] 表示第i天在状态j下所拥有的最大现金</p><ul><li><h4 id="递推公式是什么？-12"><a href="#递推公式是什么？-12" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>**dp[i][1]**可以从两个方面推导出来：</p><p>第i天买入股票，dp[i][1] = dp[i-1][0] - prices[i]</p><p>第i天没有操作（即第i-1天已经持有股票了），dp[i][1] = dp[i-1][1]</p><p>根据上一题的经验，我们需要在这两者中选取最大值，即<strong>dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</strong></p><p><strong>dp[i][2]</strong> 表示第i天第一次不再持有股票拥有的最大现金，同样可以从两个方向推导：</p><p>第i天卖出股票，拥有的金额为前一天不拥有股票的现金加上今天的股票价格，即dp[i][2] = dp[i-1][1] + prices[i]</p><p>第i-1天卖出股票，维持前一天状态，dp[i][2] = dp[i-1][2]</p><p><strong>dp[i][2] = max(dp[i-1][1]+prices[i],dp[i-1][2])</strong></p><p>同理当j=3和j=4的时候的递推公式如下</p><p><strong>dp[i][3]</strong> = max(dp[i-1][3], dp[i-1][2]-prices[i])</p><p><strong>dp[i][4]</strong> = max(dp[i-1][4], dp[i-1][3]+prices[i])</p><ul><li><h4 id="如何进行初始化？-12"><a href="#如何进行初始化？-12" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;</p><p>第0天做第一次买入的操作，dp[0][1] = -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0][3] = -prices[0];</p><p>同理第二次卖出初始化dp[0][4] = 0;</p><ul><li><h4 id="遍历顺序是什么？-12"><a href="#遍历顺序是什么？-12" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>以输入[1,2,3,4,5]为例</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401112212116.png" alt="123.买卖股票的最佳时机III"></p><p>最后我们应该选择第二次卖出股票持有的最大现金作为我们的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 五个状态 0 1 2 3 4分别表示</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其实状态1是可以省略的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 五个状态 0 1 2 3 4分别表示</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], - prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用滚动数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], -prices[i])</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i])</span><br><span class="line">            dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] - prices[i])</span><br><span class="line">            dp[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261656350.png" alt="image-20240326165634803"></p><h2 id="188、买卖股票的最佳时机IV（-）"><a href="#188、买卖股票的最佳时机IV（-）" class="headerlink" title="188、买卖股票的最佳时机IV（*）"></a>188、买卖股票的最佳时机IV（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121057284.png" alt="image-20240112105746724"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121057256.png" alt="image-20240112105757067"></p><p>本题是上一题的扩展版本，本题中可以进行<code>k</code>次购买，<code>k</code>次出售，所以状态的个数也是一个变量，总共的状态数为<code>2*k</code></p><ul><li><h4 id="dp数组含义是什么？-13"><a href="#dp数组含义是什么？-13" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>0表示第一次买入股票持有的最大现金</p><p>1表示第一次卖出股票持有的最大现金</p><p>2表示第二次买入股票持有的最大现金</p><p>3表示第二次卖出股票持有的最大现金</p><p>…….</p><p>以此类推，即<code>i</code>为偶数表示买入股票持有的最大现金，<code>i</code>为奇数表示卖出股票持有的最大现金</p><ul><li><h4 id="递推公式是什么？-13"><a href="#递推公式是什么？-13" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>用for循环代替掉上一题的最多两次买卖，也就是说上一题中最多两次买卖其实本质上也就是本题中k=2</p><p>这里需要进行特殊处理的是dp[0]的值，dp[0]的值有两个维度获取：</p><ol><li>前一天就持有股票，继续维持状态，dp[0] = dp[0]</li><li>前一天不持有股票，需要买入股票，但是手中的资金为0，dp[0] = -prices[i]</li></ol><p>即dp[0] = max(dp[0], -prices[i])</p><p>对于其余的为偶数次的持有股票状态，可以就需要用前一天不持有股票的金额减去当天的股票价格了，这部分可以直接用一个for循环统一处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span> * k):</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] - prices[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] + prices[i])</span><br></pre></td></tr></table></figure><ul><li><h4 id="如何进行初始化？-13"><a href="#如何进行初始化？-13" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>在进行初始化的时候，需要设置为偶数的状态值为-prices[0]，即持有股票的状态</p><ul><li><h4 id="遍历顺序是什么？-13"><a href="#遍历顺序是什么？-13" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>后一个状态依赖于前一个状态因此需要从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="number">2</span> * k)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * k):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                dp[i] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], -prices[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span> * k):</span><br><span class="line">                <span class="keyword">if</span> j % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] - prices[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261708084.png" alt="image-20240326170854649"></p><h2 id="309、买卖股票的最佳时机含冷冻期"><a href="#309、买卖股票的最佳时机含冷冻期" class="headerlink" title="309、买卖股票的最佳时机含冷冻期"></a>309、买卖股票的最佳时机含冷冻期</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121133995.png" alt="image-20240112113340008"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401121133998.png" alt="image-20240112113350820"></p><p>本题和之前的区别卖出股票之后，无法再第二天立即购买股票（中间有一个冷冻期1天）</p><p>确认共计多少种状态：</p><ul><li>状态1：持有股票状态（今天买入股票或者前几天就已经持有股票了）</li><li>不持有股票的状态（分成两种情况）<ul><li>状态2：保持卖出股票的状态（两天之前就已经卖出股票了并且度过了一天的冷冻期。或者前一天就卖出股票一直没有操作） 区别于冷冻期，即非冷冻期</li><li>状态3：今天卖出股票</li></ul></li><li>状态4：今天为冷冻期，冷冻期只有一天，冷冻期进行单独处理</li></ul><p>这里状态对应数组的下标为0123</p><ul><li><h4 id="dp数组含义是什么？-14"><a href="#dp数组含义是什么？-14" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j] 其中i表示第几天，j表示状态（即状态1-状态4）</p><ul><li><h4 id="递推公式是什么？-14"><a href="#递推公式是什么？-14" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>对于<strong>状态1</strong>，即dp[i][0]，表示持有股票状态</p><p>其值涉及到两个操作</p><p>操作1：前一天就已经持有股票了，dp[i][0] = dp[i-1][0]</p><p>操作2：今天买入股票 </p><ul><li>前一天是冷静期 dp[i][0] = dp[i-1][3] - prices[i]</li><li>前一天是保持卖出股票状态  dp[i][0] =dp[i-1][1] -prices[i]</li></ul><p>所以dp[i][0] = max(dp[i-1][0], dp[i][3]-prices[i], dp[i-1][1] -prices[i])</p><p>对于<strong>状态2</strong>，即dp[i][1]  表示保持卖出股票的状态</p><ul><li>前一天为冷冻期 dp[i][1] =  dp[i-1][3]</li><li>仍然是保持卖出股票状态dp[i][1] = dp[i-1][1]</li></ul><p>dp[i][1] = max(dp[i-1][1], dp[i-1][3])</p><p>对于<strong>状态3</strong>，即dp[i][2]  表示今天卖出股票的状态</p><p>可以从1个方向推导出来 即前一天持有股票</p><p>dp[i][2] = dp[i-1][0] + prices[i]</p><p>对于<strong>状态4</strong>，即dp[i][3] 表示今天是冷冻期，即前一天刚卖出股票</p><p>dp[i][3] = dp[i-1][2]</p><ul><li><h4 id="如何进行初始化？-14"><a href="#如何进行初始化？-14" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>对于第0天，如果是持有股票状态即当天买入股票</p><p>如果是保持卖出股票状态，dp[0][1] = 0</p><p>如果是今天卖出股票状态</p><ul><li><h4 id="遍历顺序是什么？-14"><a href="#遍历顺序是什么？-14" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>后面的状态依赖于前面的状态，因此需要从前往后进行遍历</p><p>使用二维数组的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态 ①前一天就持有 ②前一天为冷冻期购入 ③前一天是不持有股票状态购入</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：不持有股票状态 （区别于冷冻期 表示2天前卖出股票或者更久）</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票状态 前一天持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i-<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>使用一维数组的错误版本：在下面这份代码中，有个错误就是在状态3（下标为2）和状态4（下标为3）的时候，使用的dp[0]和dp[2]已经被修改成本轮的最新值了，而实际上我们应该使用尚未修改的版本，因此需要使用两个变量来记录之前的dp[0]和dp[2]就可以得到正确的结果了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态</span></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">3</span>]-prices[i],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：保持卖出股票状态</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>],dp[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票</span></span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 状态1：持有股票状态</span></span><br><span class="line">            tmp_dp0 = dp[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">3</span>]-prices[i],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">            <span class="comment"># 状态2：保持卖出股票状态</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>],dp[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 状态3：卖出股票</span></span><br><span class="line">            tmp_dp2 = dp[<span class="number">2</span>]</span><br><span class="line">            dp[<span class="number">2</span>] = tmp_dp0+prices[i]</span><br><span class="line">            <span class="comment"># 状态4：冷冻期</span></span><br><span class="line">            dp[<span class="number">3</span>] = tmp_dp2</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]  <span class="comment"># 持有股票 | 今天买入或前几天就持有</span></span><br><span class="line">        dp2 = <span class="number">0</span>  <span class="comment"># 不持有股票 | 刚好度过了一天冷冻期或者卖出超过2天了</span></span><br><span class="line">        dp3 = <span class="number">0</span>  <span class="comment"># 不持有股票 | 今天卖出股票</span></span><br><span class="line">        dp4 = <span class="number">0</span>  <span class="comment"># 冷冻期 |</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            tmp = dp1</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp2 - prices[i], dp4 - prices[i])  <span class="comment">#</span></span><br><span class="line">            dp2 = <span class="built_in">max</span>(dp2, dp4)</span><br><span class="line">            tmp3 = dp3</span><br><span class="line">            dp3 = tmp + prices[i]</span><br><span class="line">            dp4 = tmp3</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp2, dp3, dp4)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131319093.png" alt="image-20240113131915634"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320924.png" alt="image-20240113132000021"></p><h2 id="714、买卖股票的最佳时机含手续费"><a href="#714、买卖股票的最佳时机含手续费" class="headerlink" title="714、买卖股票的最佳时机含手续费"></a>714、买卖股票的最佳时机含手续费</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320533.png" alt="image-20240113132038334"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131320242.png" alt="image-20240113132052422"></p><p>本题与买卖股票的最佳时机II的区别就在于每次在进行卖出股票的时候需要一笔手续费，所以只需要在交易的时候减去fee即可，其余的内容不需要做任何修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 状态1：今天持有股票拥有的最大现金</span></span><br><span class="line">        <span class="comment"># 状态2：今天不持有股票拥有的最大现金</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]</span><br><span class="line">        dp2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp2 - prices[i])</span><br><span class="line">            dp2 = <span class="built_in">max</span>(dp2, dp1 + prices[i] - fee)</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403272108864.png" alt="image-20240327210805829"></p><h2 id="300、最长递增子序列"><a href="#300、最长递增子序列" class="headerlink" title="300、最长递增子序列"></a>300、最长递增子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131344403.png" alt="image-20240113134442405"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401131344874.png" alt="image-20240113134456062"></p><p>在回溯算法章节，有一题==<strong>递增子序列</strong>==的题目，但是的相关题目中有本题，我也尝试采用回溯算法解决该题，测试用例AC了，但是全部测试用例超时了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startindex, path</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> startindex&gt;<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path)&gt;=<span class="number">1</span>:</span><br><span class="line">                res=<span class="built_in">max</span>(res,<span class="built_in">len</span>(path))</span><br><span class="line">            uset = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> (path <span class="keyword">and</span> path[-<span class="number">1</span>]&gt;=nums[i]) <span class="keyword">or</span> nums[i] <span class="keyword">in</span> uset:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                uset.add(nums[i])</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtracking(nums,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题实际上应该采用动态规划算法进行求解。</p><p>这里的递增子序列的含义就是说可以从这个数组中抽出来一些数字组成一个递增的子序列即可。不要求这个子序列一定是连续的</p><p>对于子序列问题，我们通常是可以采用动态规划来解决的</p><ul><li><h4 id="dp数组含义是什么？-15"><a href="#dp数组含义是什么？-15" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示下标i之前包括<code>i</code>在内的以nums[i]结尾的最长递增子序列的长度</p><ul><li><h4 id="递推公式是什么？-15"><a href="#递推公式是什么？-15" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>位置<code>i</code>的最长上升子序列等于j从0到i-1各个位置上的最长上升子序列+1的最大值。只有在值递增的情况下才会进行最大值的更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[j]):</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在进行比较的时候需要和前面所有的进行对比，也就是要取<code>0</code>到<code>i-1</code>中的全部最大值</p><ul><li><h4 id="如何进行初始化？-15"><a href="#如何进行初始化？-15" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[i]的初始值大小至少都是1，所以初始化一个全为1的一维数组即可，数组长度为<code>n</code>，如果全部初始化为0的话，会导致最终结果不对，初始化为1的含义也表示从当前下标nums[i]为结尾的递增子序列长度为1</p><ul><li><h4 id="遍历顺序是什么？-15"><a href="#遍历顺序是什么？-15" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>dp[i] 是0到i-1各个位置的最长递增子序列推导出来的，所以从前往后进行遍历</p><p>j从0遍历到i-1，遍历i在外层循环，遍历j在内层循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141242422.png" alt="image-20240114124246835"></p><h2 id="674、最长连续递增序列"><a href="#674、最长连续递增序列" class="headerlink" title="674、最长连续递增序列"></a>674、最长连续递增序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141244981.png" alt="image-20240114124444735"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141245538.png" alt="image-20240114124459176"></p><p>这题与上一题的区别就在于要求这个序列必须在原来的数组中是<strong>连续</strong>的。连续的情况下，子序列只跟前一个状态有关。如果是不连续的话，状态就会跟前面的最大值有关（即前i-1个状态）</p><ul><li><h4 id="dp数组含义是什么？-16"><a href="#dp数组含义是什么？-16" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示下标i之前包括i在内的以nums[i]结尾的最长递增子序列的长度</p><ul><li><h4 id="递推公式是什么？-16"><a href="#递推公式是什么？-16" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>这里的区别就是，如果出现隔断了，那么就需要重置临时的最大长度为1重新进行统计</p><p>本题不需要进行两层循环，一层循环即可，如果nums[i] &gt; nums[i-1] 那么dp[i] = dp[i-1]+1，否则dp[i] = 1</p><ul><li><h4 id="如何进行初始化？-16"><a href="#如何进行初始化？-16" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>跟上一题一样，初始化都为1。表示从自己开始的话最长连续子序列为1</p><ul><li><h4 id="遍历顺序是什么？-16"><a href="#遍历顺序是什么？-16" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>后面的状态依赖于前面的，所以是从前往后进行遍历，因为这里下标处理的时候涉及到<code>i-1</code>，所以需要从1开始进行循环，到<code>len(nums)</code>为止</p><p>方法1: 贪心算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 用来记录最大值</span></span><br><span class="line">        tmp = <span class="number">1</span>  <span class="comment"># 临时变量 如果出现不连续的情况tmp重置为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">1</span>  <span class="comment"># 重新开始进行计算</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141305663.png" alt="image-20240114130517584"></p><h2 id="718、最长重复子数组"><a href="#718、最长重复子数组" class="headerlink" title="718、最长重复子数组"></a>718、最长重复子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141420532.png" alt="image-20240114142007244"></p><p>本题的含义就是找出两个数组中重复部分的最大长度，数组子序列的问题，采用动态规划算法进行求解。本题中的子数组是要求<strong>连续</strong>的</p><ul><li><h4 id="dp数组含义是什么？-17"><a href="#dp数组含义是什么？-17" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示nums1数组下标<code>1</code>到<code>i-1</code>和nums2数组下标<code>1</code>到<code>j-1</code>的重复部分的最大长度（必须是连续的）</p><p>dp[i][j] 这里的i，j需要从1开始</p><ul><li><h4 id="递推公式是什么？-17"><a href="#递推公式是什么？-17" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>本题中，dp[i][j]只能通过其状态的左上方的值获取，即dp[i][j] = dp[i-1][j-1] + 1   这里为什么只能从左上方递推过来？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="如何进行初始化？-17"><a href="#如何进行初始化？-17" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><ul><li><h4 id="遍历顺序是什么？-17"><a href="#遍历顺序是什么？-17" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>先遍历nums1后遍历num2，其实顺序是无所谓的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401142120937.jpg" alt="718.最长重复子数组"></p><p>二维DP代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res,dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题中所有的状态都是从左上角推导出来的，因此可以进行状态压缩，同时其中只保存一个数据，不会发生覆盖的情况。另外需要注意，如果nums2依旧从前往后进行遍历的时候可能会因为过程中的更新导致答案错误，所以nums2需要从后往前进行遍历。</p><p>这里需要注意的是，最大值的答案很可能是在遍历过程中产生的，后续会将其进行覆盖，所以需要在比较的过程中记录下最大值最终返回</p><p>一维DP代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 创建一个一维数组 dp，用于存储最长公共子数组的长度</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums2) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 记录最长公共子数组的长度</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历数组 nums1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums1) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 用于保存上一个位置的值</span></span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历数组 nums2</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums2) + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 保存当前位置的值，因为会在后面被更新</span></span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="comment"># 如果 nums1[i-1] 和 nums2[j-1] 相等</span></span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 在当前位置上的最长公共子数组长度为上一个位置的长度加一</span></span><br><span class="line">                    dp[j] = prev + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新最长公共子数组的长度</span></span><br><span class="line">                    result = <span class="built_in">max</span>(result,dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不相等，将当前位置的值置为零</span></span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 更新 prev 变量为当前位置的值，供下一次迭代使用</span></span><br><span class="line">                prev = current</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最长公共子数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="number">1</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res,dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                prev = current</span><br><span class="line">            <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401142153127.png" alt="image-20240114215344867"></p><p>拓展</p><p>本题我们下标统一规定了从1开始，这样的目的是方便我们进行后续的递推，省去了一步初始化的步骤。如果需要从0开始，就需要对第一行和第一列进行特殊的初始化，这样比较麻烦。相等的地方需要赋值为1。</p><h2 id="114、最长公共子序列"><a href="#114、最长公共子序列" class="headerlink" title="114、最长公共子序列"></a>114、最长公共子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141331637.png" alt="image-20240114133105420"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141331863.png" alt="image-20240114133119498"></p><p>本题与上一题最长重复子数组的区别就在于，这里不需要连续，只需要是<strong>相对连续</strong>的即可</p><ul><li><h4 id="dp数组含义是什么？-18"><a href="#dp数组含义是什么？-18" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]   表示字符串text1下标从0到<code>i-1</code>和字符串text2下标从0到<code>j-1</code>的最长公共子序列的长度</p><ul><li><h4 id="递推公式是什么？-18"><a href="#递推公式是什么？-18" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>从三个方向递推过来</p><p>如果text1[i-1]和text2[j-1]相等，则dp[i][j]=dp[i-1][j-1] + 1 在二维dp中可以看做是从左上角递推过来的</p><p>如果两者不相等，则需要考虑从其左侧或者正上方递推过来。即<strong>dp[i][j] = max(dp[i][j-1], dp[i-1][j])</strong></p><p>不相等的情况是使用前面字符的最长公共子序列  假装删除其中一个字符 可以是i-1位置的也可能是j-1位置上的</p><ul><li><h4 id="如何进行初始化？-18"><a href="#如何进行初始化？-18" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化为0</p><ul><li><h4 id="遍历顺序是什么？-18"><a href="#遍历顺序是什么？-18" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历，总共有三个方向可以推导出dp[i][j]</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141510074.jpg" alt="1143.最长公共子序列"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n1 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n2 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text2[i - <span class="number">1</span>] == text1[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401141512224.png" alt="image-20240114151211048"></p><p>一维dp数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        t1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        t2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(t2+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t1+<span class="number">1</span>):</span><br><span class="line">            prev = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t2+<span class="number">1</span>):</span><br><span class="line">                current = dp[j]</span><br><span class="line">                <span class="comment"># print(current)</span></span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = prev + <span class="number">1</span>  <span class="comment"># 0+1   保留上一行的值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-<span class="number">1</span>])</span><br><span class="line">                prev = current</span><br><span class="line">            <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161041397.png" alt="image-20240116104126073"></p><h2 id="1035、不相交的线"><a href="#1035、不相交的线" class="headerlink" title="1035、不相交的线"></a>1035、不相交的线</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151638482.png" alt="image-20240115163854290"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151639706.png" alt="image-20240115163909055"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151639145.png" alt="image-20240115163922980"></p><p>本题的本质和最长公共子序列是一样的，代码可以原封不动不做修改，仅需修改变量</p><p>题目给出的连线的条件是nums1[i-1]==nums2[j-1]则可以进行连线，必须要保持相对的顺序，否则会出现线的交叉导致出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxUncrossedLines</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151640625.png" alt="image-20240115164012706"></p><h2 id="53、最大子数组和"><a href="#53、最大子数组和" class="headerlink" title="53、最大子数组和"></a>53、最大子数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151735038.png" alt="image-20240115173510067"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401151735949.png" alt="image-20240115173520886"></p><p>法一：贪心算法</p><p>贪心的思路就是不断进行累加，如果出现负值了，就重新开始记数，同时在每一轮进行最大值的更新，出现比当前最大值大了才进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tmp+=num</span><br><span class="line">            res = <span class="built_in">max</span>(res,tmp)</span><br><span class="line">            <span class="keyword">if</span> tmp&lt;<span class="number">0</span>:</span><br><span class="line">                tmp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>法二：动态规划</p><p>动规五部曲：</p><ul><li><h4 id="dp数组含义是什么？-19"><a href="#dp数组含义是什么？-19" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]表示到当前下标i位置的最大子数组和是多少</p><ul><li><h4 id="递推公式是什么？-19"><a href="#递推公式是什么？-19" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>有两个方向可以推导出最终结果</p><p>一个是dp[i-1]+nums[i]  表示当前值和前面的累加</p><p>一个是当前值大于前面值的累加和，赋值为nums[i]</p><ul><li><h4 id="如何进行初始化？-19"><a href="#如何进行初始化？-19" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>将dp[0]赋值为nums[0]即可</p><ul><li><h4 id="遍历顺序是什么？-19"><a href="#遍历顺序是什么？-19" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 两个状态   累加前面的和或者当前值从新开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><h2 id="392、判断子序列"><a href="#392、判断子序列" class="headerlink" title="392、判断子序列"></a>392、判断子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152127112.png" alt="image-20240115212747069"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152128613.png" alt="image-20240115212801437"></p><p>解法一：双指针法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 使用双指针来解决</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s_ = t_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s_ &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> t_ &lt; <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[s_]==t[t_]:</span><br><span class="line">                s_+=<span class="number">1</span></span><br><span class="line">            t_+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s_ == <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><p>解法二：动态规划</p><p>本题中只需要考虑删除元素的情况，不需要考虑添加元素的情况因此还是比较简单的 【编辑距离的入门题目】</p><p>只需要判断二者的公共子序列长度是否为s的长度即可</p><ul><li><h4 id="dp数组含义是什么？-20"><a href="#dp数组含义是什么？-20" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示以下标为<code>i-1</code>为结尾的字符串s，和以下标为<code>j-1</code>结尾的字符串t，相同子序列的长度</p><ul><li><h4 id="递推公式是什么？-20"><a href="#递推公式是什么？-20" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>分为两种情况：</p><p>一、s[i-1]==t[j-1]   即t中找到了一个字符在s中出现了</p><p>二、s[i-1]!=t[j-1]    相当于t要删除元素，并继续进行匹配</p><p>对于情况一，dp[i][j] = dp[i-1][j-1] + 1  找到了相同子序列 长度加1</p><p>对于情况二，dp[i][j] = dp[i][j-1]     ==删掉一个字符串==</p><ul><li><h4 id="如何进行初始化？-20"><a href="#如何进行初始化？-20" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化还和之前一样赋值为0即可</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161057463.png" alt="392.判断子序列"></p><ul><li><h4 id="遍历顺序是什么？-20"><a href="#遍历顺序是什么？-20" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161058636.jpg" alt="392.判断子序列1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> n1==dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="115、不同的子序列"><a href="#115、不同的子序列" class="headerlink" title="115、不同的子序列(*)"></a>115、不同的子序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152149493.png" alt="image-20240115214907337"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401152149120.png" alt="image-20240115214922997"></p><ul><li><h4 id="dp数组含义是什么？-21"><a href="#dp数组含义是什么？-21" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]的含义是字符串s以<code>i-1</code>结尾的子序列出现在以<code>j-1</code>为结尾的字符串t的个数为dp[i][j] </p><ul><li><h4 id="递推公式是什么？-21"><a href="#递推公式是什么？-21" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>这里的递推公式是这样的（分为两种情况）：</p><p>如果两个字符相等 则，dp[i][j]由两个部分组成：<strong>dp[i-1][j-1]</strong> 和 <strong>dp[i-1][j]</strong>   </p><p>dp[i-1][j-1]表示使用s[i-1]和t[j-1]进行比较或者不使用s[i-1]而使用s[i-2]进行比较</p><p>模拟把这个s[i-1]这个元素给删除了</p><p>如果s[i-1]和t[j-1]相等，dp[i][j] = dp[i-1][j-1] + dp[i-1][j]  前一个有多少种方式+s删掉s[i-1]这个字符再进行比较出现的次数。因为题目问的是s的子序列中有多少个t，所以t不需要删除元素而s可以删除</p><p>如果s[i-1]和t[j-1]不相等，dp[i][j] = dp[i-1][j]，表示删除s中的j-1字符，用s[i-2]进行比较</p><ul><li><h4 id="如何进行初始化？-21"><a href="#如何进行初始化？-21" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>在dp数组初始化的时候我们赋值为全0数组</p><p>但是在j=0的时候，也就是t为空字符串的时候，s删除所有的字符就可以构成t了，此时dp[i][0]=1，即有s有一个子字符串为t</p><ul><li><h4 id="遍历顺序是什么？-21"><a href="#遍历顺序是什么？-21" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历，但是需要注意，需要保证j大于1。有递推公式可以得出dp[i][j]是从左上方和正上方推出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181251366.png" alt="img"></p><ul><li><h4 id="距离推导dp数组"><a href="#距离推导dp数组" class="headerlink" title="距离推导dp数组"></a>距离推导dp数组</h4></li></ul><p>以s：”baegg”，t：”bag”为例，推导dp数组状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181251573.jpg" alt="115.不同的子序列"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 模拟删除字符串s[i-1] 用s[i-2]进行比较</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401191112796.png" alt="image-20240119111203386"></p><h2 id="583、两个字符串的删除操作"><a href="#583、两个字符串的删除操作" class="headerlink" title="583、两个字符串的删除操作"></a>583、两个字符串的删除操作</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401161514033.png" alt="image-20240116151456778"></p><p>本题不同于上一题不同的子序列，两个单词word1和word2都可以进行删除操作</p><ul><li><h4 id="dp数组含义是什么？-22"><a href="#dp数组含义是什么？-22" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j] 表示以i-1为结尾的字符串word1和以j-1为结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><ul><li><h4 id="递推公式是什么？-22"><a href="#递推公式是什么？-22" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li><li><p>word[i-1]与word[i-1]相等  则不需要删除字符维持不变即可</p><ul><li>dp[i][j] = dp[i-1][j-1]</li></ul></li><li><p>word[i-1]与word[i-1]不相等，有如下 几种情况</p><ul><li>删除word1[i-1]，最少操作次数为dp[i-1][j] + 1</li><li>删除word2[j-1]，最少操作次数为dp[i][j-1] + 1</li><li>删除word1[i-1]和word2[i-1]，最少操作次数为dp[i-1][j-1] + 2</li></ul></li></ul><p>本题求的是最少的操作次数，因此需要取这三者中的最小值，即min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 2)。</p><p>但是dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2</p><ul><li><h4 id="如何进行初始化？-22"><a href="#如何进行初始化？-22" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>dp[i][0]表示以i-1结尾的word1要想变成空字符串，需要删除的字符串个数 为i，所以dp[i][0] = i</p><p>dp[0][j] 同理  dp[0][j] = j</p><ul><li><h4 id="遍历顺序是什么？-22"><a href="#遍历顺序是什么？-22" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181411569.png" alt="583.两个字符串的删除操作1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i  <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181412689.png" alt="image-20240118141213816"></p><p>本题的另一个思路是求两个字符串的最长公共子序列，然后用长度之和减去两倍的最长公共子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> n1+n2-<span class="number">2</span>*dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181418579.png" alt="image-20240118141834808"></p><h2 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离(*)"></a>72、编辑距离(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181419849.png" alt="image-20240118141908484"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181419025.png" alt="image-20240118141921213"></p><p>本题跟之前的题目相比，多了两个操作（插入和替换单词）</p><ul><li><h4 id="dp数组含义是什么？-23"><a href="#dp数组含义是什么？-23" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示以i-1结尾的word1和以i-1结尾的word2，如果想要变成一样的字符需要的最少操作次数</p><ul><li><h4 id="递推公式是什么？-23"><a href="#递推公式是什么？-23" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果word[i-1]和word[j-1]相等，则不需要进行操作，即dp[i][j]=dp[i-1][j-1]</p><p>如果word[i-1]和word[j-1]不相等，需要进行的操作有</p><ul><li>增<ul><li>选择增加的时候，本质上和删除的操作次数是一样的</li></ul></li><li>删<ul><li>如果删除的是word1的第i-1位置，则dp[i][j] = dp[i-1][j] + 1</li><li>如果删除的是word2的第j-1位置，则dp[i][j] = dp[i][j-1] + 1</li></ul></li><li>替换位置<ul><li>替换的时候，即替换word1[i-1]和word2[j-1]其中之一使其相等，dp[i][j] = dp[i-1][j-1] + 1</li></ul></li></ul><p>所以最终的代码如下：</p><ul><li><h4 id="如何进行初始化？-23"><a href="#如何进行初始化？-23" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化的时候需要注意dp[0][j]和dp[i][0]的含义</p><p>dp[0][j] 表示word2要变成word1空字符串需要操作的次数，即为j次</p><p>dp[i][0] 表示word1要变成word2空字符串需要操作的次数，即为i次</p><ul><li><h4 id="遍历顺序是什么？-23"><a href="#遍历顺序是什么？-23" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从前往后进行遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401191128328.png" alt="image-20240119112827281"></p><h2 id="647、回文子串"><a href="#647、回文子串" class="headerlink" title="647、回文子串(*)"></a>647、回文子串(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181506634.png" alt="image-20240118150631224"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181506107.png" alt="image-20240118150641764"></p><p>子串：连续的字符串组成的一个序列</p><p>统计字符串<code>s</code>中的回文子串的数目</p><ul><li><h4 id="dp数组含义是什么？-24"><a href="#dp数组含义是什么？-24" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i]如果表示到下标<code>i</code>位置字符串s的子串有多少个回文子串，那么就很难找到递推关系 </p><p>所以dp数组初始化为dp[i][j]  字符串从i到j的子串是否是回文子串  这里用bool类型的元素来进行表示即可</p><ul><li><h4 id="递推公式是什么？-24"><a href="#递推公式是什么？-24" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果s[i]和s[j]相等，则分成三种情况讨论</p><ul><li><p>i==j，单个字符，是回文子串</p></li><li><p>j-i=1，即j和i相差1个字符，也是回文子串</p></li><li><p>j-i≥1，相差多个字符，就需要看中间的字符是否也是回文子串，即dp[i+1][j-1]</p></li><li><h4 id="如何进行初始化？-24"><a href="#如何进行初始化？-24" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>初始化全部的dp数组为false，表示不是回文子串</p><ul><li><h4 id="遍历顺序是什么？-24"><a href="#遍历顺序是什么？-24" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>从dp左下角往右上角递推，注意j是从i开始进行遍历一直到len(s)的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;=<span class="number">1</span>:</span><br><span class="line">                        res+=<span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                            res+=<span class="number">1</span></span><br><span class="line">                            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181606400.png" alt="image-20240118160615948"></p><p>简化版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j] <span class="keyword">and</span> (j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401182208861.png" alt="image-20240118220833731"></p><h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串(*)"></a>5、最长回文子串(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623627.png" alt="image-20240118161552594"></p><p>本题只需要在上一题遍历的过程中进行长度的判断即可</p><p>递推的顺序依旧是从左下角到左上角</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;=<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> j-i&gt;=length:</span><br><span class="line">                            ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                            length = j-i</span><br><span class="line">                        res+=<span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                            <span class="keyword">if</span> j-i&gt;=length:</span><br><span class="line">                                ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                                length = j-i</span><br><span class="line">                            res+=<span class="number">1</span></span><br><span class="line">                            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623317.png" alt="image-20240118161626038"></p><p>简化版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        length = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j] <span class="keyword">and</span> (j-i&lt;=<span class="number">1</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">if</span> length&lt;j-i:</span><br><span class="line">                        ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">                        length = j-i</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401182209437.png" alt="image-20240118220904814"></p><h2 id="516、最长回文子序列"><a href="#516、最长回文子序列" class="headerlink" title="516、最长回文子序列(*)"></a>516、最长回文子序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181623228.png" alt="image-20240118162341066"></p><p>本题的子序列和子串的区别就在于，子序列可以是原本的字符删除其中一部分得到的一个序列，子串必须是连续的。</p><ul><li><h4 id="dp数组含义是什么？-25"><a href="#dp数组含义是什么？-25" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li></ul><p>dp[i][j]表示字符串s在[i,j]范围内最长的回文子序列的长度为dp[i][j]</p><ul><li><h4 id="递推公式是什么？-25"><a href="#递推公式是什么？-25" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li></ul><p>如果s[i]和s[j]相等，则dp[i][j] = dp[i+1][j-1] + 2</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181626930.jpg" alt="516.最长回文子序列"></p><p>如果s[i]和s[j]不相等，则可以判断二者其中的一个加入到子序列中的时候，能够得到的最大值，也就是：</p><p>dp[i][j] = max(dp[i][j-1], dp[i-1][j])</p><ul><li><h4 id="如何进行初始化？-25"><a href="#如何进行初始化？-25" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li></ul><p>对角线部分初始化为1，因为对角线已经初始化过了，所以j的遍历顺序需要从i+1开始</p><ul><li><h4 id="遍历顺序是什么？-25"><a href="#遍历顺序是什么？-25" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><p>==从左下到右上方，i从len(s)到0，j从i+1到len(s)，不从i开始的原因是因为对角线部分即ij的时候我们已经初始化过了，这一点也是本题与前两题不同之处。==</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181707879.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp表示的是i到j之间回文子序列的最大长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment"># 为什么j从i+1开始，跟之前不一样？</span></span><br><span class="line">                <span class="keyword">if</span> s[j]==s[i]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202401181647610.png" alt="image-20240118164712517"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板：</p><ul><li><h4 id="dp数组含义是什么？-26"><a href="#dp数组含义是什么？-26" class="headerlink" title="dp数组含义是什么？"></a>dp数组含义是什么？</h4></li><li><h4 id="递推公式是什么？-26"><a href="#递推公式是什么？-26" class="headerlink" title="递推公式是什么？"></a>递推公式是什么？</h4></li><li><h4 id="如何进行初始化？-26"><a href="#如何进行初始化？-26" class="headerlink" title="如何进行初始化？"></a>如何进行初始化？</h4></li><li><h4 id="遍历顺序是什么？-26"><a href="#遍历顺序是什么？-26" class="headerlink" title="遍历顺序是什么？"></a>遍历顺序是什么？</h4></li></ul><h2 id="01背包问题总结"><a href="#01背包问题总结" class="headerlink" title="01背包问题总结"></a>01背包问题总结</h2><h2 id="完全背包问题总结"><a href="#完全背包问题总结" class="headerlink" title="完全背包问题总结"></a>完全背包问题总结</h2><h2 id="股票问题总结"><a href="#股票问题总结" class="headerlink" title="股票问题总结"></a>股票问题总结</h2><ul><li><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">动态规划：121.买卖股票的最佳时机</a></li><li><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II</a></li><li><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a></li><li><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">动态规划：188.买卖股票的最佳时机IV</a></li><li><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">动态规划：309.最佳买卖股票时机含冷冻期</a></li><li><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：714.买卖股票的最佳时机含手续费</a></li></ul><p>第一题：股票只能买卖一次，求最大利润</p><p>第二题：股票可以买卖多次，求最大利润</p><p>第三题：最多只能买卖两次，求最大利润</p><p>第四题：最多能够买卖k次，求最大利润，这题是上一题的扩展版本，总结出规律即可，状态j为奇数时，卖出股票，为偶数时，为卖出股票</p><p>第五题：冷冻期导致问题多出了两个状态，一个是冷冻期，一个是不持有股票的状态（今天卖出股票和前2天卖出股票区别于冷冻期）</p><p>第六题：本质上是第二题，只是多了一笔手续费，只需要在卖出股票的递推公式中减去fee即可，其余代码不需要改动</p><h2 id="子序列问题总结"><a href="#子序列问题总结" class="headerlink" title="子序列问题总结"></a>子序列问题总结</h2><ul><li>最长上升子序列</li><li>最长连续递增子序列</li><li>最长重复子数组</li><li>最长公共子序列</li><li>不相交的线</li><li>最大子序和</li></ul><h2 id="编辑距离问题总结"><a href="#编辑距离问题总结" class="headerlink" title="编辑距离问题总结"></a>编辑距离问题总结</h2><ul><li>判断子序列</li><li>不同的子序列</li><li>两个字符串的删除操作</li><li>编辑距离</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051527105.png&quot; alt=&quot;image-20240305152747919&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;动态规划&quot;&gt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="https://guoxiansen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>

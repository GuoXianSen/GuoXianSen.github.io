<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay_Guo的博客</title>
  
  
  <link href="https://guoxiansen.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoxiansen.github.io/"/>
  <updated>2024-10-06T10:54:20.176Z</updated>
  <id>https://guoxiansen.github.io/</id>
  
  <author>
    <name>Clay_Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap的遍历方式</title>
    <link href="https://guoxiansen.github.io/2024/10/06/HashMap%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <id>https://guoxiansen.github.io/2024/10/06/HashMap%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</id>
    <published>2024-10-06T10:53:11.000Z</published>
    <updated>2024-10-06T10:54:20.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h1><h2 id="EntrySet遍历"><a href="#EntrySet遍历" class="headerlink" title="EntrySet遍历"></a>EntrySet遍历</h2><h2 id="KeySet遍历"><a href="#KeySet遍历" class="headerlink" title="KeySet遍历"></a>KeySet遍历</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap的遍历方式&quot;&gt;&lt;a href=&quot;#HashMap的遍历方式&quot; class=&quot;headerlink&quot; title=&quot;HashMap的遍历方式&quot;&gt;&lt;/a&gt;HashMap的遍历方式&lt;/h1&gt;&lt;h2 id=&quot;EntrySet遍历&quot;&gt;&lt;a href=&quot;#Ent</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常见设计模式总结</title>
    <link href="https://guoxiansen.github.io/2024/10/04/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://guoxiansen.github.io/2024/10/04/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-04T02:05:59.000Z</published>
    <updated>2024-10-04T08:09:09.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式总结"><a href="#常见设计模式总结" class="headerlink" title="常见设计模式总结"></a>常见设计模式总结</h1><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202410040133406.png" alt="eded52fd-c04c-47c2-b15a-188cfcb95dde"></p><p>Spring中和JAVA IO中就涉及到设计模式，具体包括以下几个：</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>双重锁检查法单例模式</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式是指在不改变原有对象的情况下扩展功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见设计模式总结&quot;&gt;&lt;a href=&quot;#常见设计模式总结&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式总结&quot;&gt;&lt;/a&gt;常见设计模式总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianS</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://guoxiansen.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Hot100题解</title>
    <link href="https://guoxiansen.github.io/2024/08/11/LeetCode-Hot100%E9%A2%98%E8%A7%A3/"/>
    <id>https://guoxiansen.github.io/2024/08/11/LeetCode-Hot100%E9%A2%98%E8%A7%A3/</id>
    <published>2024-08-11T02:57:31.000Z</published>
    <updated>2024-10-12T12:12:03.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49、字母异位词分组"><a href="#49、字母异位词分组" class="headerlink" title="49、字母异位词分组"></a>49、字母异位词分组</h2><h2 id="128、最长连续序列"><a href="#128、最长连续序列" class="headerlink" title="128、最长连续序列"></a>128、最长连续序列</h2><p>首先，题目给定的整数数组<code>num</code>是未排序的并且可能存在重复的数字。</p><p>本题思路，如果每次重复遍历数字，并针对该数字判断其连续的序列是否在集合中的话，时间复杂度就是O(n²)，其实如果一个数字是开头的话，就有可能会有重复寻找的情况。</p><p>因此可以判断一个数字的前一个数字是否在列表中，如果存在则不需要再从这个数字开始判断了，直接遍历下一个数字。</p><p>采用集合set进行去重。</p><p>python题解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                i = <span class="number">1</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> num + i <span class="keyword">in</span> num_set:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Java题解</p><p>这里nums为数组，不能直接使用<code>forEach</code>进行遍历，需要使用<code>Arrays.stream()</code>将其转换为流对象然后再进行<code>forEach</code>遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.stream(nums).forEach(num -&gt; num_set.add(num));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (num_set.contains(num + i)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(count, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h2><p>本题的思路是有两个指针，right指针进行遍历，left指针指向的是非0数字的当前末尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[right];</span><br><span class="line">                nums[right] = nums[left];</span><br><span class="line">                nums[left] = tmp;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、盛水最多的容器"><a href="#11、盛水最多的容器" class="headerlink" title="11、盛水最多的容器"></a>11、盛水最多的容器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[left], height[right]) * (right - left))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &lt; height[left]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><p>暴力解法 时间复杂度是<code>o(n²)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            myhash = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> -nums[i] - nums[j] <span class="keyword">in</span> myhash:</span><br><span class="line">                    tmp = [nums[i], nums[j], -nums[i] - nums[j]]</span><br><span class="line">                    <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(tmp)</span><br><span class="line">                myhash[nums[j]] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>双指针解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> sum_ == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h1&gt;&lt;h2 id=&quot;1、两数之和&quot;&gt;&lt;a href=&quot;#1、两数之和&quot; class=&quot;headerlink&quot; title=&quot;1、两数之和&quot;&gt;&lt;/a&gt;1</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://guoxiansen.github.io/2024/05/26/%E5%A0%86/"/>
    <id>https://guoxiansen.github.io/2024/05/26/%E5%A0%86/</id>
    <published>2024-05-26T01:46:15.000Z</published>
    <updated>2024-05-27T13:22:04.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>堆是一种基于树结构的数据结构，具有高效的插入和删除操作。</p><p>堆本质是完全二叉树，常用的两种堆分别是：</p><ul><li>最大堆：父节点的值小于或等于其子节点的值</li><li>最小堆：父节点的值大于或等于其子节点的值</li></ul><p>堆通常用于实现优先队列或者堆排序等算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建最小堆</span></span><br><span class="line">heap = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入元素</span></span><br><span class="line">heapq.heappush(heap, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出最小元素</span></span><br><span class="line">min_element = heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Min Heap:&quot;</span>, heap)</span><br><span class="line">print(<span class="string">&quot;Min Element:&quot;</span>, min_element)</span><br></pre></td></tr></table></figure><h2 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列/堆"></a>优先队列/堆</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;堆-1&quot;&gt;&lt;a href=&quot;#堆-1&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;堆是一种基于树</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="堆" scheme="https://guoxiansen.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>前缀和整理</title>
    <link href="https://guoxiansen.github.io/2024/05/22/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B4%E7%90%86/"/>
    <id>https://guoxiansen.github.io/2024/05/22/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B4%E7%90%86/</id>
    <published>2024-05-22T13:12:25.000Z</published>
    <updated>2024-05-27T13:16:14.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><blockquote><p>2024年3月9日美团笔试 前缀和 * 1</p><p>2024年3月13日 携程笔试 前缀和 * 1</p></blockquote><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="2602、使数组元素全部相等的最少操作次数"><a href="#2602、使数组元素全部相等的最少操作次数" class="headerlink" title="2602、使数组元素全部相等的最少操作次数"></a>2602、使数组元素全部相等的最少操作次数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132151734.png" alt="image-20240313215122293"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153581.png" alt="image-20240313215333584"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153069.png" alt="image-20240313215347177"></p><p>本题类似于<strong>携程</strong>的笔试题，暴力算法的时间复杂度为<code>O(n²)</code>，n=10^5，铁超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], queries: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            operation = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                operation += <span class="built_in">abs</span>(nums[i]-q)</span><br><span class="line">            res.append(operation)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132153379.png" alt="image-20240313215259899"></p><p>正确思路：</p><p>前缀和+二分查找</p><p>构造前缀和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], queries: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        s = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))  <span class="comment"># 前缀和</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            j = bisect_left(nums, q)</span><br><span class="line">            <span class="comment"># print(j)</span></span><br><span class="line">            left = q * j - s[j]  <span class="comment"># 蓝色面积</span></span><br><span class="line">            right = s[n] - s[j] - q * (n - j)  <span class="comment"># 绿色面积</span></span><br><span class="line">            ans.append(left + right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403132223074.png" alt="image-20240313222304904"></p><h2 id="238、除以自身以外数组的乘积"><a href="#238、除以自身以外数组的乘积" class="headerlink" title="238、除以自身以外数组的乘积"></a>238、除以自身以外数组的乘积</h2><h2 id="303、区域和检索"><a href="#303、区域和检索" class="headerlink" title="303、区域和检索"></a>303、区域和检索</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405221936084.png" alt="image-20240522193620214"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405221936111.png" alt="image-20240522193632228"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        s = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + nums[i]</span><br><span class="line">        self.s = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.s[right + <span class="number">1</span>] - self.s[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(left,right)</span></span><br></pre></td></tr></table></figure><h2 id="560、和为K的子数组"><a href="#560、和为K的子数组" class="headerlink" title="560、和为K的子数组"></a>560、和为K的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405222016079.png" alt="image-20240522201658158"></p><p>思路：</p><p>构造<code>s</code>数组，然后将每个位置的值设置为对应的前缀和，连续的子数组的和就为<code>s[j]-s[i]</code></p><p>myhash存储的是对应元素出现的次数，例如和为1的子数组出现的次数</p><p>两次遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        s = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s[index + <span class="number">1</span>] = s[index] + num</span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        <span class="comment"># 连续的子数组之和为K  s[j]-s[i]=k</span></span><br><span class="line">        <span class="comment"># s[j]-s[i]=连续子数组和=k</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 需要注意特殊情况 nums=[1],k=1的情况，如果s不设置s[0]就会出现结果为0的情况</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            res += myhash[ss - k]</span><br><span class="line">            myhash[ss] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>一次遍历：</p><p>一边计算前缀和，一边遍历前缀和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        res = s = <span class="number">0</span></span><br><span class="line">        myhash[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            s += num</span><br><span class="line">            res += myhash[s - k]</span><br><span class="line">            myhash[s] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        s = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s[index + <span class="number">1</span>] = s[index] + num</span><br><span class="line">        <span class="comment"># print(s) # [0,1,0,0]</span></span><br><span class="line">        <span class="comment"># 看差值是否在哈希表中 记录其出现的次数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ss - k <span class="keyword">in</span> myhash:</span><br><span class="line">                res += myhash[ss - k]</span><br><span class="line">            myhash[ss] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;2024年3月9日美团笔试 前缀和 * 1&lt;/p&gt;
&lt;p&gt;2024年3月13日 携程笔试 前缀和 * 1&lt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="前缀和" scheme="https://guoxiansen.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树（Java版本）</title>
    <link href="https://guoxiansen.github.io/2024/05/12/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%E7%89%88%E6%9C%AC%EF%BC%89/"/>
    <id>https://guoxiansen.github.io/2024/05/12/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%E7%89%88%E6%9C%AC%EF%BC%89/</id>
    <published>2024-05-12T01:02:31.000Z</published>
    <updated>2024-05-17T03:51:57.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">TreeNode()&#123;&#125;</span><br><span class="line">TreeNode(<span class="keyword">int</span> val)&#123;<span class="keyword">this</span>.val = val&#125;</span><br><span class="line">TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right)&#123;</span><br><span class="line"><span class="keyword">this</span>.val=val;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历算法"><a href="#二叉树的递归遍历算法" class="headerlink" title="二叉树的递归遍历算法"></a>二叉树的递归遍历算法</h2><h3 id="先序遍历【递归】"><a href="#先序遍历【递归】" class="headerlink" title="先序遍历【递归】"></a>先序遍历【递归】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历【递归】"><a href="#中序遍历【递归】" class="headerlink" title="中序遍历【递归】"></a>中序遍历【递归】</h3><h3 id="后序遍历【递归】"><a href="#后序遍历【递归】" class="headerlink" title="后序遍历【递归】"></a>后序遍历【递归】</h3><h2 id="二叉树的非递归遍历算法"><a href="#二叉树的非递归遍历算法" class="headerlink" title="二叉树的非递归遍历算法"></a>二叉树的非递归遍历算法</h2><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树与二叉树&quot;&gt;&lt;a href=&quot;#树与二叉树&quot; class=&quot;headerlink&quot; title=&quot;树与二叉树&quot;&gt;&lt;/a&gt;树与二叉树&lt;/h1&gt;&lt;h2 id=&quot;二叉树的结构&quot;&gt;&lt;a href=&quot;#二叉树的结构&quot; class=&quot;headerlink&quot; title=&quot;二</summary>
      
    
    
    
    
    <category term="Java" scheme="https://guoxiansen.github.io/tags/Java/"/>
    
    <category term="二叉树" scheme="https://guoxiansen.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="https://guoxiansen.github.io/2024/05/04/%E5%9B%BE%E8%AE%BA/"/>
    <id>https://guoxiansen.github.io/2024/05/04/%E5%9B%BE%E8%AE%BA/</id>
    <published>2024-05-04T07:10:21.000Z</published>
    <updated>2024-05-31T14:18:23.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051525379.png" alt="image-20240305152551079"></p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>在图论中，主要的遍历方法就是深度优先搜索和广度优先搜索</p><p>图的存储方式主要有以下两种：</p><ul><li>邻接矩阵（二维数组）</li><li>邻接表</li></ul><h2 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h2><p>深搜三部曲</p><p>1、确定递归函数和参数</p><p>2、确定终止条件</p><p>3、处理目前搜索节点出发的路径</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    处理节点</span><br><span class="line">    dfs(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">direction = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, visited, x, y</span>):</span></span><br><span class="line">    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> direction:</span><br><span class="line">        nextx = x + dx</span><br><span class="line">        nexty = y + dy</span><br><span class="line">        <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">            visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">            dfs(grid, visited, nextx, nexty)</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h2><p><strong>广度优先搜索适合用于解决两个点之间的最短路径问题</strong></p><p>在广度优先搜索中 ，可以使用队列也可以使用栈这样的数据结构，区别就是每一圈的顺序有所不同</p><p>BFS的思想在之前的二叉树的层序遍历中已经被使用到了，当时使用了deque()队列进行层序遍历</p><p>在图中，我们也可以采用BFS的方式进行遍历，当然采取的数据结构可以是队列，也可以采用栈，但大多数情况下都是用队列的，所以下面的代码中也就采用队列来实现了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">grid, visited, x, y</span>):</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x, y))</span><br><span class="line">    visited[x][y] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        x, y = queue.popleft()  <span class="comment"># 弹出队首元素</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> direction:</span><br><span class="line">            nextx, nexty = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">                queue.append((nextx, nexty))</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="图的应用（参照811）"><a href="#图的应用（参照811）" class="headerlink" title="图的应用（参照811）"></a>图的应用（参照811）</h2><ul><li>最小生成树<ul><li>克鲁斯卡尔算法</li><li>普里姆算法</li></ul></li><li>拓扑排序</li><li>最短路径问题<ul><li>单源最短路径<ul><li>BFS</li><li>迪杰斯特拉</li></ul></li><li>多源最短路径<ul><li>弗洛伊德</li></ul></li></ul></li><li>关键路径</li><li>有向无环图描述表达式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405010052468.png" alt="image-20240501005242111"></p><h2 id="并查集相关问题"><a href="#并查集相关问题" class="headerlink" title="并查集相关问题"></a>并查集相关问题</h2><p>并查集一般用来解决连通性问题</p><p>判断两个元素是否在同一个集合里的时候要使用到并查集</p><p>并查集的两个主要功能：</p><ul><li>将两个元素添加到同一个集合里</li><li>判断两个元素是否在同一个集合里</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.father = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, u</span>):</span></span><br><span class="line">        <span class="keyword">if</span> u != self.father[u]:</span><br><span class="line">            self.father[u] = self.find(self.father[u])  <span class="comment"># 进行路径压缩，构成一个根结点连接多个孩子结点的情况</span></span><br><span class="line">        <span class="keyword">return</span> self.father[u]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSame</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        u = self.find(u)  <span class="comment"># 寻找根的过程</span></span><br><span class="line">        v = self.find(v)  <span class="comment"># 寻找根的过程</span></span><br><span class="line">        <span class="keyword">if</span> u == v:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.father[v] = u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = <span class="number">1005</span>  <span class="comment"># 根据题目中节点数量而定，一般比节点数量稍大一些</span></span><br><span class="line">    uf = UnionFind(n)</span><br><span class="line">    uf.join(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    uf.join(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    print(uf.find(<span class="number">1</span>))</span><br><span class="line">    print(uf.find(<span class="number">3</span>))</span><br><span class="line">    print(uf.isSame(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">    print(uf.isSame(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 在使用时，可以通过 uf.init() 进行初始化，但在 Python 中不需要显式的初始化函数。</span></span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="797、所有可能的路径"><a href="#797、所有可能的路径" class="headerlink" title="797、所有可能的路径"></a>797、所有可能的路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312012122713.png" alt="所有可能的路径"></p><p>本题中给出的<code>graph[i]</code>表示第<code>i</code>个节点可以访问的所有节点的列表</p><p>递归三部曲：</p><ul><li><h3 id="确定递归函数和参数"><a href="#确定递归函数和参数" class="headerlink" title="确定递归函数和参数"></a>确定递归函数和参数</h3></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph,path,x</span>):</span> <span class="comment"># graph这个图作为最外层传过来的一个参数，其实可以不写</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里的参数分别代表的含义是：遍历的图，当前已经存在的路径和当前遍历到的顶点序号<code>x</code></p><ul><li><h3 id="确定终止条件"><a href="#确定终止条件" class="headerlink" title="确定终止条件"></a>确定终止条件</h3></li></ul><p>题目中的要求是需要遍历从节点<code>0</code>到节点<code>n-1</code>，因此终止条件就是当前遍历的顶点序号为len(graph)-1时，即可将该路径path加入到res列表中</p><ul><li><h3 id="处理目前搜索节点出发的路径"><a href="#处理目前搜索节点出发的路径" class="headerlink" title="处理目前搜索节点出发的路径"></a>处理目前搜索节点出发的路径</h3></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph[x]:</span><br><span class="line">    path.append(node)</span><br><span class="line">    dfs(graph,path,node)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">path, x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="built_in">len</span>(graph) - <span class="number">1</span>:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[x]:</span><br><span class="line">                path.append(node)</span><br><span class="line">                backtracking(path, node)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtracking([<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402012045443.png" alt="image-20240201204537616"></p><p>注意：初始化的时候需要将起点先加入到<code>path</code>数组中去</p><p>总结：</p><p>有向图路径问题比较适合用深度优先搜索。</p><p>深度优先搜索和广度优先搜索适合解决颜色类的问题</p><h2 id="200、岛屿数量"><a href="#200、岛屿数量" class="headerlink" title="200、岛屿数量"></a>200、岛屿数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402021034633.png" alt="image-20240202103424606"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402021034288.png" alt="image-20240202103445158"></p><p>本题类似于找有多少联通分量</p><p>DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, grid, visited, x, y</span>):</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">            nextx, nexty = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty] <span class="keyword">and</span> grid[nextx][nexty] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                self.dfs(grid, visited, nextx, nexty)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    visited[i][j] = <span class="literal">True</span></span><br><span class="line">                    self.dfs(grid, visited, i, j)</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>BFS</p><p>采用广度优先搜索，看看有多少<code>grid[x][y]==&#39;1&#39;</code>的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, visited, x, y</span>):</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((x, y))</span><br><span class="line">        visited[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">                nextx, nexty = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    nextx &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid)</span><br><span class="line">                    <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty] <span class="keyword">and</span> grid[nextx][nexty] == <span class="string">&quot;1&quot;</span>:  <span class="comment"># 岛屿</span></span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    queue.append((nextx, nexty))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    self.bfs(grid, visited, i, j)</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404292119651.png" alt="image-20240429211941875"></p><h2 id="695、岛屿的最大面积"><a href="#695、岛屿的最大面积" class="headerlink" title="695、岛屿的最大面积"></a>695、岛屿的最大面积</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032222352.png" alt="image-20240203222220240"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404292122015.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032222175.png" alt="image-20240203222235246"></p><p>在bfs遍历过程中进行岛屿面积的求和，然后将得到的面积与res进行比较，取较大的那个。需要注意的是，在bfs函数一开始的时候，我们就访问了一个结点了，因此此时记录岛屿最大面积的tmp值应该加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dirs = [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">grid, i, j, visited</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> tmp</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            tmp+=<span class="number">1</span></span><br><span class="line">            q = deque()</span><br><span class="line">            q.append((i,j))</span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                x,y = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> dirs:</span><br><span class="line">                    next_i = x + k[<span class="number">0</span>]</span><br><span class="line">                    next_j = y + k[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> next_i&lt;<span class="number">0</span> <span class="keyword">or</span> next_i&gt;=m:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> next_j&lt;<span class="number">0</span> <span class="keyword">or</span> next_j&gt;=n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> visited[next_i][next_j]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[next_i][next_j]==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    q.append((next_i,next_j))</span><br><span class="line">                    visited[next_i][next_j] = <span class="literal">True</span></span><br><span class="line">                    tmp+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    tmp=<span class="number">0</span></span><br><span class="line">                    bfs(grid,i,j,visited)</span><br><span class="line">                    res = <span class="built_in">max</span>(tmp,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>BFS代码：</p><p>使用模板进行做题求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line">        <span class="comment"># self.dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]</span></span><br><span class="line">        self.max_ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, visited, x, y</span>):</span></span><br><span class="line">        queue = deque([(x, y)])</span><br><span class="line">        visited[x][y] = <span class="literal">True</span></span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">                nextx, nexty = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    nextx &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid)</span><br><span class="line">                    <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">                    queue.append((nextx, nexty))</span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">        self.max_ = <span class="built_in">max</span>(self.max_, tmp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    self.bfs(grid, visited, i, j)</span><br><span class="line">        <span class="keyword">return</span> self.max_</span><br></pre></td></tr></table></figure><p>DFS代码</p><p>本题在使用DFS进行遍历的时候需要注意，递归的过程中每遇到一个岛屿的时候，就需要将其值进行累加，这里给类中定义了一个变量max_用来记录每一次循环过程中的岛屿。</p><p>其实这里类似于图论中的联通分量，一个岛屿就是一个联通分量，每到一个联通分量中就会执行一次循环中的dfs，然后再去计算岛屿的面积</p><p>在for循环的开始即遍历到的那个节点处，需要将<code>max_</code>值初始化为1，因为当前节点如果是岛屿的话，在dfs过程中不会计算所以需要进行初始化，然后在dfs的最后，我们需要将res更新为最新的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line">        <span class="comment"># self.dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]</span></span><br><span class="line">        self.max_ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, grid, visited, x, y</span>):</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">            nextx, nexty = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[nextx][nexty] <span class="keyword">and</span> grid[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                self.dfs(grid, visited, nextx, nexty)</span><br><span class="line">                self.max_ += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    self.max_ = <span class="number">1</span></span><br><span class="line">                    visited[i][j] = <span class="literal">True</span></span><br><span class="line">                    self.dfs(grid, visited, i, j)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, self.max_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404301924144.png" alt="image-20240430192449132"></p><h2 id="1020、飞地的数量"><a href="#1020、飞地的数量" class="headerlink" title="1020、飞地的数量"></a>1020、飞地的数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032218540.png" alt="image-20240203221823494"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032218790.png" alt="image-20240203221839899"></p><p>本题的思路就是从边缘四周进行遍历，然后将遍历得到的节点值全部赋为0（和边缘能连通的陆地的1全部修改为0），最后遍历整个图寻找其中值为1的个数有多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先从边缘进行遍历，最后统计在中间的岛屿数量</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> grid[i][j]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            dfs(i-<span class="number">1</span>,j)</span><br><span class="line">            dfs(i+<span class="number">1</span>,j)</span><br><span class="line">            dfs(i,j-<span class="number">1</span>)</span><br><span class="line">            dfs(i,j+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        m,n = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span> <span class="keyword">or</span> i==m-<span class="number">1</span> <span class="keyword">or</span> j==n-<span class="number">1</span>) <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    dfs(i,j)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>总结：</p><p>无需记录每个结点是否被访问过了（这是和前几题的区别），只需要在最后统计出grid中值为1有多少个即为最终结果。</p><p>BFS思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 将四周1改为0  然后遍历中间有多少1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="comment"># 修改所有可以联通的地方改成0</span></span><br><span class="line">            queue = deque([(x, y)])</span><br><span class="line">            <span class="comment"># visited[x][y] = True</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">                grid[x][y] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                x, y = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">                    nextx, nexty = x + dx, y + dy</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        nextx &lt; <span class="number">0</span></span><br><span class="line">                        <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid)</span><br><span class="line">                        <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                        <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">                    ):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                        queue.append((nextx, nexty))</span><br><span class="line">                        grid[nextx][nexty] = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># visited[nextx][nexty] = True</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> <span class="keyword">and</span> (i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n - <span class="number">1</span>):</span><br><span class="line">                    bfs(i, j)</span><br><span class="line">        <span class="comment"># print(mygrid)</span></span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404301931031.png" alt="image-20240430193118374"></p><h2 id="130、被围绕的区域"><a href="#130、被围绕的区域" class="headerlink" title="130、被围绕的区域"></a>130、被围绕的区域</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032225869.png" alt="image-20240203222521581"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032225715.png" alt="image-20240203222540429"></p><p>本题的思路是首先将所有边缘能够遍历到的值为O的位置全部修改为A，然后再进行遍历这个图，将所有的O改为X，将所有的A改为O即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        dirs = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> board[x][y] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                board[x][y] = <span class="string">&quot;A&quot;</span></span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">                    dfs(x + d[<span class="number">0</span>], y + d[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == n - <span class="number">1</span>) <span class="keyword">and</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    dfs(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402032229614.png" alt="image-20240203222906431"></p><p>dfs遍历实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边缘的O都变成A，将其余的O变成X，再将所有的A变成O</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">board, x, y</span>):</span></span><br><span class="line">            <span class="comment"># x y 需要满足边界条件</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">                nextx = x + dx</span><br><span class="line">                nexty = y + dy</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    nextx &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(board)</span><br><span class="line">                    <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[nextx][nexty] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[nextx][nexty] = <span class="string">&quot;A&quot;</span></span><br><span class="line">                    dfs(board, nextx, nexty)</span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(board) - <span class="number">1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">                ) <span class="keyword">and</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    dfs(board, i, j)</span><br><span class="line">                    board[i][j] = <span class="string">&quot;A&quot;</span></span><br><span class="line">        <span class="comment"># print(board)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405010040501.png" alt="image-20240501004056824"></p><p>BFS实现遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dir</span> = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边缘的O都变成A，将其余的O变成X，再将所有的A变成O</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">board, x, y</span>):</span></span><br><span class="line">            queue = deque([(x, y)])</span><br><span class="line">            board[x][y] = <span class="string">&quot;A&quot;</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                x, y = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.<span class="built_in">dir</span>:</span><br><span class="line">                    nextx = x + dx</span><br><span class="line">                    nexty = y + dy</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        nextx &lt; <span class="number">0</span></span><br><span class="line">                        <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(board)</span><br><span class="line">                        <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                        <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">                    ):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> board[nextx][nexty] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                        board[nextx][nexty] = <span class="string">&quot;A&quot;</span></span><br><span class="line">                        queue.append((nextx, nexty))</span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(board) - <span class="number">1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">                ) <span class="keyword">and</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    bfs(board, i, j)</span><br><span class="line">        <span class="comment"># print(board)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br></pre></td></tr></table></figure><p>BFS这里需要注意在修改代码的最后要将最新符合条件的位置的内容添加到队列当中。</p><h2 id="417、太平洋大西洋水流问题"><a href="#417、太平洋大西洋水流问题" class="headerlink" title="417、太平洋大西洋水流问题"></a>417、太平洋大西洋水流问题</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402041906117.png" alt="image-20240204190605437"></p><p>思路：用一个数据结构[(1,2,3,4)]存储所有的节点，如果一个节点是可以从大西洋到太平洋并且可以从太平洋到大西洋就可以添加到结果集合中。</p><p>注意：之前的代码有个错误，就是如果一个点既能到太平洋又能到大西洋就会会漏计算，要将elif改成if就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        visited = [</span><br><span class="line">            [[<span class="literal">False</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)</span><br><span class="line">        ]  <span class="comment"># 用来标记当前位置是否能从太平洋或者大西洋到达 0:太平洋 1:大西洋</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    visited[i][j][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">                    self.dfs(heights, visited, i, j, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n - <span class="number">1</span>:</span><br><span class="line">                    visited[i][j][<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                    self.dfs(heights, visited, i, j, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> visited[i][j][<span class="number">0</span>] <span class="keyword">and</span> visited[i][j][<span class="number">1</span>]:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, heights, visited, x, y, flag</span>):</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">            nextx = x + dx</span><br><span class="line">            nexty = y + dy</span><br><span class="line">            <span class="comment"># 如果当前位置的高度高于x,y的高度，需要跳过</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                nextx &lt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(heights)</span><br><span class="line">                <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">or</span> heights[nextx][nexty] &lt; heights[x][y]</span><br><span class="line">                <span class="keyword">or</span> visited[nextx][nexty][flag]</span><br><span class="line">            ):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># if visited[nextx][nexty][flag] == False:</span></span><br><span class="line">            visited[nextx][nexty][flag] = <span class="literal">True</span></span><br><span class="line">            self.dfs(heights, visited, nextx, nexty, flag)</span><br></pre></td></tr></table></figure><p>BFS代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]  <span class="comment"># 上右下左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        visited = [[[<span class="literal">False</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  <span class="comment"># 用来标记当前位置是否能从太平洋或者大西洋到达 0:太平洋 1:大西洋</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    self.bfs(heights, visited, i, j, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n - <span class="number">1</span>:</span><br><span class="line">                    self.bfs(heights, visited, i, j, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> visited[i][j][<span class="number">0</span>] <span class="keyword">and</span> visited[i][j][<span class="number">1</span>]:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, heights, visited, x, y, flag</span>):</span></span><br><span class="line">        queue = deque([(x, y)])</span><br><span class="line">        visited[x][y][flag] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                nextx = x + dx</span><br><span class="line">                nexty = y + dy</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(heights) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(heights[<span class="number">0</span>]) <span class="keyword">or</span> heights[nextx][</span><br><span class="line">                    nexty] &lt; heights[x][y] <span class="keyword">or</span> visited[nextx][nexty][flag]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited[nextx][nexty][flag] = <span class="literal">True</span></span><br><span class="line">                queue.append((nextx, nexty))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]</span></span><br><span class="line">    <span class="comment"># heights = [[2, 1], [1, 2]]</span></span><br><span class="line">    heights = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line">    res = s.pacificAtlantic(heights)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="comment"># visited = [[[False] * 2 for _ in range(3)] for _ in range(5)]</span></span><br><span class="line">    <span class="comment"># for i in range(len(visited)):</span></span><br><span class="line">    <span class="comment">#     for j in range(len(visited[0])):</span></span><br><span class="line">    <span class="comment">#         print(visited[i][j][0])</span></span><br></pre></td></tr></table></figure><h2 id="994、腐烂的橘子"><a href="#994、腐烂的橘子" class="headerlink" title="994、腐烂的橘子"></a>994、腐烂的橘子</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405031149399.png" alt="image-20240502204651657"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405031149133.png" alt="image-20240502204701754"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131949283.png" alt="image-20240513194951920"></p><p>类似于树的层次遍历，记录一共有多少层</p><p>这里是遍历总共进行几次BFS</p><p>这里需要注意：如果一开始有多个腐烂的橘子，需要将其全部添加到初试的队列中，同时这里还有一点需要注意，添加的时候除了其位置<code>i</code>和<code>j</code>，还需要添加一个当前发生的分钟数。这样我们在每次进行bfs的时候，在往queue中添加新的橘子的时候，queue.append((i,j,num+1))这样去添加，这样在同一层的所有的节点的分钟数都是一样的，只有下一层的才会进行num+1操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, visited</span>):</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    queue.append((i, j, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, num = queue.popleft()</span><br><span class="line">            res = <span class="built_in">max</span>(res, num) <span class="comment"># 更新最新的分钟数</span></span><br><span class="line">            visited[x][y] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.directions:</span><br><span class="line">                nextx = x + dx</span><br><span class="line">                nexty = y + dy</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= m <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">                    queue.append((nextx, nexty, num + <span class="number">1</span>))</span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    grid[nextx][nexty] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        res = self.bfs(grid, visited)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    grid = [[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">    print(Solution().orangesRotting(grid))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131839693.png" alt="image-20240513183931600"></p><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        queue = deque()</span><br><span class="line">        fresh = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    fresh += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> fresh:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                x, y = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                    nextx, nexty = x + dx, y + dy</span><br><span class="line">                    <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= m <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                        grid[nextx][nexty] = <span class="number">2</span></span><br><span class="line">                        queue.append((nextx, nexty))</span><br><span class="line">                        fresh -= <span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> fresh == <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405132023103.png" alt="image-20240513202315555"></p><h2 id="827、最大人工岛"><a href="#827、最大人工岛" class="headerlink" title="827、最大人工岛"></a>827、最大人工岛</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402041948424.png" alt="image-20240204194827930"></p><p>【错误思路】本题思路就是将所有的岛屿进行编号并构建哈希表为{编号: 面积}，例如{1: [10, False]}</p><p>这里除了记录面积，还需要记录当前的独立的岛屿是否访问过，如果访问过也不能添加，同时每次遍历的过程中要清空访问记录重置一下</p><p>下面的代码不幸的超时了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时了一会</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        self.area = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        tag = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                    tmp = self.bfs(grid, visited, i, j, tag)</span><br><span class="line">                    self.area[tag].append(tmp)</span><br><span class="line">                    self.area[tag].append(<span class="literal">False</span>)</span><br><span class="line">                    tag += <span class="number">1</span></span><br><span class="line">        print(self.area)  <span class="comment"># &#123;2: 3, 3: 3&#125;</span></span><br><span class="line">        singleMaxArea = <span class="built_in">max</span>(self.area[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> self.area) <span class="keyword">if</span> self.area <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> grid:</span><br><span class="line">            print(g)</span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> self.area.values():</span><br><span class="line">                        v[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                    tmpArea = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                        <span class="keyword">if</span> i + dx &lt; <span class="number">0</span> <span class="keyword">or</span> i + dx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j + dy &lt; <span class="number">0</span> <span class="keyword">or</span> j + dy &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> grid[i + dx][j + dy] <span class="keyword">in</span> self.area <span class="keyword">and</span> <span class="keyword">not</span> self.area[grid[i + dx][j + dy]][<span class="number">1</span>]:</span><br><span class="line">                            tmpArea += self.area[grid[i + dx][j + dy]][<span class="number">0</span>]</span><br><span class="line">                            self.area[grid[i + dx][j + dy]][<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># print(tmpArea)</span></span><br><span class="line">                    maxArea = <span class="built_in">max</span>(maxArea, tmpArea)</span><br><span class="line">        <span class="keyword">return</span> maxArea <span class="keyword">if</span> maxArea != <span class="number">0</span> <span class="keyword">else</span> singleMaxArea</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, visited, x, y, tag</span>):</span></span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        queue = deque([(x, y)])</span><br><span class="line">        visited[x][y] = <span class="literal">True</span></span><br><span class="line">        grid[x][y] = tag</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                nextx = x + dx</span><br><span class="line">                nexty = y + dy</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    grid[nextx][nexty] = tag</span><br><span class="line">                    queue.append((nextx, nexty))</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># grid = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]</span></span><br><span class="line">    <span class="comment"># grid = [[1, 1], [1, 1]]</span></span><br><span class="line">    <span class="comment"># grid = [[0, 0], [0, 0]]</span></span><br><span class="line">    grid = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">    print(s.largestIsland(grid))</span><br></pre></td></tr></table></figure><p>正确的思路：第一次遍历将所有的岛屿全部统计出来并使用哈希表进行记录，同时对各个岛屿从2开始进行编号，哈希表中的数据为：{2: 10, 3: 5}这样。然后遍历所有grid[i][j]==0的水域，检查将其赋值为1后，与上下左右的四个位置对应的岛屿面积之和进行累加，得到最终的人工岛的面积，求出来的最大值就是最终的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        self.area = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        tag = <span class="number">2</span></span><br><span class="line">        <span class="comment"># 遍历矩阵，统计其中的岛屿面积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                    tmp = self.bfs(grid, visited, i, j, tag)</span><br><span class="line">                    self.area[tag] = tmp</span><br><span class="line">                    tag += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(self.area)  # &#123;2: [3,False], 3: [3,False]&#125;</span></span><br><span class="line">        <span class="comment"># 同来解决全部是0的情况</span></span><br><span class="line">        singleMaxArea = <span class="built_in">max</span>(self.area[i] <span class="keyword">for</span> i <span class="keyword">in</span> self.area.keys()) <span class="keyword">if</span> self.area <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># for g in grid:</span></span><br><span class="line">        <span class="comment">#     print(g)</span></span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 每轮进行初始化</span></span><br><span class="line">                    mset = <span class="built_in">set</span>()</span><br><span class="line">                    tmpArea = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                        nextx = i + dx</span><br><span class="line">                        nexty = j + dy</span><br><span class="line">                        <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        mset.add(grid[nextx][nexty])</span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> mset:</span><br><span class="line">                        tmpArea += self.area.get(m, <span class="number">0</span>)</span><br><span class="line">                    maxArea = <span class="built_in">max</span>(maxArea, tmpArea)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># print(tmpArea)</span></span><br><span class="line">        <span class="keyword">return</span> maxArea <span class="keyword">if</span> maxArea != <span class="number">0</span> <span class="keyword">else</span> singleMaxArea</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, visited, x, y, tag</span>):</span></span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        queue = deque([(x, y)])</span><br><span class="line">        visited[x][y] = <span class="literal">True</span></span><br><span class="line">        grid[x][y] = tag</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                nextx = x + dx</span><br><span class="line">                nexty = y + dy</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[nextx][nexty]:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">True</span></span><br><span class="line">                    grid[nextx][nexty] = tag</span><br><span class="line">                    queue.append((nextx, nexty))</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure><h2 id="463、岛屿的周长"><a href="#463、岛屿的周长" class="headerlink" title="463、岛屿的周长"></a>463、岛屿的周长</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202402042205818.png" alt="image-20240204220535567"></p><p>方法1：当碰到水域或者边界处则周长加1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">islandPerimeter</span>(<span class="params">self, grid</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:  <span class="comment"># 岛屿</span></span><br><span class="line">                    <span class="comment"># 遍历四周是海洋还是岛屿</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                        nextx = i + dx</span><br><span class="line">                        nexty = j + dy</span><br><span class="line">                        <span class="keyword">if</span> (</span><br><span class="line">                            nextx &lt; <span class="number">0</span></span><br><span class="line">                            <span class="keyword">or</span> nextx &gt;= m</span><br><span class="line">                            <span class="keyword">or</span> nexty &lt; <span class="number">0</span></span><br><span class="line">                            <span class="keyword">or</span> nexty &gt;= n</span><br><span class="line">                            <span class="keyword">or</span> grid[nextx][nexty] == <span class="number">0</span></span><br><span class="line">                        ):</span><br><span class="line">                            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>本题无须进行BFS或者DFS遍历，直接扫描整个表即可</p><p>有下面几种情况：</p><ul><li>nextx&lt;0</li><li>nextx&gt;=len(grid)</li><li>nexty&lt;0</li><li>nexty&gt;=len(grid[0])</li><li>grid[nextx][nexty]==0岛屿旁边为水域 需要将周长加1</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405041549007.png" alt="image-20240504154904217"></p><p>方法2：计算岛屿数量和相邻的岛屿数量</p><p>遍历整个图，碰到<code>grid[i][j]==1</code>，则将岛屿数量加1，然后再对该点上下左右四个区域分别进行校验是否是岛屿，进行累加计算出相邻的岛屿数量</p><p>最终岛屿数量*4-相邻岛屿的数量就是岛屿的周长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># self.direction = [(0, 1), (1, 0)]</span></span><br><span class="line">        self.direction = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">islandPerimeter</span>(<span class="params">self, grid</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span>  <span class="comment"># 记录岛屿的数量</span></span><br><span class="line">        adj = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.direction:</span><br><span class="line">                        nextx = i + dx</span><br><span class="line">                        nexty = j + dy</span><br><span class="line">                        <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= m <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &gt;= n:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> grid[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                            adj += <span class="number">1</span></span><br><span class="line">        print(res, adj)</span><br><span class="line">        <span class="keyword">return</span> res * <span class="number">4</span> - adj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># grid = [[1]]</span></span><br><span class="line">    grid = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">    print(Solution().islandPerimeter(grid))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405051952018.png" alt="image-20240505195213775"></p><h2 id="127、单词接龙"><a href="#127、单词接龙" class="headerlink" title="127、单词接龙"></a>127、单词接龙</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131603774.png" alt="image-20240513160357495"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131604080.png" alt="image-20240513160413580"></p><p>主要需要解决两个问题：</p><ul><li><p>单词如何作为图连接起来</p><ul><li>首先转换为列表，然后通过遍历单词中的每一位字母，然后再进行单词的替换【for循环26次】</li></ul></li><li><p>起点和终点的最短路径长度</p><ul><li>BFS如果遍历到终点就结束</li></ul></li></ul><p>哈希表<code>myhash</code>用来记录单词与其对应的变化的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList</span>) -&gt; int:</span></span><br><span class="line">        wordset = <span class="built_in">set</span>(wordList)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordset:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        myhash = &#123;beginWord: <span class="number">1</span>&#125;</span><br><span class="line">        queue = deque([beginWord])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            word = queue.popleft()</span><br><span class="line">            path = myhash[word]  <span class="comment"># 记录当前的步数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):  <span class="comment"># 遍历所有单词</span></span><br><span class="line">                word_list = <span class="built_in">list</span>(word)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                    <span class="keyword">if</span> word_list[i] == <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>) + j):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    word_list[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>) + j)  <span class="comment"># 修改单词</span></span><br><span class="line">                    new_word = <span class="string">&quot;&quot;</span>.join(word_list)</span><br><span class="line">                    <span class="keyword">if</span> new_word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> path + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordset <span class="keyword">and</span> new_word <span class="keyword">not</span> <span class="keyword">in</span> myhash:</span><br><span class="line">                        myhash[new_word] = path + <span class="number">1</span></span><br><span class="line">                        queue.append(new_word)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405040942081.png" alt="单词接龙"></p><h2 id="126、单词接龙II"><a href="#126、单词接龙II" class="headerlink" title="126、单词接龙II"></a>126、单词接龙II</h2><p>本题和上一题的区别就在于需要找到所有的最短路径</p><h2 id="841、钥匙和房间"><a href="#841、钥匙和房间" class="headerlink" title="841、钥匙和房间"></a>841、钥匙和房间</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131650630.png" alt="image-20240513165027044"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131650364.png" alt="image-20240513165040085"></p><p>采用dfs进行遍历，看所有的房间是否都可以被访问，使用visited数组来表示每个房间是否已经被访问通过，通过dfs遍历之后，只需要判断visited数组是否全部已经访问即可判断所有的房间是否能进入。</p><p>注意这里使用<code>all()</code>函数，<code>all()</code>函数的含义是判断传入的可迭代对象是否全部都是True，如果全部为True则返回Ture，否则返回False</p><p>这里处理的是当前节点，或者可以采用处理下一个结点的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, rooms, key, visited</span>):</span></span><br><span class="line">        <span class="keyword">if</span> visited[key]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[key] = <span class="literal">True</span></span><br><span class="line">        keys = rooms[key]</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            self.dfs(rooms, key, visited)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span>(<span class="params">self, rooms</span>) -&gt; bool:</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * <span class="built_in">len</span>(rooms)</span><br><span class="line">        self.dfs(rooms, <span class="number">0</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(visited)</span><br></pre></td></tr></table></figure><p>处理下一个结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, rooms, key, visited</span>):</span></span><br><span class="line">        keys = rooms[key]</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[key]:</span><br><span class="line">                visited[key] = <span class="literal">True</span></span><br><span class="line">                self.dfs(rooms, key, visited)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span>(<span class="params">self, rooms</span>) -&gt; bool:</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * <span class="built_in">len</span>(rooms)</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        self.dfs(rooms, <span class="number">0</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(visited)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131650357.png" alt="image-20240513165058165"></p><h2 id="1971、寻找图中是否存在路径"><a href="#1971、寻找图中是否存在路径" class="headerlink" title="1971、寻找图中是否存在路径"></a>1971、寻找图中是否存在路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131651900.png" alt="image-20240513165127395"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131651119.png" alt="image-20240513165143136"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131651674.png" alt="image-20240513165157570"></p><p>本题属于并查集的问题，需要判断起点和终点的根结点是否是同一个，本质上类似于并查集模板中<code>isSame()</code>函数所干的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPath</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: List[List[<span class="built_in">int</span>]], source: <span class="built_in">int</span>, destination: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        graph = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]   <span class="comment"># 初始化一个father数组</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> graph[x] != x:</span><br><span class="line">                graph[x] = find(graph[x])</span><br><span class="line">            <span class="keyword">return</span> graph[x]</span><br><span class="line">        <span class="comment"># 实现join方法</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            graph[find(x)] = find(y)</span><br><span class="line">        <span class="comment"># 这里是isSame()方法</span></span><br><span class="line">        <span class="keyword">return</span> find(source) == find(destination)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405061031607.png" alt="寻找图中是否存在路径"></p><h2 id="684、冗余连接"><a href="#684、冗余连接" class="headerlink" title="684、冗余连接"></a><a href="https://leetcode.cn/problems/redundant-connection/">684、冗余连接</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131652590.png" alt="image-20240513165241620"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405131652471.png" alt="image-20240513165256804"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span>(<span class="params">self, edges</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        graph = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x != graph[x]:</span><br><span class="line">                graph[x] = find(graph[x])</span><br><span class="line">            <span class="keyword">return</span> graph[x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> graph[find(u)] == find(v):</span><br><span class="line">                <span class="keyword">return</span> [u, v]</span><br><span class="line">            graph[find(u)] = find(v)</span><br></pre></td></tr></table></figure><h2 id="685、冗余连接II"><a href="#685、冗余连接II" class="headerlink" title="685、冗余连接II"></a>685、冗余连接II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405141130049.png" alt="冗余连接II"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405141131350.png" alt="image-20240514113128376"></p><p>本题和冗余连接的区别在于从无向图转变为了有向图，本题中存在三种情况：</p><ul><li>所有节点入度均为2<ul><li><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405151641509.png" alt="img"></li><li></li></ul></li><li>所有节点入度均为1，但是存在环结构<ul><li><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405151641719.png" alt="img"></li></ul></li></ul><p>计算入度：</p><p>使用一个indegree列表，其长度为<code>len(edges)+1</code>【这是因为需要下标和节点进行对应，题目中没有0号节点】，只需要对edges列表进行遍历，对edges[i][1]所指向的节点值加1</p><p>做题整体思路：</p><ul><li>首先遍历所有的节点，记录入度</li><li>将所有入度为2的顶点（对应的边的在edge中的下标）加入到<code>vec</code>列表中【题目说了如果一样的情况下优先输出后一条边，所以进行逆序遍历】</li><li>判断<code>vec</code>长度是否超过0，如果超过0说明对应的是第一种入度为2的情况<ul><li>这个时候需要判断删除入度为2的这条边之后的情况【题目限制本题最多只有两条边对应入度为2】</li><li>先判断删除第一条边之后是否还是树【调用方法<code>isTreeAfterRemoveEdge()</code>】，如果是则返回<code>edges[vec[0]]</code>，否则返回<code>edges[vec[1]]</code></li></ul></li><li>否则对应的是入度为1的情况<ul><li>寻找树中的环路进行判断<code>getRemovedEdge()</code>，判断删除其中的边是否依旧是一棵树</li></ul></li></ul><p>这里在进行判断的时候<code>isTreeAfterRemoveEdge()</code>和<code>getRemovedEdge()</code>方法都是依赖于并查集的，需要在检查的过程中构建并查集即<code>join()</code>方法</p><p>其中<code>isTreeAfterRemoveEdge()</code>方法的实现如下：</p><p>遍历的过程中对非删除的边进行构造并查集，先去判断顶点之间是否存在相同的父节点，如果存在则直接返回False，否则将其添加到并查集中，如果循环结束依旧没有返回<code>False</code>则返回<code>True</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isTreeAfterRemoveEdge</span>(<span class="params">self, edges, index</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(edges)):</span><br><span class="line">        <span class="keyword">if</span> i == index:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> self.isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.join(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><code>getRemovedEdge()</code>方法的实现如下：</p><p>在遍历的过程中进行判断两个顶点是否已经存在于并查集中了，如果存在则直接返回这条边，否则将两个顶点添加到并查集中，如果循环结束依旧没有return，则直接返回空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRemovedEdge</span>(<span class="params">self, edges</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(edges)):</span><br><span class="line">        <span class="keyword">if</span> self.isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> edges[i]</span><br><span class="line">        self.join(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.n = <span class="number">1001</span></span><br><span class="line">        self.father = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, u</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.father[u] != u:</span><br><span class="line">            self.father[u] = self.find(self.father[u])</span><br><span class="line">        <span class="keyword">return</span> self.father[u]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        u = self.find(u)</span><br><span class="line">        v = self.find(v)</span><br><span class="line">        <span class="keyword">if</span> u == v:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.father[v] = u</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSame</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantDirectedConnection</span>(<span class="params">self, edges</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        <span class="comment"># 将所有入度为2的节点记录下来</span></span><br><span class="line">        indgree = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># 因为节点编号是从1到n，所以0号下标忽略 列表长度为n+1</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            indgree[edge[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(indgree)</span></span><br><span class="line">        vec = []  <span class="comment"># 存放的是边在edges列表中的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> indgree[edges[i][<span class="number">1</span>]] == <span class="number">2</span>:</span><br><span class="line">                vec.append(i)</span><br><span class="line">        <span class="comment"># print(vec)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(vec) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 说明存在入度为2的顶点 需要删除边进行判断了</span></span><br><span class="line">            <span class="keyword">if</span> self.isTreeAfterRemoveEdge(edges, vec[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">return</span> edges[vec[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> edges[vec[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 剩余的情况：没有入度为2的顶点 一定存在环 需要删除环中的一条边</span></span><br><span class="line">        <span class="keyword">return</span> self.getRemovedEdge(edges)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断删除指定边之后是否仍然构成树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isTreeAfterRemoveEdge</span>(<span class="params">self, edges, index</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(edges)):</span><br><span class="line">            <span class="keyword">if</span> i == index:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self.join(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRemovedEdge</span>(<span class="params">self, edges</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(edges)):</span><br><span class="line">            <span class="keyword">if</span> self.isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> edges[i]</span><br><span class="line">            self.join(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405151639840.png" alt="image-20240515163954839"></p><h2 id="LCR-116-省份数量"><a href="#LCR-116-省份数量" class="headerlink" title="LCR 116. 省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/">LCR 116. 省份数量</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405071629775.png" alt="image-20240507162944560"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405071631302.png" alt="image-20240507163127242"></p><p>本题的含义就是去找整个图中的联通分量的个数，就看需要进行多少次DFS即可，或者采用BFS的方式也是一样的思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_BFS</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 用来防止出现单独的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                self.bfs(i, isConnected, n, queue, visited)</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, i, isConnected, n, queue, visited</span>):</span></span><br><span class="line">        queue.append(i)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[cur][j] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[j]:</span><br><span class="line">                    queue.append(j)</span><br><span class="line">                    visited[j] = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, i, visited, isConnected</span>):</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[j]:</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">                self.dfs(j, visited, isConnected)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                self.dfs(i, visited, isConnected)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><p>本题是一个经典的拓扑排序问题，其中解决方法如下：</p><ul><li>如果满足拓扑排序，那么其经过的次数最终应该就是拓扑排序的次数【BFS】</li><li>通过dfs判断有向图中是否存在环路【DFS】</li></ul><p>方法一：</p><ol><li>首先生成一个入度表<code>indegrees</code></li><li>使用一个队列<code>queue</code>，将所有入度为0的节点入队</li><li>当<code>queue</code>不为空时，依次将堆首节点出队，在课程安排图中删除此节点<code>pre</code><ul><li>并不是真正从邻接表中删除此节点，而是将此节点对应的入度-1。</li><li></li></ul></li><li>在每次pre出队时，执行<code>numCourses--</code></li></ol><p>拓扑排序的次数等于课程个数，最后只需要判断<code>numCourses==0</code>即可判断是否成功安排课程表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]: <span class="comment"># 入度也为0的 加入</span></span><br><span class="line">                    queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051525379.png&quot; alt=&quot;image-20240305152551079&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;图论&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
    <category term="图" scheme="https://guoxiansen.github.io/tags/%E5%9B%BE/"/>
    
    <category term="DFS" scheme="https://guoxiansen.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://guoxiansen.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="https://guoxiansen.github.io/2024/04/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>https://guoxiansen.github.io/2024/04/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</id>
    <published>2024-04-29T02:54:17.000Z</published>
    <updated>2024-05-29T12:59:01.303Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191636043.png" alt="image-20240519163601830"></p><h1 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h1><p>滑动窗口主要解决子数组或者子串问题，其优点是可以避免暴力算法导致的<code>O(n²)</code>的时间复杂度，降低时间复杂度到<code>O(n)</code>。</p><p>滑动窗口的代码模板如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口算法框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slidingWindow</span>(<span class="params">s: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="comment"># 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment"># 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment"># 我想记录窗口中的元素和，就用 int</span></span><br><span class="line">    window = <span class="built_in">dict</span>()</span><br><span class="line">    </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># c 是将移入窗口的字符</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 增大窗口</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment"># 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment"># 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="comment"># print(f&quot;window: [&#123;left&#125;, &#123;right&#125;)&quot;)</span></span><br><span class="line">        <span class="comment">#/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="string">&quot;window needs shrink&quot;</span>:</span><br><span class="line">            <span class="comment"># d 是将移出窗口的字符</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            window[d] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[d] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> window[d]</span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滑动窗口需要关注的几个点：</p><ul><li></li><li></li></ul><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="76、最小覆盖子串"><a href="#76、最小覆盖子串" class="headerlink" title="76、最小覆盖子串"></a>76、最小覆盖子串</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191452671.png" alt="最小覆盖子串"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191452468.png" alt="题目条件"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        window = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        need = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> t:</span><br><span class="line">            need[ch] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        start, length = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window[c] += 1</span></span><br><span class="line">            <span class="comment"># print(window)</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">                window[c] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 只有字符串字符串长度更短才会进行更新</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt; length:</span><br><span class="line">                    start, length = left, right - left</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(window)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> length == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> s[start:start + length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&quot;ADOBECODEBANC&quot;</span></span><br><span class="line">    t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    print(Solution().minWindow(s, t))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191451964.png" alt="image-20240519145147478"></p><h2 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191552148.png" alt="image-20240519155204142"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        window = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            window[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> window[c] &gt; <span class="number">1</span>:</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">            length = <span class="built_in">max</span>(length, right - left)</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191552032.png" alt="image-20240519155231234"></p><h2 id="567、字符串的排列"><a href="#567、字符串的排列" class="headerlink" title="567、字符串的排列"></a>567、字符串的排列</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191605716.png" alt="image-20240519160518124"></p><p>题目中说s2是否包含s1的排列，实际上只需要判断<code>s2</code>和<code>s1</code>中相同字母的个数是否相等即可，这里通过2个字典<code>window</code>与<code>need</code>和一个<code>valid</code>进行维护。</p><ul><li>window：窗口为当前的字符与其对应的个数</li><li>need：字符串<code>s1</code>的所有字符与其个数</li><li>valid：为<code>window</code>和<code>need</code>中是字符个数是否相等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        window, need = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">            need[ch] += <span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            c = s2[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">                window[c] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right - left &gt;= <span class="built_in">len</span>(s1):</span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                d = s2[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.checkInclusion(s1=<span class="string">&quot;ab&quot;</span>, s2=<span class="string">&quot;eidbcaooo&quot;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405192204981.png" alt="image-20240519220402320"></p><h2 id="438、找到字符串中所有字母异位词"><a href="#438、找到字符串中所有字母异位词" class="headerlink" title="438、找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438、找到字符串中所有字母异位词</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191612286.png" alt="image-20240519161212003"></p><p>整体思路与字符串排列相同，区别就在于需要找到所有的结果，只需要用一个列表进行接收即可。</p><p>其中第二个while循环是为了缩小窗口，获得最终正确的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        window, need = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> p:</span><br><span class="line">            need[ch] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">                window[c] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right - left &gt;= <span class="built_in">len</span>(p):</span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                    res.append(left)</span><br><span class="line">                d = s[left]</span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&quot;cbaebabacd&quot;</span></span><br><span class="line">    p = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    print(Solution().findAnagrams(s, p))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191626897.png" alt="image-20240519162616071"></p><h2 id="239、滑动窗口的最大值"><a href="#239、滑动窗口的最大值" class="headerlink" title="239、滑动窗口的最大值"></a>239、滑动窗口的最大值</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405260943370.png" alt="滑动窗口的最大值"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405260944660.png" alt="滑动窗口的最大值2"></p><p>思路：使用单调队列，维持里面的最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myqueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue = deque()  <span class="comment"># 单调队列 只记录窗口中的最大最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.queue <span class="keyword">and</span> self.queue[-<span class="number">1</span>] &lt; val:</span><br><span class="line">            self.queue.pop()</span><br><span class="line">        self.queue.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.queue <span class="keyword">and</span> self.queue[<span class="number">0</span>] == val:</span><br><span class="line">            self.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMax</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        mq = Myqueue()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            mq.push(nums[i])</span><br><span class="line">        <span class="comment"># print(mq.queue)</span></span><br><span class="line">        res.append(mq.getMax())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            mq.pop(nums[i - k])</span><br><span class="line">            mq.push(nums[i])</span><br><span class="line">            res.append(mq.getMax())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="1052、爱生气的书店老板"><a href="#1052、爱生气的书店老板" class="headerlink" title="1052、爱生气的书店老板"></a>1052、爱生气的书店老板</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405272107531.png" alt="image-20240527210704040"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, customers: List[<span class="built_in">int</span>], grumpy: List[<span class="built_in">int</span>], minutes: <span class="built_in">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param customers:顾客数量</span></span><br><span class="line"><span class="string">        :param grumpy: 生气</span></span><br><span class="line"><span class="string">        :param minutes: 老板可以保持这个分钟数不生气</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(customers)):</span><br><span class="line">            <span class="keyword">if</span> grumpy[i] == <span class="number">0</span>:</span><br><span class="line">                res += customers[i]</span><br><span class="line">                customers[i] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(customers)</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        max_res = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(customers):</span><br><span class="line">            <span class="comment"># if right - left &lt; minutes:</span></span><br><span class="line">            cur += customers[right]</span><br><span class="line">            <span class="comment"># print(queue)</span></span><br><span class="line">            <span class="comment"># queue.append(customers[right])</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left &gt; minutes:</span><br><span class="line">                cur -= customers[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># queue.popleft()</span></span><br><span class="line">            max_res = <span class="built_in">max</span>(max_res, cur)</span><br><span class="line">        <span class="comment"># print(max_res)</span></span><br><span class="line">        <span class="keyword">return</span> res + max_res</span><br></pre></td></tr></table></figure><p>反过来的思路：求最大反过来求最小或者求最小反过来求最大</p><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></p><p>最后的牌肯定连续，需要点数最大，则最后连续的牌值越小，过来求滑动窗口的最小值即可。</p><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></p><p>本题思路是求连续生气的中长度为minute的最大子数组之和。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202405191636043.png&quot; alt=&quot;image-20240519163601830&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;滑动窗口问题</summary>
      
    
    
    
    
    <category term="滑动窗口" scheme="https://guoxiansen.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>为什么Cookie无法防止CSRF攻击而Token可以？</title>
    <link href="https://guoxiansen.github.io/2024/04/27/%E4%B8%BA%E4%BB%80%E4%B9%88Cookie%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB%E8%80%8CToken%E5%8F%AF%E4%BB%A5%EF%BC%9F/"/>
    <id>https://guoxiansen.github.io/2024/04/27/%E4%B8%BA%E4%BB%80%E4%B9%88Cookie%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB%E8%80%8CToken%E5%8F%AF%E4%BB%A5%EF%BC%9F/</id>
    <published>2024-04-27T05:23:35.000Z</published>
    <updated>2024-05-09T08:22:36.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么Cookie无法防止CSRF攻击而Token可以？"><a href="#为什么Cookie无法防止CSRF攻击而Token可以？" class="headerlink" title="为什么Cookie无法防止CSRF攻击而Token可以？"></a>为什么Cookie无法防止CSRF攻击而Token可以？</h1><h2 id="CSRF介绍"><a href="#CSRF介绍" class="headerlink" title="CSRF介绍"></a>CSRF介绍</h2><p>CSRF（Cross Site Request Forgery）：跨站请求伪造，属于网络攻击领领域范畴。相比于SQL脚本注入、XSS攻击等安全攻击方式，CSRF的知名度并没有他们高，但是它确实是我们开发系统时必须要考虑的安全隐患。</p><p>什么是CSRF呢？</p><p>简单来说，就是黑客利用你的身份信息去做一些非法的事情，例如将你的钱转走、发邮件、发消息等</p><p>CSRF攻击需要依赖于Cookie，Session</p><p>Cookie中会存放SessionID，</p><h2 id="CSRF攻击流程"><a href="#CSRF攻击流程" class="headerlink" title="CSRF攻击流程"></a>CSRF攻击流程</h2><p>流程：</p><ol><li>客户端通过账户密码登录访问网站A</li><li>网站A验证客户端的账号密码，成功则生成一个sessionID，并返回给客户端存储在浏览器中</li><li>该客户端Tab一个新页面访问了网站B</li><li>网站B自动触发要求该客户端访问网站A（网站B中有链接指向网站A）</li><li>客户端通过网站B中的链接访问网站A（此时携带有合法的SessionID进行访问站A）</li><li>此时网站A只需要校验sessionID是否合法，若合法则执行相应的操作</li></ol><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>防御CSRF攻击的方法：</p><ul><li>在请求地址中添加token并验证</li><li>验证 HTTP Referer 字段<ul><li>这个字段可以用来识别这个请求的来源，这样来自第三方的就可以拒绝了</li></ul></li><li>JWT校验</li></ul><p>传统方案：使用Cookie</p><p>通常Cookie会搭配Session使用，由于http请求是无状态的，服务器需要识别客户端的身份，例如常见的购物车功能，所以使用SessionID</p><p>可以使用cookie在用户登录之后保存用户的登录状态</p><h2 id="JWT为什么安全"><a href="#JWT为什么安全" class="headerlink" title="JWT为什么安全"></a>JWT为什么安全</h2><p>JWT一般存放在localStorage中，前端的每一个请求都会带上该JWT，整个过程中不涉及到Cookie，如果此时点击了非法请求，非法请求是无法携带JWT的，攻击者无法获取到或者伪造token，因此可以有效的防止csrf攻击。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么Cookie无法防止CSRF攻击而Token可以？&quot;&gt;&lt;a href=&quot;#为什么Cookie无法防止CSRF攻击而Token可以？&quot; class=&quot;headerlink&quot; title=&quot;为什么Cookie无法防止CSRF攻击而Token可以？&quot;&gt;&lt;/a&gt;为什</summary>
      
    
    
    
    
    <category term="CSRF" scheme="https://guoxiansen.github.io/tags/CSRF/"/>
    
    <category term="安全" scheme="https://guoxiansen.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>八股整理</title>
    <link href="https://guoxiansen.github.io/2024/04/26/%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/"/>
    <id>https://guoxiansen.github.io/2024/04/26/%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/</id>
    <published>2024-04-26T14:29:25.000Z</published>
    <updated>2024-04-26T14:30:10.381Z</updated>
    
    <content type="html"><![CDATA[<p>1.redis的集群模式</p><p>2.redis的持久化策略</p><p>3.内存淘汰策略</p><p>4.redis hash的底层结构</p><p>5.redis string底层结构</p><p>6.redis实现分布式锁，以及setnx可能存在的问题</p><p>7.spring和springboot的区别</p><p>8.springboot注入类有哪些注解，有什么区别</p><p>9.spring aop如何实现</p><p>10.动态代理有几种实现方式</p><p>11.mybatis #和$的区别</p><p>12.mysql如何选择建立哪些索引</p><p>13.mysql为什么用b+树</p><p>14.mysql有哪些锁</p><p>15.https中用到了哪些加密算法</p><p>16.tcp的粘包问题</p><p>17.linux如何查看文件</p><p>18.java锁的可重入和公平性</p><p>19.java线程的生命周期</p><p>20.wait和sleep的区别</p><p>21.什么是死锁，如何用java写个死锁</p><p>22.jvm的内存模型</p><p>23.年轻代垃圾回收算法</p><p>24.树的遍历</p><p>25.一致性哈希算法</p><p>26.编程题，字符串匹配，说可以直接暴力</p><p>二面</p><p>1.介绍部门业务</p><p>2.拷打项目</p><p>3.数据库事务的特性</p><p>4.如何实现持久性</p><p>5.binlog和redolog的区别</p><p>6.undolog</p><p>7.undolog提到了mvcc，让我介绍一下mvcc</p><p>8.什么是幻读</p><p>9.怎么解决幻读</p><p>10.mysql索引原理</p><p>11.b+树查数据的过程，b+树大概有多少叉（多少个子节点）</p><p>12.b+树的范围查询</p><p>13.b+树和b树的区别</p><p>14.主键如何设计</p><p>15.什么是RPC</p><p>16.进程间通信的方式有哪些</p><p>17.tcp四次挥手</p><p>18.编程题：区间合并</p><hr><h1 id="Java面试题整理2024"><a href="#Java面试题整理2024" class="headerlink" title="Java面试题整理2024"></a>Java面试题整理2024</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p>面向对象</p><p>JDK、JRE、JVM之间的区别</p><p> jdk包含jre包含jvm</p><p>==和equals方法之间的区别</p><p>hashCode()和eequals()之间的关系</p><p>final关键字的作用是什么</p><p>String、StringBuffer、StringBuider的区别</p><p>重载和重写的区别</p><p>接口和抽象类的区别</p><p>List和Set的区别</p><p>ArrayList和LinkedList区别</p><p>HashMap和HashTable有什么区别？底层实现是什么？</p><p>谈谈concurrentHashMap的扩容机制</p><p>Jdk1.7到Jdk1.8 HashMap 发生了什么变化(底层)</p><p>说一下HashMap的put方法</p><p>范型中extends和super的区别</p><p>深拷贝和浅拷贝</p><p>HashMap的扩容机制原理</p><p>CopyOnWriteArrayList的底层原理是怎么样的</p><p>什么是字节码？采用字节码的好处是什么</p><p>Java中的异常体系是怎么样的</p><p>Java中有哪些类加载器</p><p>说说类加载器双亲委派模型</p><p>GC如何判断对象可以被回收</p><p>JVM中哪些是线程共享区</p><p>你们项目中如何排查JVM问题</p><p>一个对象从加载到JVM，再到被GC清除，都经历了什么过程</p><p>怎么确定一个对象到底是不是垃圾</p><p>JVM有哪些垃圾回收算法</p><p>什么是STW</p><p>JVM有哪些垃圾回收器</p><p>垃圾回收分为哪些阶段</p><p>什么是三色标记</p><p>JVM参数有哪些</p><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><p>线程的生命周期？线程有几种状态</p><p>Sleep()、Wait()、join()、yield()之间的区别</p><p>对线程安全的理解</p><p>Thread和Runable的区别</p><p>对守护线程的理解</p><p>ThreadLocal的底层原理</p><p>并发、并行、串行之间的区别</p><p>并发的三大特性</p><p>Java死锁如何避免</p><p>如何理解volatile关键字</p><p>为什么用线程池？解释下线程池的参数?</p><p>线程池的底层工作原理</p><p>线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</p><p>线程池中线程复用原理</p><p>ReentrantLock中公平锁和非公平锁的底层实现</p><p>ReentrantLock中tryLock()和lock()方法的区别</p><p>CountDownLatch和Semaphore的区别和底层原理</p><p>Synchronized的偏向锁、轻量级锁和重量级锁</p><p>Synchronized和ReentrantLock的区别</p><p>谈谈你对AQS的理解，AQS如何实现可重入锁</p><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>Spring是什么？</p><p>谈谈你对AOP的理解</p><p>谈谈你对IOC的理解</p><p>解释下Spring支持的几种bean的作用域</p><p>spring事务的实现方式和原理以及隔离级别</p><p>spring事务传播机制</p><p>spring事务什么时候会失效</p><p>什么是bean的自动装配，有哪些方式</p><p>spring中bean的创建的生命周期有哪些步骤</p><p>spring中bean是线程安全的吗</p><p>ApplicationContext和BeanFactory有什么区别</p><p>spring中的事务如何实现的</p><p>spring什么时候@transactional会失效</p><p>spring容器启动流程是怎么样的</p><p>spring用到了哪些设计模式</p><p>springboot、springmvc和spring的区别</p><p>springMVC工作流程</p><p>springMVC的主要组件</p><p>springboot自动配置原理</p><p>如何理解springboot中的starter</p><p>什么是嵌入式服务器？为什么要使用嵌入式服务器</p><p>springboot中常用注解及其底层实现</p><p>springboot是如何启动tomcat的</p><p>springboot中配置文件的加载顺序是怎么样的</p><p>mybatis的优缺点</p><p>mybatis和hibernate有哪些不同</p><p>#{}和${}的区别是什么</p><p>简述Mybatis的插件运行原理，如何编写一个插件</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>ACID靠什么保证的</p><p>什么是MVCC</p><p>分表后非shading_key的查询怎么样处理，分表后的排序</p><p>MySQL主从同步原理</p><p>简述MyISAM和InnoDB的区别</p><p>简述MySQL中索引类型及对数据库的性能的影响</p><p>Explain语句结果中各个字段分表表示什么</p><p>索引覆盖是什么</p><p>最左前缀原则是什么</p><p>Innodb是如何实现事务的</p><p>B树和B+树的区别，为什么MySQL使用B+树</p><p>MySQL锁有哪些，该如何理解</p><p>MySQL慢查询该如何优化</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>什么是RDB和AOF</p><p>Redis的过期键的删除策略</p><p>Redis线程模型、单线程快的原因</p><p>简述Redis事务实现</p><p>Redis主从复制的核心原理</p><p>Redis有哪些数据结构？分别有哪些典型的应用场景？</p><p>Redis分布式锁底层是如何实现的？</p><p>Redis集群策略</p><p>缓存穿透、缓存击穿、缓存雪崩分别是什么</p><p>Redis和MySQL如何保证数据的一致</p><p>Redis的持久化机制</p><p>Redis单线程为什么这么快</p><p>简述Redis事务实现</p><h2 id="分布式与微服务"><a href="#分布式与微服务" class="headerlink" title="分布式与微服务"></a>分布式与微服务</h2><p>什么是CAP理论</p><p>什么是BASE理论</p><p>什么是RPC</p><p>数据一致性模型有哪些</p><p>分布式ID是什么？有哪些解决方案？</p><p>分布式锁的使用场景是什么？有哪些实现方案？</p><p>什么是分布式事务？有哪些实现方案？</p><p>什么是ZAB协议</p><p>简述paxos算法</p><p>简述raft算法</p><p>为什么Zookeeper可以用来作为注册中心</p><p>Zookeeper中的领导者选举的流程是怎样的</p><p>Zookeeper集群中节点之间数据是如何同步的</p><p>Dubbo支持哪些负载均衡策略</p><p>Dubbo是如何完成服务导出的</p><p>Dubbo是如何完成服务引入的</p><p>Dubbo的架构设计是怎么样的</p><p>负载均衡算法有哪些</p><p>分布式架构下，Session共享有什么方案</p><p>简述你对RPC、RMI的理解</p><p>如何实现接口的幂等性</p><p>Zookeeper的数据模型和节点类型</p><p>简述Zookeeper的命名服务、配置管理、集群管理</p><p>简述Zookeeper中watch机制</p><p>Zookeeper和Eureka的区别</p><p>如何实现分库分表</p><p>存储拆分后如何解决唯一主键问题</p><p>雪花算法原理</p><p>如何解决不使用分区键的查询原理</p><p>SpringCloud有哪常用组件，作用是什么？</p><p>如何避免缓存穿透、缓存击穿、缓存雪崩？</p><p>分布式系统中常用的缓存方案有哪些</p><p>缓存过期都有哪些策略</p><p>常见的缓存淘汰算法</p><p>布隆过滤器原理，优缺点有哪些。</p><p>分布式缓存寻址算法</p><p>什么是Hystrix？简述实现机制</p><p>SpringCloud和Dubbo有哪些区别</p><p>什么是服务雪崩？什么是服务限流？什么是服务熔断？什么是服务降级？区别是什么</p><p>SOA、分布式、微服务之间有什么关系和区别？</p><p>怎么拆分微服务？</p><p>怎么设计出高内聚、低耦合的微服务</p><p>有没有了解过DDD领域驱动设计</p><p>什么是中台？</p><p>你的项目是怎么保证微服务敏捷开发的？</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>如何进行产品选型？</p><p>简述RabbitMQ的架构设计</p><p>RabbitMQ如何确保消息发送？消息接收？</p><p>RabbitMQ事务消息</p><p>RabbitMQ死信队列、延时队列</p><p>RabbitMQ镜像队列机制</p><p>Kafka是什么</p><p>Kafka为什么吞吐量高</p><p>Kafka的Pull和Push分别有什么优缺点</p><p>为什么要使用Kafka，为什么要使用消息队列？</p><p>Kafka中的ISR、AR代表什么？ISR的伸缩指的是什么</p><p>Kafka高效文件存储设计特点</p><p>Kafka和传统消息系统之间的三个关键区别</p><p>Kafka创建Topic时如何将分区放置在不同的Broker中</p><p>Kafka的消费者如何消费数据</p><p>Kafka消费者负载均衡策略</p><p>Kafka生产数据时数据的分组策略</p><p>Kafka是怎么样体现消息顺序性的</p><p>Kafka如何实现延迟队列</p><p>RocketMQ的事务消息是如何实现的</p><p>为什么RocketMQ不使用Zookeeper作为注册中心</p><p>RocketMQ的实现原理</p><p>RocketMQ为什么速度快</p><p>消息队列如何保证消息可靠传输</p><p>消息队列有哪些作用</p><p>死信队列是什么？延时队列是什么？</p><p>如何保证消息的高效读写？</p><p>让你设计一个MQ，你会如何设计？</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>什么是认证和授权？如何设计一个权限认证框架？</p><p>如果没有Cookie、Session还能进行身份验证吗？</p><p>什么是CRSF攻击？如何防止？</p><p>什么是OAuth2.0 协议？有哪几种认证方式？</p><p>什么是SSO？与OAuth2.0有什么关系？</p><p>如何设计一个开放授权平台？</p><p>epoll和poll的区别</p><p>TCP的三次握手和四次挥手</p><p>浏览器发出一个请求到收到响应经历了哪些步骤？</p><p>跨域请求是什么？有什么问题？怎么解决？</p><p>零拷贝是什么</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.redis的集群模式&lt;/p&gt;
&lt;p&gt;2.redis的持久化策略&lt;/p&gt;
&lt;p&gt;3.内存淘汰策略&lt;/p&gt;
&lt;p&gt;4.redis hash的底层结构&lt;/p&gt;
&lt;p&gt;5.redis string底层结构&lt;/p&gt;
&lt;p&gt;6.redis实现分布式锁，以及setnx可能存在的问题&lt;</summary>
      
    
    
    
    
    <category term="面试" scheme="https://guoxiansen.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股" scheme="https://guoxiansen.github.io/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java与Python对比</title>
    <link href="https://guoxiansen.github.io/2024/04/24/Java%E4%B8%8EPython%E5%AF%B9%E6%AF%94/"/>
    <id>https://guoxiansen.github.io/2024/04/24/Java%E4%B8%8EPython%E5%AF%B9%E6%AF%94/</id>
    <published>2024-04-24T08:14:20.000Z</published>
    <updated>2024-04-25T05:39:29.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java语言与Python对比"><a href="#Java语言与Python对比" class="headerlink" title="Java语言与Python对比"></a>Java语言与Python对比</h1><h2 id="语法和风格"><a href="#语法和风格" class="headerlink" title="语法和风格"></a>语法和风格</h2><p>Java是一种静态类型语言，所有的变量都需要显示的提前声明，并且有严格的语法和规范；</p><p>Python是一种动态类型语言，所有的变量类型都是在运行的时候才确定的，语法更加简洁和灵活</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>Java作为一种编译型语言，性能比较高；而Python作为一种解释型语言，其性能会比较慢。这一点从我平时在leetcode上刷题就可以看出来，相同的实现方式，往往Java速度会更快一些。</p><h2 id="并发和多线程的支持"><a href="#并发和多线程的支持" class="headerlink" title="并发和多线程的支持"></a>并发和多线程的支持</h2><p>Java中提供了完善的并发和多线程的处理能力；而Python由于全局解释器锁的原因，多线程并不能真正实现并行执行，更适合用于I/O密集型任务。其在处理CPU密集型的任务的性能不如Java</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>Java往往应用于例如服务器端开发、大数据处理和安卓领域</p><p>Python更多的用于科学计算、人工智能领域以及一些简单的web开发</p><h2 id="生态系统和库"><a href="#生态系统和库" class="headerlink" title="生态系统和库"></a>生态系统和库</h2><p>二者生态系统都挺完善的，Java有例如Spring一系列的框架，Python也有诸如Django、Flask、FastAPI、Numpy、pandas等框架；二者的社区都很活跃。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java是单继承的，但是可以通过实现接口的方式弥补无法多继承的不足</p><p>Python是多继承的</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Java可以通过垃圾回收机制进行自动内存管理，但是开发者也可以采用手动释放对象的方式加速内存回收</p><p>Python有自动内存管理，开发者不需要进行手动的管理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java语言与Python对比&quot;&gt;&lt;a href=&quot;#Java语言与Python对比&quot; class=&quot;headerlink&quot; title=&quot;Java语言与Python对比&quot;&gt;&lt;/a&gt;Java语言与Python对比&lt;/h1&gt;&lt;h2 id=&quot;语法和风格&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Java" scheme="https://guoxiansen.github.io/tags/Java/"/>
    
    <category term="Python" scheme="https://guoxiansen.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04安装FloodLight最新版本</title>
    <link href="https://guoxiansen.github.io/2024/04/14/Ubuntu20-04%E5%AE%89%E8%A3%85FloodLight%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    <id>https://guoxiansen.github.io/2024/04/14/Ubuntu20-04%E5%AE%89%E8%A3%85FloodLight%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/</id>
    <published>2024-04-14T12:16:38.000Z</published>
    <updated>2024-04-14T12:18:03.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404142017144.png" alt="image-20240414201754826"></p><h1 id="Ubuntu20-04安装FloodLight最新版本"><a href="#Ubuntu20-04安装FloodLight最新版本" class="headerlink" title="Ubuntu20.04安装FloodLight最新版本"></a>Ubuntu20.04安装FloodLight最新版本</h1><blockquote><p>网上的很多教程尝试了一下都不对，并且很多都是基于Ubuntu14的旧版本系统，其中的Python环境大多是基于2.0的，由于本人所使用的系统是Ubuntu20.04，后再油管澳大利亚某个学校的网络教学视频的帮助下成功安装，在这里写下安装教程，希望能对后面学习的同学有所帮助。</p><p>系统环境：Ubuntu20.04</p><p>Python版本：3.8</p></blockquote><h2 id="第一步：安装必要的依赖文件"><a href="#第一步：安装必要的依赖文件" class="headerlink" title="第一步：安装必要的依赖文件"></a>第一步：安装必要的依赖文件</h2><p>这里网上的教程会让下载python-dev，注意不要下会将系统中原有的Python3.0的版本给修改导致Mininet无法运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential python-dev openjdk-8-jdk maven ant</span><br></pre></td></tr></table></figure><h2 id="第二步：下载FloodLight"><a href="#第二步：下载FloodLight" class="headerlink" title="第二步：下载FloodLight"></a>第二步：下载FloodLight</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/floodlight/floodlight.git</span><br></pre></td></tr></table></figure><h2 id="第三步：安装web子模块"><a href="#第三步：安装web子模块" class="headerlink" title="第三步：安装web子模块"></a>第三步：安装web子模块</h2><p>安装web子模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd floodlight</span><br><span class="line">sudo git submodule init</span><br><span class="line">sudo git submodule update</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141809751.png" alt="image-20240414161312644"></p><h2 id="第四步：编译"><a href="#第四步：编译" class="headerlink" title="第四步：编译"></a>第四步：编译</h2><p>直接编译会发生报错，这里需要解决一下，需要到<a href="https://mvnrepository.com/">maven仓库</a>中下载两个文件并修改<code>build.xml</code>配置文件</p><ul><li>文件1：libthrift-0.14.1.jar</li><li>文件2：netty-all-4.1.66.Final.jar</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141604610.png" alt="image-20240414160339511"></p><p>将上述两个文件放到<code>floodlight/lib</code>目录下，然后编辑<code>build.xml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit build.xml</span><br></pre></td></tr></table></figure><p>修改图片中的两行为刚移动过去的文件【71行和76行】，保存并退出</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141809614.png" alt="image-20240414160358889"></p><p>修改完成后进行ant清除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ant clean</span><br></pre></td></tr></table></figure><p>重新进行ant编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ant</span><br></pre></td></tr></table></figure><p>编译成功：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141809610.png" alt="image-20240414160535614"></p><p>检查安装是否成功</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141809952.png" alt="image-20240414160910659"></p><h2 id="第五步：测试"><a href="#第五步：测试" class="headerlink" title="第五步：测试"></a>第五步：测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/floodlight.jar</span><br></pre></td></tr></table></figure><p>访问web界面</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141809351.png" alt="web界面"></p><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mn --topo=single,4 --controller=remote,ip=127.0.0.1,port=6653</span><br></pre></td></tr></table></figure><p>打开网页查看网络拓扑：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404141914178.png" alt="image-20240414191451535"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>油管视频教程：<a href="https://www.youtube.com/watch?v=UgF8zSHXnGI">https://www.youtube.com/watch?v=UgF8zSHXnGI</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404142017144.png&quot; alt=&quot;image-20240414201754826&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ubuntu</summary>
      
    
    
    
    
    <category term="SDN" scheme="https://guoxiansen.github.io/tags/SDN/"/>
    
    <category term="FloodLight" scheme="https://guoxiansen.github.io/tags/FloodLight/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目快速搭建</title>
    <link href="https://guoxiansen.github.io/2024/04/11/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    <id>https://guoxiansen.github.io/2024/04/11/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/</id>
    <published>2024-04-11T14:04:12.000Z</published>
    <updated>2024-04-11T14:04:37.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112204639.png" alt="image-20240411220414040"></p><p>快速创建SpringBoot项目</p><p>打开IDEA在File-&gt;New-&gt;Project中新建项目</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112103007.png" alt="image-20240411210322084"></p><p>点击左侧的Spring Initializr</p><p>输入以下信息：</p><ul><li>Name 项目名称</li><li>Group 根据公司域名来，或者默认com.example【倒序域名】</li><li>Package Name 包名，项目的代码会在这个包下</li><li>JDK版本</li><li>Java 与上面JDK版本对应</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112129237.png" alt="image-20240411212922459"></p><p>点击Next，选择SpringBoot版本，注意JDK17仅支持SpringBoot3的版本，不支持2.0版本，然后因为我们需要开发web项目，所以需要勾选Web下的Spring Web，之后点击Create</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112130798.png" alt="image-20240411213031291"></p><p>等待片刻，即可完成项目脚手架的创建。</p><p>项目结构如下：</p><p>我们主要关注的是：</p><ul><li>pom.xml：这里面是关于项目中所使用到的依赖坐标</li><li>application.yml：关于项目中的一些配置信息，如数据库配置、Redis配置等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112134450.png" alt="image-20240411213305456"></p><p>我们在springbootquickstart包下创建controller文件夹，并在其中创建一个HelloController对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.spingbootquickstart.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello~~~~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完毕后，找到启动项SpringbootQuickstartApplication，右击运行即可，看到下面的结果</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112159046.png" alt="image-20240411215925117"></p><p>不难看出我们的项目运行在8080端口，现在我们可以在浏览器访问localhost:8080/hello，即可得到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112157071.png" alt="image-20240411215728827"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112204639.png&quot; alt=&quot;image-20240411220414040&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速创建SpringB</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://guoxiansen.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Centos服务器安装MySQL</title>
    <link href="https://guoxiansen.github.io/2024/04/05/Centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySQL/"/>
    <id>https://guoxiansen.github.io/2024/04/05/Centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySQL/</id>
    <published>2024-04-05T08:25:43.000Z</published>
    <updated>2024-04-08T13:36:11.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Centos服务器安装MySQL"><a href="#Centos服务器安装MySQL" class="headerlink" title="Centos服务器安装MySQL"></a>Centos服务器安装MySQL</h1><blockquote><p>利用闲置服务器安装MySQL，用于项目练手</p><p>Linux版本：Centos7.9</p><p>MySQL版本：8.0.36</p></blockquote><h2 id="一、下载MySQL"><a href="#一、下载MySQL" class="headerlink" title="一、下载MySQL"></a>一、下载MySQL</h2><p>从Oracle官网下载最新版本的MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.36-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><p>在 /usr/local/src目录下创建一个mysql目录,进入目录后将下载的mysql解压到mysql目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/src/mysql</span><br><span class="line">tar -xvf mysql-8.0.36-1.el7.x86_64.rpm-bundle.tar -C /usr/local/src/mysql/</span><br></pre></td></tr></table></figure><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y perl.x86_64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051629724.png" alt="image-20240405162956661"></p><p>在mysql目录下执行yum安装命令，等待跑完安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-community-*.rpm</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051632920.png" alt="image-20240405163210736"></p><p>显示Complete！即为安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051810450.png" alt="image-20240405181019237"></p><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><p>查看运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051813987.png" alt="image-20240405181344557"></p><p>如果active是active (running)则启动成功</p><h2 id="四、获取初始密码"><a href="#四、获取初始密码" class="headerlink" title="四、获取初始密码"></a>四、获取初始密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404061635494.png" alt="image-20240405181525391"></p><h2 id="五、登录"><a href="#五、登录" class="headerlink" title="五、登录"></a>五、登录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051816820.png" alt="image-20240405181614381"></p><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的密码&#x27;;</span><br></pre></td></tr></table></figure><p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘@766414Love521’;</p><p>设置密码的时候提示您密码不符合规范</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051834559.png" alt="image-20240405183457090"></p><p>原因是密码过于简单，密码中需要包含大小写字母、数字以及要保证长度</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051907400.png" alt="image-20240405190738981"></p><h2 id="六、远程连接"><a href="#六、远程连接" class="headerlink" title="六、远程连接"></a>六、远程连接</h2><p>切换到mysql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br></pre></td></tr></table></figure><p>查询权限</p><p>默认情况下只允许本地localhost连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> host <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051910411.png" alt="image-20240405191035651"></p><p>修改权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> =<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051914627.png" alt="image-20240405191437245"></p><p>刷新权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051914453.png" alt="image-20240405191454118"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051915123.png" alt="image-20240405191541526"></p><p>在华为云服务器安全组中开放端口</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051922373.png" alt="image-20240405192239382"></p><p>Navicat中测试连接，连接成功安装完毕！</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051924232.png" alt="image-20240405192427938"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果出现下面无法连接的情况，可以尝试使用ssh的方式进行连接</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404082135415.png" alt="image-20240408213521518"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404082136634.png" alt="image-20240408213606195"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Centos服务器安装MySQL&quot;&gt;&lt;a href=&quot;#Centos服务器安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;Centos服务器安装MySQL&quot;&gt;&lt;/a&gt;Centos服务器安装MySQL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;利</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://guoxiansen.github.io/tags/MySQL/"/>
    
    <category term="Linux" scheme="https://guoxiansen.github.io/tags/Linux/"/>
    
    <category term="Centos" scheme="https://guoxiansen.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Springboot学习笔记</title>
    <link href="https://guoxiansen.github.io/2024/04/05/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://guoxiansen.github.io/2024/04/05/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-05T05:22:11.000Z</published>
    <updated>2024-04-25T06:07:21.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot学习笔记"><a href="#Springboot学习笔记" class="headerlink" title="Springboot学习笔记"></a>Springboot学习笔记</h1><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>采用<code>.yml</code>格式的配置文件相较于<code>.property</code>格式的配置文件来说，层级关系更清晰</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404051324989.png" alt="image-20240405132413536"></p><h3 id="yml配置信息的书写与获取"><a href="#yml配置信息的书写与获取" class="headerlink" title="yml配置信息的书写与获取"></a>yml配置信息的书写与获取</h3><ul><li>三方技术配置信息<ul><li>Mybatis</li></ul></li><li>自定义配置信息<ul><li>邮件的相关配置信息</li></ul></li></ul><p>使用注解进行值的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;email&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>值的前面必须有空格作为分隔符</li><li>使用空格作为缩进表示层级关系，相同层级左侧对齐</li></ul><p>配置信息的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;键名&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 前缀</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;email&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="Springboot整合mybatis"><a href="#Springboot整合mybatis" class="headerlink" title="Springboot整合mybatis"></a>Springboot整合mybatis</h2><h2 id="Bean注册"><a href="#Bean注册" class="headerlink" title="Bean注册"></a>Bean注册</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404052108095.png" alt="image-20240405210815362"></p><p>如果要注册的bean对象来自于第三方（不是自定义的），是无法使用<code>@Component</code>及其衍生注解声明bean的</p><ul><li>@Bean</li><li>@Import</li></ul><p>Bean扫描</p><p>Springboot默认扫描启动类所在包及其子包下的内容，如果要扫描其他文件夹，可以手动添加注解@ComponentScan</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404101008851.png" alt="image-20240406165916427"></p><h2 id="注册条件"><a href="#注册条件" class="headerlink" title="注册条件"></a>注册条件</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404101008933.png" alt="image-20240408201847651"></p><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>遵循约定大于配置的原则，在boot程序启动后，起步依赖中的一些bean对象会自动注入到ioc容器中 </p><h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404091710648.png" alt="image-20240409171023782"></p><p>准备工作：</p><ul><li>创建数据库表</li><li>创建SpringBoot工程，引入对应的依赖（web、mybatis、mysql驱动）</li><li>配置文件application.yml中引入mybatis的配置信息</li><li>创建包结构，并准备实体类</li></ul><p>包结构介绍如下：</p><ul><li>config：对应相关的配置信息</li><li>controller：控制器存放的包</li><li>exception：全局异常</li><li>interceptors：拦截器</li><li>mapper：和数据库相关的</li><li>pojo：实体类相关的</li><li>service：接口和对应的实现类，核心功能都由其实现</li><li>utils：存放工具类，工具类中通常会提供静态方法供我们在项目中使用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404120921192.png" alt="image-20240412092156313"></p><p>功能：</p><ul><li>注册</li><li>登录</li><li>获取用户详细信息</li><li>更新用户基本信息</li><li>更新用户头像</li><li>更新用户密码</li></ul><p>故障修复</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404092026681.png" alt="image-20240409202558370"></p><p>对于下面这个报错，只需要将mybatis的版本修改为3.0.3即可解决</p><p>Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: No acceptable representation]</p><p>这个报错是因为没有在标准结果Result对象上面添加<code>@Data</code>注解，就导致解析的时候无法正确的将其转换为json对象。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404120957157.png" alt="image-20240412095712214"></p><p>上面这个报错解决方案是在userMapper中的文件上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into user(username,password,create_time,update_time) values(#&#123;username&#125;,#&#123;password&#125;,now(),now())&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册相关的api要求</p><p>定义统一的消息返回的类Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.itheima.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//业务状态码  0-成功  1-失败</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//提示信息</span></span><br><span class="line">    <span class="keyword">private</span> T data;<span class="comment">//响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速返回操作成功响应结果(带响应数据)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Result&lt;E&gt; <span class="title">success</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速返回操作成功响应结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">error</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="number">1</span>, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中我们定义了三个静态方法：</p><ul><li>success(E data)</li><li>success()：操作成功方法，无需传入相关参数</li><li>error(String message)</li></ul><p>注意这里使用了泛型，这样我们data类型就可以根据实际情况进行灵活的调整与使用了</p><h4 id="注册接口"><a href="#注册接口" class="headerlink" title="注册接口"></a>注册接口</h4><p>步骤：</p><ol><li>编写UserController类</li><li>编写UserService接口</li><li>编写UserServiceImpl实现UserService接口</li><li>编写注册逻辑register方法</li></ol><p>详细代码如下：</p><p>UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.itheima.pojo.Result;</span><br><span class="line"><span class="keyword">import</span> org.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.itheima.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        User u = userService.findByUserName(username);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户名没有被占用</span></span><br><span class="line">            <span class="comment">// 注册</span></span><br><span class="line">            userService.register(username, password);</span><br><span class="line">            <span class="keyword">return</span> Result.success(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 占用</span></span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;用户名已被占用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写UserServiceImpl实现UserService接口</p><p>这里的实现中引入了一个密码加密处理的工具类MD5Util，实际上MD5加密的方式是不安全的，可以通过撞库的方式进行密码的破解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.itheima.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.itheima.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.itheima.utils.Md5Util;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findByUserName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        User u = userMapper.findByUserName(username);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 密码加密处理</span></span><br><span class="line">        String md5String = Md5Util.getMD5String(password);</span><br><span class="line">        <span class="comment">// md5 加密</span></span><br><span class="line">        userMapper.add(username, md5String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper类中注册方法：注意add方法需要添加注解@Param(“username”)和@Param(“password”)，否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gyz.demoregister.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gyz.demoregister.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username=#&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findByUserName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增用户</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(username,password,create_time,update_time) values(#&#123;username&#125;,#&#123;password&#125;,&quot; +</span></span><br><span class="line"><span class="meta">            &quot;now(),now())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line">    <span class="comment">// void add(String username, String password);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121001655.png" alt="image-20240412100155489"></p><h4 id="注册校验"><a href="#注册校验" class="headerlink" title="注册校验"></a>注册校验</h4><p>在上面的代码中，存在一定的缺陷，即用户名和密码需要进行一定的校验才能符合我们的要求，如下图所示密码要求是5-16位非空字符，在我们刚刚的代码中没有进行相关的校验，不符合要求，现在我们来进行改进。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121004484.png" alt="image-20240412100450075"></p><p>这里我们使用Spring Validation ，这是Spring提供的一个参数校验框架，使用预定义的注解完成参数校验</p><p>步骤主要有三步：</p><ul><li><h4 id="引入Spring-Validation起步依赖"><a href="#引入Spring-Validation起步依赖" class="headerlink" title="引入Spring Validation起步依赖"></a>引入Spring Validation起步依赖</h4></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="在参数前面添加-Pattern注解"><a href="#在参数前面添加-Pattern注解" class="headerlink" title="在参数前面添加@Pattern注解"></a>在参数前面添加@Pattern注解</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(<span class="meta">@Pattern(regexp = &quot;^\\S&#123;5,16&#125;$&quot;)</span> String username, <span class="meta">@Pattern(regexp = &quot;^\\S&#123;5,16&#125;$&quot;)</span> String password)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li><h4 id="在Controller类上添加-Validated注解"><a href="#在Controller类上添加-Validated注解" class="headerlink" title="在Controller类上添加@Validated注解"></a>在Controller类上添加@Validated注解</h4></li></ul><p>在控制器类上方添加<code>@Validated</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121015536.png" alt="image-20240412101543115"></p><p>这时候我们进行测试：会发现报错500服务器内部错误，这样的响应格式明显是不符合我们要求统一的返回类型Result</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121023642.png" alt="image-20240412102352488"></p><p>这时候我们就可以定义一个全局异常处理器，用来处理参数校验失败的异常</p><p>使用注解<code>@RestControllerAdvice</code>，方法上面需要添加注解@ExceptionHandler(Exception.class)，返回值类型为Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gyz.demoregister.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gyz.demoregister.pojo.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handlerException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(StringUtils.hasLength(e.getMessage())? e.getMessage():<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用spring提供的StringUtils工具类判断错误信息是否为空，如果不为空则返回错误信息，如果为空则返回操作失败。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>请求路径 /user/login</p><p>请求方式 POST</p><p>请求参数username和password</p><p>响应数据：Result对象，其中data返回JWT</p><p>用户登录成功后，系统会自动下发JWT令牌，然后后续每次请求，都会在请求头header中携带<code>Authorization</code>，值为JWT令牌</p><p>如果检测到用户未登录或者JWT过期或非法，则HTTP响应码为401</p><h4 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h4><ul><li>首先判断用户名是否存在于数据库中</li><li>如果存在则进行密码校验<ul><li>如果密码错误则返回账号名或密码错误</li><li>如果密码正确则返回JWT令牌</li></ul></li><li>如果不存在则返回账号名或密码错误</li></ul><p>注意claims为存储到jwt中的数据，同时这个数据后续也会存在ThreadLocal中方便在其他的DAO接口中进行复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    User loginUser = userService.findUserByName(username);</span><br><span class="line">    <span class="keyword">if</span> (loginUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Md5Util.getMD5String(password).equals(loginUser.getPassword())) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存储到ThreadLocal中的业务数据 这里跟需要来即可</span></span><br><span class="line">        claims.put(<span class="string">&quot;id&quot;</span>, loginUser.getId());</span><br><span class="line">        claims.put(<span class="string">&quot;username&quot;</span>, loginUser.getUsername());</span><br><span class="line">        String token = JwtUtil.genToken(claims);</span><br><span class="line">        <span class="keyword">return</span> Result.success(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="登录认证引入"><a href="#登录认证引入" class="headerlink" title="登录认证引入"></a>登录认证引入</h4><p>例如我们登录过后，如果访问文章列表这样的信息的话，就需要携带我们登录过后的令牌才能够进行访问否则直接拒绝访问。例如下面的接口在我们没有登录的状态下是不能直接访问的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121523566.png" alt="image-20240412152258937"></p><p>令牌就是一段字符串</p><ul><li>承载业务数据，减少后续请求查询数据库的次数【直接从令牌中获取用户的信息】</li><li>防篡改，保证信息的合法性和有效性</li></ul><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>被<code>.</code>分成三个部分</p><ul><li>Header（请求头），记录令牌类型、签名算法等。{“alg” : “H256”, “type” : “JWT”}</li><li>Payload（有效载荷），携带一些自定义信息、默认信息等。例如{“id”: “1”, “username” : “zhangsan”}<ul><li>此部分不要存放一些加密信息</li></ul></li><li>Signature（签名），防止Token被篡改、确保安全性，将header、payload进行加密得到</li></ul><p>jwt基于Base64进行编码，这样就算数据中个包含了中文也是可以正确显示的</p><p>生成jwt</p><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IuW8oOS4iSJ9LCJleHAiOjE3MTI3MzM5OTh9.6cBZ03xMeLItFt4FWSM_Xe2lBcGklI8koRpZZINa-Zk</p><p>校验jwt token</p><p>如果篡改了头部和载荷部分的数据，那么验证失败</p><p>如果秘钥修改了，验证失败</p><p>token过期</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404101532993.png" alt="image-20240410153251962"></p><h4 id="使用jwt"><a href="#使用jwt" class="headerlink" title="使用jwt"></a>使用jwt</h4><p>引入依赖坐标，刷新Maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建测试类，生成jwt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gyz.cvmanage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTVerifier;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.Claim;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jwt生成</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        claims.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;user&quot;</span>, claims)</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>)) <span class="comment">// 添加过期时间</span></span><br><span class="line">                .sign(Algorithm.HMAC256(<span class="string">&quot;itheima&quot;</span>));<span class="comment">// 指定算法，配置密钥</span></span><br><span class="line">        System.out.println(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jwt解析</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IuW8oOS4iSJ9LCJleHAiOjE3MTI5NTA3MTR9.2C1Ljtu7VJjjOyw5_vS8j0GFMxVXhPVmzhswSdUjxDo&quot;</span>;</span><br><span class="line">        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(<span class="string">&quot;itheima&quot;</span>)).build();</span><br><span class="line">        DecodedJWT decodedJWT = jwtVerifier.verify(token);</span><br><span class="line">        Map&lt;String, Claim&gt; claims = decodedJWT.getClaims();</span><br><span class="line">        System.out.println(claims); <span class="comment">// &#123;exp=1712950714, user=&#123;&quot;id&quot;:1,&quot;username&quot;:&quot;张三&quot;&#125;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IuW8oOS4iSJ9LCJleHAiOjE3MTI5NTA3MTR9.2C1Ljtu7VJjjOyw5_vS8j0GFMxVXhPVmzhswSdUjxDo</span><br></pre></td></tr></table></figure><p>解密jwt</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;exp=1712950714, user=&#123;&quot;id&quot;:1,&quot;username&quot;:&quot;张三&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>登录成功返回jwt</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121601743.png" alt="image-20240412160125393"></p><p>现在进行校验：即访问**/article/list**接口需要携带token请求头<code>Authorization</code>才能获取对应的数据。</p><p>从请求头中获取数据可以使用注解<code>@RequestHeader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br></pre></td></tr></table></figure><p>这段解析的代码如果报错则说明解析失败，如果没有报错则解析成功，可以从其中获取我们所需要的数据</p><p>Ctrl+Alt+T  idea快捷键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">list</span><span class="params">(<span class="meta">@RequestHeader(name = &quot;Authorization&quot;)</span> String token, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证token</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">            <span class="keyword">return</span> Result.success(<span class="string">&quot;所有文章数据&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// throw new RuntimeException(e);</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);  <span class="comment">// 未授权 校验失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;未登录.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121620476.png" alt="image-20240412162032583"></p><p>上面的代码的确实现了我们所需要的功能，但是存在一个缺陷，如果我们增加业务代码，就需要在代码中编写token校验的内容，这样的工作显然是比较麻烦的，后续为了方便所有的接口都进行jwt的校验，可以编写一个拦截器来进行拦截，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404101559515.png" alt="image-20240410155952755"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404101600284.png" alt="image-20240410160025628"></p><p>拦截器的实现步骤：</p><ul><li>编写LoginInterceptor类实现HandlerInterceptor接口<ul><li>重写preHandle方法：在请求到达处理器之前，可以用于权限验证、数据校验等操作。如果返回true，表示方放行继续执行后续代码；如果返回false，表示拦截，中断请求处理。</li></ul></li><li>编写web配置类实现WebMvcConfigurer接口，注册我们写好的拦截器</li></ul><p>拦截器LoginInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 令牌验证</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 放行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// throw new RuntimeException(e);</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);  <span class="comment">// 未授权 校验失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 拦截</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return HandlerInterceptor.super.preHandle(request, response, handler);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册拦截器：这里需要注意添加注解<code>@Configuration</code>，否则配置不会生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(loginInterceptor).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span>, <span class="comment">// 放行登录接口</span></span><br><span class="line">                <span class="string">&quot;user/register&quot;</span><span class="comment">// 放行注册接口</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取用户详细信息"><a href="#获取用户详细信息" class="headerlink" title="获取用户详细信息"></a>获取用户详细信息</h3><p>根据用户名获取用户详细信息，用户名从token中获取：</p><ol><li>从请求头中获取token</li><li>调用jwt工具类对token进行解析</li><li>根据用户名查找用户</li><li>返回用户实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/userInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">userInfo</span><span class="params">(<span class="meta">@RequestHeader(name = &quot;Authorization&quot;)</span> String token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据用户名查询用户</span></span><br><span class="line">    Map&lt;String, Object&gt; map = JwtUtil.parseToken(token);</span><br><span class="line">    String username = (String) map.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    User user = userService.findUserByName(username);</span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试1：不携带Authorization请求头，HTTP响应码为401未授权</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121713267.png" alt="image-20240412171339061"></p><p>测试2：携带Authorization请求头，得到结果：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121714809.png" alt="image-20240412171423456"></p><p>这里需要注意：接口响应的数据中包含了密码，这显然是不符合要求的【密码属于机密信息需要进行隐藏】。Springboot提供了对应的注解<code>@JsonIgnore</code>，</p><p>让springMVC把当前对象转换为json字符串的时候，忽略password，最终的json字符串就没有password这个属性了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;<span class="comment">// 主键ID</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">// 用户名</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password;<span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">// 昵称</span></span><br><span class="line">    <span class="keyword">private</span> String email;<span class="comment">// 邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String userPic;<span class="comment">// 用户头像地址</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;<span class="comment">// 更新时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，再次测试，得到正确的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121732068.png" alt="image-20240412173229726"></p><p>但是我们可以发现，返回的结果中创建时间和更新时间是null，但数据库中实际上是存在这个数据的，这是因为数据库中的字段是带下划线的，无法和驼峰命名进行自动转化，我们需要在<code>application.yml</code>中添加相应的配置信息【来进行驼峰和下划线的自动转换】</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121734106.png" alt="image-20240412173400545"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重新测试，结果正确：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404121737067.png" alt="测试创建和更新时间"></p><h3 id="ThreadLocal优化"><a href="#ThreadLocal优化" class="headerlink" title="ThreadLocal优化"></a>ThreadLocal优化</h3><p>上面的代码中我们为了获取用户的信息，在userInfo接口中解析了jwt的token，但是实际上我们在拦截器中已经进行解析了；相当于这部分我们进行了重复的工作，因此我们需要对其进行优化，解决的方法就是使用ThreadLocal存储用户的信息</p><p>ThreadLocal提供线程的局部变量</p><ul><li>用来存取数据：get()/set()</li><li>使用ThreadLocal存储的数据，线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadLocalSetAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供ThreadLocal对象</span></span><br><span class="line">        ThreadLocal tl = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="string">&quot;11111111111111&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">        &#125;, <span class="string">&quot;蓝色线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="string">&quot;22222222222222&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + tl.get());</span><br><span class="line">        &#125;, <span class="string">&quot;红色线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，创建了两个线程并在线程中分别存放了不同的数据，最终运行测试程序，发现最终两个线程存储的内容是相互隔离的。</p><p>ThreadLocal原理如下：两个用户的线程中的数据是相互隔离的，所以是线程安全的。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404102017351.png" alt="image-20240410201706484"></p><p>使用ThreadLocal对代码进行优化步骤十分简单：</p><ul><li>引入ThreadLocalUtil工具类</li><li>在拦截器中添加数据到ThreadLocal中</li><li>在对应的业务代码中获取ThreadLocal中的数据</li><li>在<code>afterCompletion</code>方法中清空ThreadLocal对象防止内存泄漏</li></ul><p>拦截器中存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 令牌验证</span></span><br><span class="line">    String token = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">        <span class="comment">// System.out.println(claims);</span></span><br><span class="line">        <span class="comment">// 将业务信息存储到ThreadLocal中</span></span><br><span class="line">        ThreadLocalUtil.set(claims);  <span class="comment">// &#123;id=5, username=test2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 放行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// throw new RuntimeException(e);</span></span><br><span class="line">        response.setStatus(<span class="number">401</span>);  <span class="comment">// 未授权 校验失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 拦截</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return HandlerInterceptor.super.preHandle(request, response, handler);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>userInfo</code>接口</p><p>直接从全局的ThreadLocal对象中获取数据即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/userInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">userInfo</span><span class="params">(<span class="comment">/* @RequestHeader(name = &quot;Authorization&quot;) String token */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据用户名查询用户</span></span><br><span class="line">    <span class="comment">// Map&lt;String, Object&gt; map = JwtUtil.parseToken(token);</span></span><br><span class="line">    <span class="comment">// String username = (String) map.get(&quot;username&quot;);</span></span><br><span class="line">    Map&lt;String, Object&gt; map = ThreadLocalUtil.get();</span><br><span class="line">    String username = (String) map.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">    User user = userService.findUserByName(username);</span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新用户基本信息"><a href="#更新用户基本信息" class="headerlink" title="更新用户基本信息"></a>更新用户基本信息</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122027021.png" alt="image-20240412202722804"></p><p>更新参数为nickname、email，需要根据id来进行更新，更新的时候需要注意更新时间</p><p>restful风格规定了我们进行更新的时候使用的方法为<code>PUT</code></p><p>步骤如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122031458.png" alt="image-20240412203112871"></p><p>完成上述工作后，仍然存在一个问题：参数的校验，这里我们更新的昵称的长度以及email的格式需要符合规范，所以这里需要进行参数的校验；但是由于这些参数都是在User实体类中的，所以需要借助于自带的注解来进行参数的校验</p><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>更新信息参数校验 【实体参数校验】</p><ol><li>需要在实体类的属性上面添加validation提供的注解</li><li>在参请求参数前面添加<code>@Validated</code>注解</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404102111607.png" alt="image-20240410210412049"></p><p>实体类属性上添加相应注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span> <span class="comment">// 值不为null</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;<span class="comment">// 主键ID</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">// 用户名</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password;<span class="comment">// 密码</span></span><br><span class="line">    <span class="meta">@NotEmpty</span> <span class="comment">// 不能为null并且内容不为空</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^\\S&#123;1,10&#125;$&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">// 昵称</span></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="meta">@Email</span> <span class="comment">// 满足邮箱格式</span></span><br><span class="line">    <span class="keyword">private</span> String email;<span class="comment">// 邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String userPic;<span class="comment">// 用户头像地址</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;<span class="comment">// 更新时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller中添加注解 <code>@Validated</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> User user)</span> </span>&#123;</span><br><span class="line">    userService.update(user);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试更新成功：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122049883.png" alt="image-20240412204858410"></p><p>nickname不能为空</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122049893.png" alt="image-20240412204927627"></p><p>邮箱地址不合法无法通过</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122050843.png" alt="image-20240412204959267"></p><p>更新用户头像</p><p>请求路径：/user/updateAvatar</p><p>PATCH：这个更新通常用于部分更新，比如本需求中只需要更新图片</p><p>这里也需要进行参数校验，可以使用@url进行校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(&quot;/updateAvatar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">updateAvatar</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@URL</span> String avatarUrl)</span></span>&#123;</span><br><span class="line">    userService.updateAvatar(avatarUrl);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122100452.png" alt="image-20240412210003005"></p><p>更新头像</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404102130358.png" alt="image-20240410212847940"></p><p>这个报错是因为参数里面并没有这个值，需要自己手动进行获取，这里使用now()方法进行获取即可</p><p>更新成功</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404102130103.png" alt="image-20240410212958895"></p><p> @URL注解可以自动对url地址进行校验</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122105522.png" alt="image-20240412210514448"></p><h3 id="更新用户密码"><a href="#更新用户密码" class="headerlink" title="更新用户密码"></a>更新用户密码</h3><p>请求接口 /user/updatePwd</p><p>PATCH：本需求中只需要更新用户密码</p><p>请求参数包括三个：</p><ul><li>old_pwd</li><li>new_pwd</li><li>re_pwd</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122110893.png" alt="image-20240412211049990"></p><p>注意这里在进行密码更新的时候，id需要在ThreadLocal中进行获取</p><p>测试成功，并对错误接口进行测试</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122128222.png" alt="image-20240412212759929"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122130529.png" alt="image-20240412213026492"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404122130565.png" alt="image-20240412213037139"></p><h2 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h2><p>总共有5个接口：</p><ul><li>新增文章分类</li><li>文章分类列表</li><li>获取文章分类详情</li><li>更新文章分类</li><li>删除文章分类</li></ul><h3 id="新增文章分类"><a href="#新增文章分类" class="headerlink" title="新增文章分类"></a>新增文章分类</h3><blockquote><p>请求路径：/category</p><p>请求方式：POST</p><p>接口描述：该接口用于新增文章分类</p></blockquote><p>请求数据样例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;categoryName&quot;</span>:<span class="string">&quot;人文&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;categoryAlias&quot;</span>:<span class="string">&quot;rw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库表结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404131656747.png" alt="image-20240413165627307"></p><ul><li><p>id</p></li><li><p>分类名称</p></li><li><p>分类别名</p></li><li><p>创建人ID，来自于User表中的主键ID，记录这个分类是哪个用户进行创建的</p></li><li><p>创建时间</p></li><li><p>更新时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;<span class="comment">// 主键ID</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;<span class="comment">// 分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String categoryAlias;<span class="comment">// 分类别名</span></span><br><span class="line">    <span class="keyword">private</span> Integer createUser;<span class="comment">// 创建人ID</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;<span class="comment">// 更新时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404131703239.png" alt="image-20240413170319757"></p><h3 id="文章分类列表"><a href="#文章分类列表" class="headerlink" title="文章分类列表"></a>文章分类列表</h3><blockquote><p>请求参数：无</p><p>请求方式：GET</p><p>请求路径：/category</p></blockquote><p>注意这个请求路径和新增文章分类是一样的，不同的是他们的请求方式不一样。</p><p>因为这里返回的数据是如下格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;操作成功&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;categoryName&quot;</span>: <span class="string">&quot;美食&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;categoryAlias&quot;</span>: <span class="string">&quot;my&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2023-09-02 12:06:59&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;updateTime&quot;</span>: <span class="string">&quot;2023-09-02 12:06:59&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;categoryName&quot;</span>: <span class="string">&quot;娱乐&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;categoryAlias&quot;</span>: <span class="string">&quot;yl&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2023-09-02 12:08:16&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;updateTime&quot;</span>: <span class="string">&quot;2023-09-02 12:08:16&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">&quot;categoryName&quot;</span>: <span class="string">&quot;军事&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;categoryAlias&quot;</span>: <span class="string">&quot;js&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2023-09-02 12:08:33&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;updateTime&quot;</span>: <span class="string">&quot;2023-09-02 12:08:33&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过观察可以发现这也就是Category实体类所对应的数据，所以我们在控制器中写我们方法的时候返回值需要使用Result的泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;Category&gt;&gt; list() &#123;</span><br><span class="line">    List&lt;Category&gt; cs = categoryService.list();</span><br><span class="line">    <span class="keyword">return</span> Result.success(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过categoryService中的list方法获取到一个List集合得到全部的数据。【注意：这里所得到的数据需要是当前用户所创建的数据所以在list方法中还需要从ThreadLocal中获取到用户id，然后在<code>userMapper</code>中查询的时候再根据用户id去查询】</p><p>categoryServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = ThreadLocalUtil.get();</span><br><span class="line">    Integer userId = (Integer) map.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> categoryMapper.list(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>categoryMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from category where create_user=#&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Category&gt; <span class="title">list</span><span class="params">(Integer userId)</span></span>;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404171058065.png" alt="image-20240417105800821"></p><p>这里的时间格式有点问题，不是例如2024-4-17 11:01:10这样的，所以我们需要在实体类中添加一下注解规范一下时间的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;<span class="comment">// 创建时间</span></span><br><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;<span class="comment">// 更新时间</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404171107689.png" alt="image-20240417110710285"></p><p>再次测试时间格式就正常了</p><h3 id="获取文章分类详情"><a href="#获取文章分类详情" class="headerlink" title="获取文章分类详情"></a>获取文章分类详情</h3><blockquote><p>请求路径：/category/detail</p><p>请求方式：GET</p><p>接口描述：该接口用于根据ID获取文章分类详情</p></blockquote><h3 id="更新文章分类"><a href="#更新文章分类" class="headerlink" title="更新文章分类"></a>更新文章分类</h3><blockquote><p>请求路径：/category</p><p>请求方式：PUT</p><p>接口描述：该接口用于更新文章分类</p></blockquote><ul><li>id不能为空</li><li>categoryName不能为空</li><li>categoryAlias不能为空</li></ul><p>这里需要注意请求体为<code>json</code>格式的，我们需要进行校验，防止其中改的参数为空，所以我们需要在实体类Category中添加相应的校验规则</p><p>这里需要添加一个id不为空的校验规则，这样就会导致前面新增文章分类的时候出现id不能为空的报错，因为那个接口中不需要传递id参数，id是由MySQL主键进行自增的，所以这里引出一个规则分组校验</p><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>把校验项进行归类分组，在完成不同的功能时，校验指定组中的校验项：</p><ul><li>定义分组</li><li>定义校验项时制定归属的分组</li><li>校验时制定要校验的分组</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404171403511.png" alt="image-20240417140350672"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = Update.class)</span> <span class="comment">// 不能不传</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;<span class="comment">// 主键ID</span></span><br><span class="line">    <span class="meta">@NotEmpty(groups = &#123;Add.class, Update.class&#125;)</span> <span class="comment">// 必须传 如果是字符串不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;<span class="comment">// 分类名称</span></span><br><span class="line">    <span class="meta">@NotEmpty(groups = &#123;Add.class, Update.class&#125;)</span> <span class="comment">// 必须传 如果是字符串不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String categoryAlias;<span class="comment">// 分类别名</span></span><br><span class="line">    <span class="keyword">private</span> Integer createUser;<span class="comment">// 创建人ID</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">// 创建时间</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;<span class="comment">// 更新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404171422534.png" alt="image-20240417142220635"></p><h3 id="删除文章分类"><a href="#删除文章分类" class="headerlink" title="删除文章分类"></a>删除文章分类</h3><blockquote><p>请求路径：/category</p><p>请求方式：DELETE</p><p>接口描述：该接口用于根据ID删除文章分类</p></blockquote><p>【已完成】</p><h2 id="文章管理"><a href="#文章管理" class="headerlink" title="文章管理"></a>文章管理</h2><h3 id="发布文章（新增）"><a href="#发布文章（新增）" class="headerlink" title="发布文章（新增）"></a>发布文章（新增）</h3><blockquote><p>请求路径：/article</p><p>请求方式：POST</p><p>接口描述：该接口用于新增文章(发布文章)</p></blockquote><p>请求参数为application/json格式</p><p>样例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;陕西旅游攻略&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;兵马俑,华清池,法门寺,华山...爱去哪去哪...&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;coverImg&quot;</span>: <span class="string">&quot;https://big-event-gwd.oss-cn-beijing.aliyuncs.com/9bf1cf5b-1420-4c1b-91ad-e0f4631cbed4.png&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;草稿&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;categoryId&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意参数的校验：</p><ul><li>title为1-10个非空字符</li><li>coverImg为url地址</li><li>state必须是 已发布或者草稿</li></ul><p>前两个都很好校验，state需要去编写自定义的校验规则注解：</p><ul><li><h3 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404171714387.png" alt="image-20240417171328385"></p><h3 id="文章列表查询（条件分页）"><a href="#文章列表查询（条件分页）" class="headerlink" title="文章列表查询（条件分页）"></a>文章列表查询（条件分页）</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404181052309.png" alt="image-20240418105248483"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404181057986.png" alt="image-20240418105707617"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404181350908.png" alt="image-20240418135028776"></p><p>文件上传如果发生同名的问题需要保证文件的名字是唯一的，防止发生文件覆盖，使用uuid对文件进行重命名</p><p>OSS 对象存储服务，Object Storage Service</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404181613271.png" alt="image-20240418161254400"></p><p>融合OSS对象存储编写工具类</p><h2 id="登录优化-Redis"><a href="#登录优化-Redis" class="headerlink" title="登录优化-Redis"></a>登录优化-Redis</h2><p>令牌主动失效机制：</p><ul><li>登录成功后，给浏览器响应令牌的同时，把该令牌存储到redis中</li><li>LoginInterceptor拦截器中，需要验证浏览器携带的令牌，并同时需要获取到redis中存储的与之相同的令牌</li><li>当用户修改密码成功后，删除redis中存储的旧令牌</li></ul><h2 id="集成Redis"><a href="#集成Redis" class="headerlink" title="集成Redis"></a>集成Redis</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404182132118.png" alt="image-20240418213211652"></p><p>引入依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>令牌主动失效机制：</p><ul><li>登录成功后给浏览器响应令牌的同时，把令牌存储到redis中</li><li>LoginInterceptor拦截器中，需要验证浏览器携带的令牌，并同时需要获取到redis中存储的与之相同的令牌</li><li>当用户修改密码成功后，删除redis中存储的旧令牌</li></ul><h2 id="Springboot项目部署"><a href="#Springboot项目部署" class="headerlink" title="Springboot项目部署"></a>Springboot项目部署</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404182211548.png" alt="image-20240418221106865"></p><p>属性配置方式：</p><h1 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Springboot学习笔记&quot;&gt;&lt;a href=&quot;#Springboot学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Springboot学习笔记&quot;&gt;&lt;/a&gt;Springboot学习笔记&lt;/h1&gt;&lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础</summary>
      
    
    
    
    
    <category term="Springboot" scheme="https://guoxiansen.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>三次握手与四次挥手</title>
    <link href="https://guoxiansen.github.io/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://guoxiansen.github.io/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2024-03-26T03:05:56.000Z</published>
    <updated>2024-03-26T07:40:20.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP是一种面向连接的协议，可以保证传输的可靠性</p><p>TCP是一种全双工的协议</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="三次握手的流程"><a href="#三次握手的流程" class="headerlink" title="三次握手的流程"></a>三次握手的流程</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261540258.png" alt="TCP 三次握手"></p><h2 id="为什么是三次而不是两次"><a href="#为什么是三次而不是两次" class="headerlink" title="为什么是三次而不是两次"></a>为什么是三次而不是两次</h2><p>首先客户端给服务器端发送请求之后，当服务器端收到请求就可以确保客户端的发送功能是正常的</p><p>然后服务器端给客户端响应<strong>（seq=y, ack=x+1）</strong>，当客户端收到消息之后，就可以确保服务器端的发送和接收功能都是正常的</p><p>此时客户端再给服务器端发送一条响应，那么服务器端就可以确保客户端的接收功能也是正常的。</p><p>如果说只进行两次握手，客户端给服务器端发送Hello，服务器端给客户端回一个hi，可能存在一个问题，这个消息并没有被客户端所接收，连接可能会存在数据丢失导致不可靠的问题。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP通过四次挥手来保证数据完整传输的</p><p>四次挥手需要确保双方后面都不会再发送数据的情况下再进行断开连接</p><h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><ol><li>客户端给服务器端发送一个带有FIN结束标识和seq=1的断开连接的请求包，主要目的是告诉客户端我这边不再发送数据包了，但是可以接收数据。</li><li>服务器端会给客户端发送一个ack包，表示自己已经知道客户端不会再向自己发送数据了</li><li>服务端给客户端发送一个断开连接的请求包，告知客户端自己这边也不会发送数据了</li><li>客户端给服务器端做出最后的响应，当服务端收到响应之后就会断开连接并释放资源；客户端这边需要等待一段时间再去断开连接，等待的时间是两倍的请求时间。</li></ol><h2 id="为什么不能将服务器端的两次请求合并成一个？"><a href="#为什么不能将服务器端的两次请求合并成一个？" class="headerlink" title="为什么不能将服务器端的两次请求合并成一个？"></a>为什么不能将服务器端的两次请求合并成一个？</h2><p>第二次挥手和第三次挥手之间是有一定的延迟性的，延迟可能是几秒、几十秒甚至几分钟</p><p>第二次挥手直接进行一次确认可以保证不会触发TCP的超时重传机制，减少额外的开销</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;p&gt;TCP是一种面向连接的协议，可以保证传输的可靠性&lt;/p&gt;
&lt;p&gt;TCP是一种全双工的协议&lt;/p&gt;
&lt;h1 id=&quot;三次握手&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://guoxiansen.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python内置模块collections解析</title>
    <link href="https://guoxiansen.github.io/2024/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97collections%E8%A7%A3%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97collections%E8%A7%A3%E6%9E%90/</id>
    <published>2024-03-25T13:40:03.000Z</published>
    <updated>2024-03-26T06:41:15.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置模块collections解析"><a href="#Python内置模块collections解析" class="headerlink" title="Python内置模块collections解析"></a>Python内置模块collections解析</h1><p>python的collections模块提供了非常多方便的操作，例如</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261336795.png" alt="image-20240326133642376"></p><ul><li>Counter</li><li>defaultdict()</li><li>OrderDict()</li><li>deque<ul><li>双端队列</li></ul></li><li>namedtuple()</li><li></li></ul><p>下面将逐个介绍每一个具体类的用法</p><h2 id="Counter类"><a href="#Counter类" class="headerlink" title="Counter类"></a>Counter类</h2><p>该类可以快速的进行统计，例如给定一个字符串之后，可以统计每个字符出现的次数，当然只要是<strong>可迭代【可哈希】</strong>的数据都是可以传给Counter中的，例如list，tuple等</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261340020.png" alt="image-20240326134016203"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;abcdeasdasdkjyhaksjdhkashd&quot;</span></span><br><span class="line">myhash = Counter(string)</span><br><span class="line">print(myhash)</span><br></pre></td></tr></table></figure><p>该类中提供了几个方法可以使用</p><ul><li><code>most_common()</code><ul><li>可以将字典中的元素按照出现次数组成一个元素，再按照出现次数从大到小排列成一个列表</li><li>例如：[(‘a’, 5), (‘d’, 5), (‘s’, 4), (‘k’, 3), (‘h’, 3), (‘j’, 2), (‘b’, 1), (‘c’, 1), (‘e’, 1), (‘y’, 1)]</li></ul></li><li><code>element()</code><ul><li>该方法会返回一个迭代器，其中包含元素的重复次数，如果这个元素出现次数为0，则不会返回该元素，可以作为字符串对其进行处理</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my = Counter(<span class="string">&quot;123123asdasdas&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(my.elements()))</span><br><span class="line"><span class="comment"># 112233aaasssdd</span></span><br></pre></td></tr></table></figure><h2 id="defaultdict类"><a href="#defaultdict类" class="headerlink" title="defaultdict类"></a>defaultdict类</h2><p>普通的字典在使用的时候，如果键不存在则会报错<code>KeyError</code>，这一点很影响使用体验，当然也可以每次都采用<code>dic.get(key, defaultValue)</code>的方式去获取值。这时就可以使用defaultdic来创建一个具有默认值的字典，这里的类型可以是整型、浮点型、列表、元祖、集合、字典等。</p><table><thead><tr><th>类型</th><th>初始值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>float</td><td>0.0</td></tr><tr><td>list</td><td>[]</td></tr><tr><td>tuple</td><td>()</td></tr><tr><td>set</td><td>set()</td></tr><tr><td>dict</td><td>{}</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dic = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">print(dic[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="OrderDict"><a href="#OrderDict" class="headerlink" title="OrderDict"></a>OrderDict</h2><p>OrderDict是一个可以按照元素添加顺序来存储键值对的字典类型，可以确保元素的顺序性。除了拥有普通字典的所有的操作以外，多了个顺序性。</p><p>底层采用的是双向链表，可以解决LRU算法的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="number">1</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">od[<span class="number">2</span>] = <span class="string">&quot;Java&quot;</span></span><br><span class="line">od[<span class="number">3</span>] = <span class="string">&quot;Golang&quot;</span></span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># OrderedDict([(1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;), (3, &#x27;Golang&#x27;)])</span></span><br></pre></td></tr></table></figure><p>可以确保元素的打印顺序</p><p>其中有几个实用的方法：</p><ul><li>popitem(last=True)<ul><li>该方法会移除字典最后一个元素，可以接收一个参数，如果为空默认为True移除最后一个元素，如果为False则移除第一个元素。</li></ul></li><li>move_to_end(key, last=True)<ul><li>该方法会将指定key位置的元素移动到字典的最后【默认情况】，如果last为False则移动到最开头位置。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="number">1</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line">od[<span class="number">2</span>] = <span class="string">&quot;Java&quot;</span></span><br><span class="line">od[<span class="number">3</span>] = <span class="string">&quot;Golang&quot;</span></span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># od.popitem(0)</span></span><br><span class="line"><span class="comment"># print(od)</span></span><br><span class="line">od.move_to_end(<span class="number">3</span>,<span class="literal">False</span>)</span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># OrderedDict([(1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;), (3, &#x27;Golang&#x27;)])</span></span><br><span class="line"><span class="comment"># OrderedDict([(3, &#x27;Golang&#x27;), (1, &#x27;Python&#x27;), (2, &#x27;Java&#x27;)])</span></span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>作为一个双端队列，此部分可以参考【<a href="https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">二叉树总结</a>】</p><p>实现树的层次遍历，使用popleft()方法可以提升效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python内置模块collections解析&quot;&gt;&lt;a href=&quot;#Python内置模块collections解析&quot; class=&quot;headerlink&quot; title=&quot;Python内置模块collections解析&quot;&gt;&lt;/a&gt;Python内置模块collect</summary>
      
    
    
    
    
    <category term="Python" scheme="https://guoxiansen.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常见限流算法</title>
    <link href="https://guoxiansen.github.io/2024/03/25/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>https://guoxiansen.github.io/2024/03/25/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</id>
    <published>2024-03-25T00:40:04.000Z</published>
    <updated>2024-09-29T06:07:52.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250840747.png" alt="image-20240325084030703"></p><h1 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h1><p>限流算法主要是为了防止系统过载或者应对突发流量，是一种用于控制数据流速度的技术。主要包括下面四种方法：</p><ul><li>固定窗口限流算法</li><li>滑动窗口限流算法</li><li>漏桶限流算法</li><li>令牌桶限流算法</li></ul><h2 id="滑动窗口限流算法"><a href="#滑动窗口限流算法" class="headerlink" title="滑动窗口限流算法"></a>滑动窗口限流算法</h2><p>有时候用户的一些无意义或者非法操作，例如频繁的发送短信、频繁的修改个人信息等操作就是无意义或者非法的，因此我们要针对这些操作进行限流。</p><p>限流的主要核心思路就是使用redis的zset结合滑动窗口限流算法，</p><p>针对这些行为，我设计了一个通用的接口，思路上是使用时间窗口限流算法，具体实现我使用zset进行的。</p><p>比如用户五分钟内只能发送三条验证码，于是就将用户发送短信的行为设计为redis的key，格式为：</p><p><strong>场景:行为:用户唯一标识</strong>，zset的score分数值为时间戳，value值也是时间戳。</p><p>具体的流程为：</p><ul><li><p>当用户每次发生这样的限流行为，我就会在Redis中进行记录，</p></li><li><p>在业务处理中，使用Redis的api进行查询，本质上就是调用了Redis的<code>zcount</code>命令去统计，传入开始score值和结束score值，我们以当前时间戳作为结束分值，然后使用当前时间去减去限流时间，例如五分钟，求出五分钟之前的时间戳，于是根据这两个时间戳作为score分值，查询这个范围中限流行为的发生次数，判断该行为一共触发了几次。</p></li><li><p>后续的业务中，就根据不同的场景和需要进行校验。</p></li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p><img src="http://xiaobaoqiu.github.io/images/guava/rate-limit1.png" alt="img"></p><p>漏铜算法的原理就是有一个容量固定的漏洞，会以一定的速度注入水流（指的是请求的流量），同时以一定的出水速度流出（指的是处理请求的速度），如果漏桶装满了，那么剩余的请求就会抛弃不再处理了。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法控制令牌生成的速度，取令牌的速度不进行控制</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404280947793.png" alt="image-20240428094748070"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404280929751.jpeg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403250840747.png&quot; alt=&quot;image-20240325084030703&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;常见限流算法</summary>
      
    
    
    
    
    <category term="限流算法" scheme="https://guoxiansen.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap底层源码分析</title>
    <link href="https://guoxiansen.github.io/2024/03/18/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://guoxiansen.github.io/2024/03/18/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-03-18T02:03:18.000Z</published>
    <updated>2024-04-25T02:48:52.656Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072003833.png" alt="image-20240307200352512"></p><h1 id="HashMap底层源码分析"><a href="#HashMap底层源码分析" class="headerlink" title="HashMap底层源码分析"></a>HashMap底层源码分析</h1><p>HashMap主要是用来存放键值对的，它基于哈希表的Map接口实现，是常用的Java集合之一，是非线程安全的。</p><p>HashMap可以存放null的Key和value，但是null作为键只能有一个，作为value可以有多个</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">V <strong>put</strong>(K key, V value)</td><td align="center">添加元素</td></tr><tr><td align="center">V <strong>remove</strong>(Object key)</td><td align="center">根据键删除键值对元素</td></tr><tr><td align="center"><strong>void</strong> clear()</td><td align="center">移除所有的键值对元素</td></tr><tr><td align="center">boolean <strong>containsKey</strong>(Object key)</td><td align="center">判断集合是否包含指定的键</td></tr><tr><td align="center">boolean <strong>containsValue</strong>(Object value)</td><td align="center">判断集合是否包含指定的值</td></tr><tr><td align="center">boolean <strong>isEmpty</strong>()</td><td align="center">判断集合是否为空</td></tr><tr><td align="center">int <strong>size</strong>()</td><td align="center">集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><h3 id="HashMap内部方法"><a href="#HashMap内部方法" class="headerlink" title="HashMap内部方法"></a>HashMap内部方法</h3><p>图标为<code>m</code>表示<code>method</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181611363.png" alt="image-20240318161136018"></p><h3 id="HashMap内部类"><a href="#HashMap内部类" class="headerlink" title="HashMap内部类"></a>HashMap内部类</h3><p>图标为<code>c</code>表示<code>class</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181613451.png" alt="image-20240318161323108"></p><h3 id="HashMap内部属性"><a href="#HashMap内部属性" class="headerlink" title="HashMap内部属性"></a>HashMap内部属性</h3><p>图标为<code>f</code>表示<code>field</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403181613605.png" alt="image-20240318161341292"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>HashMap中每个元素都是一个Entry对象</p><p>jdk1.7及之前的底层实现为：数组+链表</p><p>jdk1.8之后的底层实现为：数组+链表+红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示数组默认的大小 为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示默认的负载因子（加载因子）为0.75</span></span><br><span class="line"><span class="comment">// 当数组元素个数超过0.75*16=12的时候就进行扩容，扩容为原来的2倍空间大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示HashMap最大的空间为 1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>空参构造方法只是进行<code>loadFactor</code>进行了初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap中的Hash值只与键有关系与值无关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回键所对应的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&gt;&gt;&gt;</code> 表示无符号右移</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>调用空参构造的时候，只把属性<code>loadFactor</code>初始化为0.75</p><p>剩余的核心源码主要涉及到<strong>PUT操作</strong>：【put操作首先通过hash值定位到数组下标】</p><ul><li>如果当前位置没有值，则直接在<strong>数组</strong>中添加该键值对，即Node对象<ul><li>如果数组长度超过其初始长度16*0.75=12的时候，则会进行扩容，扩容成原来的2倍</li></ul></li><li>如果当前位置有值，在判断两者的key是否相等：<ul><li>key一样：<ul><li>则进行覆盖更新</li></ul></li><li>key不一样：<ul><li>则在其后以链表的形式进行追加。</li><li>当链表的长度达到8【<code>TREEIFY_THRESHOLD</code>】的时候，则会调用<code>treeifyBin()</code>方法，此方法会根据HashMap数组长度来判断是否需要转成红黑树。只有当数组长度大于或者等于64【<code>MIN_TREEIFY_CAPACITY</code>】的情况下，才会执行转换红黑树的操作，以减少搜索时间。否则就只执行<code>resize()</code>方法对数组进行扩容。</li></ul></li></ul></li></ul><p><strong>get操作：</strong></p><p>判断是否存在以key为key的键值对映射，如果不存在返回null；如果存在则返回<code>e.value</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072003833.png&quot; alt=&quot;image-20240307200352512&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashMa</summary>
      
    
    
    
    
    <category term="HashMap" scheme="https://guoxiansen.github.io/tags/HashMap/"/>
    
    <category term="哈希表" scheme="https://guoxiansen.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://guoxiansen.github.io/2024/03/15/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://guoxiansen.github.io/2024/03/15/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2024-03-15T13:15:28.000Z</published>
    <updated>2024-03-26T02:40:50.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种特殊的数据结构，由数据表中的一列或者多列组成，可以用来快速查询数据库中的某一特定值的记录。</p><h2 id="索引的类型有哪些？"><a href="#索引的类型有哪些？" class="headerlink" title="索引的类型有哪些？"></a>索引的类型有哪些？</h2><h3 id="按照数据结构的维度进行划分："><a href="#按照数据结构的维度进行划分：" class="headerlink" title="按照数据结构的维度进行划分："></a>按照数据结构的维度进行划分：</h3><ul><li>BTree索引</li><li>哈希索引</li><li>RTree索引</li><li>全文索引<ul><li>对文本的内容进行分词，进行索引。目前只有CHAR、VARCHAR、TEXT列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如ElasticSearch代替。</li></ul></li></ul><h3 id="按照应用的维度划分："><a href="#按照应用的维度划分：" class="headerlink" title="按照应用的维度划分："></a>按照应用的维度划分：</h3><ul><li><p><strong>单列索引</strong></p><ul><li></li></ul></li><li><p><strong>联合索引</strong></p><ul><li>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li></ul></li><li><p>主键索引</p><ul><li>加速查询+列值唯一（不可以有NULL）</li></ul></li><li><p>普通索引</p><ul><li>仅加速查询</li></ul></li><li><p>唯一索引</p><ul><li>加速查询+列值唯一（可以有NULL）</li></ul></li><li><p>覆盖索引</p><ul><li>一个索引包含或者说覆盖所有需要查询的字段值</li></ul></li><li><p>全文索引</p></li></ul><p>联合索引：</p><p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或者复合索引。</p><p>以score和name两个字段建立联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`cus_order`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> id_score_name(score, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure><p>最左匹配原则，在使用联合索引的时候，mysql会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用字段过滤掉一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code>**、</strong><code>&lt;</code>** ）才会停止匹配。对于 <strong><code>&gt;=</code>**、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code>** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><p>在navicat中创建索引</p><h2 id="使用索引注意事项"><a href="#使用索引注意事项" class="headerlink" title="使用索引注意事项"></a>使用索引注意事项</h2><h3 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h3><ul><li><p>不为NULL字段：索引字段的数据应该尽量不为NULL，因为对数据为NULL的字段，数据库较难优化。如果字段频繁查询，但又避免不了为NULL，建议使用1，true，false这样语义较为清晰的短值或者短字符作为替代。</p></li><li><p>被频繁查询的字段：</p></li><li><p>被作为查询条件的字段</p></li><li><p>频繁需要排序的字段</p></li><li><p>被经常频繁用于连接的字段：</p></li><li><p>尽可能考虑建立联合索引而不是单列索引</p></li></ul><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><h2 id="为什么要用索引？"><a href="#为什么要用索引？" class="headerlink" title="为什么要用索引？"></a>为什么要用索引？</h2><p>这里我首先在数据库中插入了500多万条数据</p><p>创建数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_data`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`random`</span> <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>这里我用java的代码来往数据库中反复的插入数据， 具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertDataDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initConn</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/testdb?&quot;</span></span><br><span class="line">                + <span class="string">&quot;user=root&amp;password=xxxxxx&amp;useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamically load mysql driver</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Successfully loaded MySQL driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomStr</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Define an empty string</span></span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="comment">// Generate an int type integer between 97 ~ 122</span></span><br><span class="line">            <span class="keyword">int</span> intVal = (<span class="keyword">int</span>) (Math.random() * <span class="number">26</span> + <span class="number">97</span>);</span><br><span class="line">            <span class="comment">// Force conversion (char) intVal Convert the corresponding value to the corresponding character, and splicing the characters</span></span><br><span class="line">            result = result + (<span class="keyword">char</span>) intVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Output string</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> insertNum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// open time</span></span><br><span class="line">        Long begin = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Start Inserting Data...&quot;</span>);</span><br><span class="line">        <span class="comment">// sql prefix</span></span><br><span class="line">        String prefix = <span class="string">&quot;INSERT INTO tb_data (id, user_name, create_time, random) VALUES &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// save the sql suffix</span></span><br><span class="line">            StringBuffer suffix = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// Set the transaction to non-automatic commit</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            PreparedStatement pst = conn.prepareStatement(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= insertNum; i++) &#123;</span><br><span class="line">                <span class="comment">// Build sql suffix</span></span><br><span class="line">                suffix.append(<span class="string">&quot;(&quot;</span> + i + <span class="string">&quot;,&#x27;&quot;</span> + randomStr(<span class="number">8</span>) + <span class="string">&quot;&#x27;, SYSDATE(), &quot;</span> + i * Math.random() + <span class="string">&quot;),&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Build a complete sql</span></span><br><span class="line">            String sql = prefix + suffix.substring(<span class="number">0</span>, suffix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// Add execution sql</span></span><br><span class="line">            pst.addBatch(sql);</span><br><span class="line">            <span class="comment">// perform the operation</span></span><br><span class="line">            pst.executeBatch();</span><br><span class="line">            <span class="comment">// commit the transaction</span></span><br><span class="line">            conn.commit();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// close the connection</span></span><br><span class="line">            pst.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// End Time</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;insert&quot;</span> + insertNum + <span class="string">&quot; data data is completed!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Time-consuming : &quot;</span> + (end - begin) / <span class="number">1000</span> + <span class="string">&quot;seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        initConn();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            insert(<span class="number">50000</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到现在数据库中一共有523万条数据</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152118596.png" alt="image-20240315211801264"></p><p>现在我来随机进行一条user_name数据的查询，可以看到耗时39秒</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152119959.png" alt="image-20240315211945502"></p><h3 id="慢SQL查询"><a href="#慢SQL查询" class="headerlink" title="慢SQL查询"></a>慢SQL查询</h3><p>这里也是一道常见的面试问题，一般而言，可以在MySQL配置文件中开启慢查询日志，打开my.ini文件，找到<code>slow_query_log</code>，将其参数修改为<code>ON</code>，同时可以设置<code>long_query_time</code>来定义慢查询的阈值（以秒为单位，默认为10秒）。然后我们可以在本地的<code>hostname-slow.log</code>文件中查看到之前的慢sql语句。</p><p>注意：这里的<code>hostname</code>是指你笔记本/服务器的主机名称</p><p>打开文件，直接到最后：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152126574.png" alt="image-20240315212601235"></p><p>可以看到我刚进行的几条sql语句因为时间过长都被记录在日志当中了。然后开发人员就可以根据SQL语句来进行针对性的优化，这里我进行设置索引</p><p>这里也可以使用<code>EXPLAIN</code>语句查看这条SQL语句慢的原因：可以看到这里涉及到了523w行记录，所以会慢，因此我们可以考虑添加数据库索引</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152151306.png" alt="image-20240315215146207"></p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_user_name <span class="keyword">ON</span> tb_data (user_name);</span><br></pre></td></tr></table></figure><p>这样的方式我们就可以在tb_data表中给user_name列创建了一个名为idx_user_name的索引</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152155913.png" alt="image-20240315215538262"></p><p>创建索引的时间也比较漫长，可以看到花费了一百多秒</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152210565.png" alt="image-20240315221023511"></p><p>索引在本地也会生成一个<code>.MYI</code>的文件，思想是以空间换时间</p><p>现在我们在执行刚刚的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_data <span class="keyword">WHERE</span> user_name=<span class="string">&quot;gdpzfbho&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152157326.png" alt="image-20240315215701951"></p><p>可以看到查询时间肉眼可见的降低。</p><p>同时再次使用<code>explain</code>语句进行查询</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261040947.png" alt="image-20240315221419192"></p><p>发现这条命令已经是通过索引走的了</p><p>查看数据库引擎</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403152208450.png" alt="image-20240315220851579"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;h2 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://guoxiansen.github.io/tags/MySQL/"/>
    
    <category term="索引" scheme="https://guoxiansen.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>

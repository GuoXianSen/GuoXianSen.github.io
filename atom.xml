<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clay_Guo的博客</title>
  
  
  <link href="https://guoxiansen.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoxiansen.github.io/"/>
  <updated>2023-11-21T07:08:43.632Z</updated>
  <id>https://guoxiansen.github.io/</id>
  
  <author>
    <name>Clay_Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树相关总结</title>
    <link href="https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://guoxiansen.github.io/2023/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</id>
    <published>2023-11-02T11:30:47.000Z</published>
    <updated>2023-11-21T07:08:43.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021939061.png" alt="image-20231102193927953"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的理论基础"><a href="#二叉树的理论基础" class="headerlink" title="二叉树的理论基础"></a>二叉树的理论基础</h2><p>二叉树是结点的度数之和不超过2的树，二叉树总共有五种基本形态</p><p>二叉树的种类主要有</p><ul><li>满二叉树</li><li>完全二叉树</li></ul><p>二叉树的存储方式</p><ul><li>顺序存储</li><li>链式存储</li></ul><p>二叉树的遍历方式</p><ul><li>先序遍历（深度优先搜索）</li><li>中序遍历（深度优先搜索）</li><li>后序遍历（深度优先搜索）</li><li>层次遍历（广度优先搜索）</li></ul><p>对于二叉树结点的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">       <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val] </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311022036965.png" alt="image-20231102203600726"></p><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>方法1：利用栈先进后出的性质，先把右孩子结点放入栈中，再将左孩子结点放入栈中，这样就可以先访问根节点， 在访问左孩子，最后访问右孩子了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># print(node)</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2：按照中序遍历的算法，只需要将添加<code>append</code>操作放到前面去即可。但需要控制两个指针。</p><p>思路：沿着左子树一直往左下方走，左孩子不为空就一直进栈，同时将其值添加到res列表中。如果左孩子为空，则弹出栈顶元素，然后再访问该结点的右孩子，再重复上述的操作直到遍历结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历参考先序遍历<strong>思路2</strong>，区别就是只需要<code>append</code>语句放到当<code>cur</code>指针为空的时候里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311022035056.png" alt="image-20231102203511759"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>思路：在进行先序遍历的时候，我们的思路是利用栈，首先访问根结点，然后将右子树添加到栈中，再将左子树添加到栈中，实现的效果是<strong>根左右</strong>的效果，而在进行后序遍历的时候，我们需要的的顺序是<strong>左右根</strong>，如果我们先序遍历算法中左右子树进栈的顺序修改之后，刚好可以得到我们后续遍历结果的逆序结果，最终的返回值设置为<code>res[::-1]</code>即为最终答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.left &#x3D; left</span><br><span class="line">#         self.right &#x3D; right</span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        stack &#x3D; [root]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while stack:</span><br><span class="line">            node &#x3D; stack.pop()</span><br><span class="line">            # 根 右 左</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        # 左 右 根</span><br><span class="line">        return res[::-1]</span><br></pre></td></tr></table></figure><h2 id="二叉树三种遍历算法的统一非递归算法"><a href="#二叉树三种遍历算法的统一非递归算法" class="headerlink" title="二叉树三种遍历算法的统一非递归算法"></a>二叉树三种遍历算法的统一非递归算法</h2><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>层次遍历需要借助队列来实现，队列先进先出的特点可以很好的满足层次遍历按层遍历的需要。</p><p>代码模板（以力扣为标准）</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021933135.png" alt="image-20231102193339525"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stack)):</span><br><span class="line">                node = stack.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021936728.png" alt="image-20231102193628125"></p><p>二叉树的层次遍历可以衍生出非常多的变种题目。</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II(opens new window)</a><ul><li>本题和层次遍历的区别就是只需要返回res列表的逆序即可。</li></ul></li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图(opens new window)</a></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II(opens new window)</a></li><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度</a></li></ul><h3 id="199、二叉树的右视图"><a href="#199、二叉树的右视图" class="headerlink" title="199、二叉树的右视图"></a>199、二叉树的右视图</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031016316.png" alt="image-20231103101656058"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># tmp.append(node.val)</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                tmp = node.val</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031016068.png" alt="image-20231103101640796"></p><h3 id="111、二叉树的最小深度"><a href="#111、二叉树的最小深度" class="headerlink" title="111、二叉树的最小深度"></a>111、二叉树的最小深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311060955485.png" alt="image-20231106095458959"></p><p>本题的解题思路与二叉树的最大深度大同小异，唯一的区别就是在循环中进行判断当前节点的左右孩子结点是否为空，如果为空，则直接返回depth即可，如果不为空就一直进行循环，最后再返回depth，代码的主体框架与层次遍历是一致的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311060957166.png" alt="层次遍历时间"></p><h2 id="二叉树的深度与高度"><a href="#二叉树的深度与高度" class="headerlink" title="二叉树的深度与高度"></a>二叉树的深度与高度</h2><p>二叉树的深度与高度有一些区别，其中二叉树中的深度是指从根结点到该节点的路径长度。高度是指从叶子结点到当前结点的路径长度。</p><p>结点的<strong>深度</strong>是从根结点开始<strong>自顶向下</strong>逐层累加的。</p><p>结点的<strong>高度</strong>是从叶子结点开始<strong>自底向上</strong>逐层累加的。</p><p>在力扣中有几道题目是与二叉树的深度相关，一般而言如果是需要求深度的，都采用先序遍历的方法，因为先序遍历先遍历根结点，然后遍历孩子结点就可以得出其深度。满足其自顶向下的特点。一般而言可以采用递归方法。</p><p>深度：先序遍历 | 层次遍历</p><p>高度：后续遍历</p><ul><li>104.二叉树的最大深度</li><li>559.n叉树的最大深度</li><li>111.二叉树的最小深度</li></ul><p>根结点的高度就是二叉树的最大深度。</p><h3 id="104、二叉树的最大深度"><a href="#104、二叉树的最大深度" class="headerlink" title="104、二叉树的最大深度"></a>104、二叉树的最大深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131941621.png" alt="image-20231113191706720"></p><p>求最大深度，需要从根结点开始自定向下进行深度优先搜索DFS，因此采用先序遍历，采用递归的实现方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先序遍历求最大深度 根左右   深度是从根节点到最后  高度是从叶子结点到当前节点的高度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line">        height = <span class="number">1</span> + <span class="built_in">max</span>(left_height,right_height)</span><br><span class="line">        <span class="keyword">return</span> height</span><br></pre></td></tr></table></figure><p>其中代码还可以精简为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(self.maxDepth(root.left),self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940044.png" alt="image-20231113192723426"></p><h3 id="559、n叉树的最大深度"><a href="#559、n叉树的最大深度" class="headerlink" title="559、n叉树的最大深度"></a>559、n叉树的最大深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940525.png" alt="image-20231113192558344"></p><p>解题思路与二叉树的最大深度一致，唯一的区别就是通过for循环去遍历孩子结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> root.children:</span><br><span class="line">            max_depth = <span class="built_in">max</span>(max_depth,self.maxDepth(ch))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max_depth</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940106.png" alt="image-20231113192704871"></p><h3 id="111、二叉树的最小深度-1"><a href="#111、二叉树的最小深度-1" class="headerlink" title="111、二叉树的最小深度"></a>111、二叉树的最小深度</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940290.png" alt="image-20231113192853117"></p><p>解题思路和求最大深度差不多，但是又有一个特殊情况，就是当二叉树为单分支的情况，即当出现某个节点的左孩子或者右孩子其中之一为空的时候，深度就要取最右孩子中的最大值了，否则就会结果为0+1。其余的情况就取最小值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_depth = self.minDepth(root.left)</span><br><span class="line">        right_depth = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left_depth,right_depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">min</span>(left_depth,right_depth)</span><br></pre></td></tr></table></figure><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><h3 id="110、平衡二叉树"><a href="#110、平衡二叉树" class="headerlink" title="110、平衡二叉树"></a>110、平衡二叉树</h3><p>平衡二叉树的定义是左右子树的高度之差不超过1的二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311131940948.png" alt="image-20231113193458877"></p><p>代码</p><p>定义一个获取结点高度的函数<code>get_height()</code>，如果当前结点为空，则返回0，然后分别获取该结点左孩子和右孩子的高度，如果左右孩子高度返回值是-1，则也返回-1，否则在判断左右子树高度之差是否大于1，如果大于1则也返回-1，如果左右子树高度之差小于1，则返回<code>1+max(left_height, right_height)</code>。主程序中，只需要判断对根节点进行判断<code>get_height(root)</code>是否为-1即可判断该二叉树是否是平衡二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_height</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_height = get_height(root.left)</span><br><span class="line">            <span class="keyword">if</span> left_height==-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            right_height = get_height(root.right)</span><br><span class="line">            <span class="keyword">if</span> right_height==-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(left_height-right_height)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(left_height,right_height)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> get_height(root)!=-<span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141931314.png" alt="image-20231114193151177"></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="116、翻转二叉树"><a href="#116、翻转二叉树" class="headerlink" title="116、翻转二叉树"></a>116、翻转二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141348128.png" alt="image-20231114134848424"></p><p>由示例可以看出，本题实际上需要实现的功能是沿着中间的一个轴翻转这颗二叉树，其本质实际只需要将二叉树每个结点的左右子树进行翻转即可。</p><p>需要注意的是，本题不能采用中序遍历的方法，可以采用先序遍历或者后序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>中序遍历的时候可能会对一些节点重复的调换导致错误。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141442054.png" alt="image-20231114144227076"></p><h2 id="101、对称二叉树"><a href="#101、对称二叉树" class="headerlink" title="101、对称二叉树"></a>101、对称二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311031112657.png" alt="image-20231103111251882"></p><p>本题思路与翻转二叉树有点区别，翻转二叉树是直接对比左右孩子结点的值是否相等即可判断，而本题需要判断的是（例如在第三层中，判断根节点左孩子2的左孩子是否与根结点右孩子2的右孩子是否相等）对比的其实是外侧与外侧，内侧与内侧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">left,right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            out = compare(left.left,right.right)</span><br><span class="line">            inner = compare(left.right,right.left)</span><br><span class="line">            <span class="keyword">return</span> out <span class="keyword">and</span> inner</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right)</span><br></pre></td></tr></table></figure><h2 id="100、相同的树"><a href="#100、相同的树" class="headerlink" title="100、相同的树"></a>100、相同的树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141526042.png" alt="image-20231114152650867"></p><p>思路基本与对称二叉树一致，需要对两棵树的结点的值以及左右子树的值进行对比，如果不相同则返回，相等则继续递归，知道递归结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        if not p and not q: return True</span><br><span class="line">        elif not p or not q: return False</span><br><span class="line">        elif p.val!&#x3D;q.val: return False</span><br><span class="line"></span><br><span class="line">        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141527981.png" alt="image-20231114152707949"></p><h2 id="572、另一棵树的子树"><a href="#572、另一棵树的子树" class="headerlink" title="572、另一棵树的子树"></a>572、另一棵树的子树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141519990.png" alt="image-20231114151903739"></p><p>解题思路与相同的树一致，只需要遍历<code>root</code>这棵树的每个结点，然后再与<code>subRoot</code>进行判断是否是相同的树即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root: Optional[TreeNode], subRoot: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSame</span>(<span class="params">s,t</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> s.val!=t.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> isSame(s.left,t.left) <span class="keyword">and</span> isSame(s.right,t.right)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 遍历root的所有结点与subRoot进行比较</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isSame(node,subRoot):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141520178.png" alt="image-20231114152036046"></p><h2 id="222、完全二叉树的节点数量"><a href="#222、完全二叉树的节点数量" class="headerlink" title="222、完全二叉树的节点数量"></a>222、完全二叉树的节点数量</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061044923.png" alt="image-20231106104412026"></p><p>解题思路1：可以直接按照普通二叉树的遍历进行记录总共多少个结点（前中后序遍历+层次遍历都可以解决这个问题），时间复杂度为 O(n)</p><p>（此方法没有利用完全二叉树的性质）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061046621.png" alt="image-20231106104634852"></p><p>使用层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                num+=<span class="number">1</span></span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141934586.png" alt="image-20231114193418762"></p><p>解题思路2：利用完全二叉树的性质，如果是满二叉树结点的数量可以用2的深度-1次方 再 -1 来进行计算。时间复杂度为O(logn * logn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        leftdepth = <span class="number">0</span></span><br><span class="line">        rightdepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            leftdepth+=<span class="number">1</span></span><br><span class="line">            left=left.left</span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            rightdepth+=<span class="number">1</span></span><br><span class="line">            right=right.right</span><br><span class="line">        <span class="keyword">if</span> leftdepth==rightdepth:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftdepth)-<span class="number">1</span></span><br><span class="line">        leftnum = self.countNodes(root.left)</span><br><span class="line">        rightnum = self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">return</span> leftnum+rightnum+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311061049909.png" alt="image-20231106104900697"></p><h2 id="257、二叉树的所有路径"><a href="#257、二叉树的所有路径" class="headerlink" title="257、二叉树的所有路径"></a>257、二叉树的所有路径</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141554968.png" alt="image-20231114155412077"></p><p>本题使用DFS与BFS均可解决。</p><p>使用DFS的时候需要注意在递归的过程中如果当前结点为空则不进行处理，不为空时才进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 使用DFS解决</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="comment"># node结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                path+=<span class="built_in">str</span>(node.val)</span><br><span class="line">                <span class="comment"># 叶子结点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    paths.append(path)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path+=<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        paths = []</span><br><span class="line">        find_path(root,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141605715.png" alt="image-20231114160516588"></p><p>使用BFS解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 使用BFS 层次遍历</span></span><br><span class="line">        paths = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> paths</span><br><span class="line">        </span><br><span class="line">        queue = [root]</span><br><span class="line">        path_lst = [<span class="built_in">str</span>(root.val)]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            path = path_lst.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                paths.append(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                    path_lst.append(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(node.left.val))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                    path_lst.append(path+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141625644.png" alt="image-20231114162537557"></p><h2 id="113、路径总和II"><a href="#113、路径总和II" class="headerlink" title="113、路径总和II"></a>113、路径总和II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141607596.png" alt="image-20231114160701463"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="comment"># path+=[node.val]</span></span><br><span class="line">                path=path+[node.val]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span>(path)==targetSum:</span><br><span class="line"></span><br><span class="line">                        paths.append(path)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        paths = []</span><br><span class="line">        find_path(root,[])</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141618342.png" alt="image-20231114161838454"></p><p>这里需要注意一个问题，就是<code>path+=[node.val]</code>和<code>path=path+[node.val]</code>这两句代码的写法有点不同，+=是在原来的path上进行修改，而直接赋值是可以形成一个新的列表，在递归的过程中就出现一个新的列表。这是由于python中列表是可变类型的，如果列表也是和字符串一样属于不可变类型的话，就可以直接使用+=操作了。</p><h2 id="988、从叶结点开始的最小字符串"><a href="#988、从叶结点开始的最小字符串" class="headerlink" title="988、从叶结点开始的最小字符串"></a>988、从叶结点开始的最小字符串</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141700936.png" alt="image-20231114170051688"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141701926.png" alt="image-20231114170117467"></p><p>本题思路与二叉树的所有路径思路一致，只需要在其中添加一个用来进行比较的变量即可，注意这里所说的变量不可以是字符串，因为字符串是不可修改的。这里也需要注意是从叶子结点开始的，所以最终求得的路径path需要进行逆序处理[::-1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestFromLeaf</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">node,path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                path+=<span class="built_in">str</span>(myhash[node.val])</span><br><span class="line">                <span class="comment"># print(node.val,path)</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    minleaf[<span class="number">0</span>] = <span class="built_in">min</span>(minleaf[<span class="number">0</span>],path[::-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    find_path(node.left,path)</span><br><span class="line">                    find_path(node.right,path)</span><br><span class="line">        myhash = &#123;i: <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)&#125;</span><br><span class="line">        minleaf = [<span class="string">&quot;z&quot;</span>*<span class="number">8500</span>]</span><br><span class="line">        find_path(root,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> minleaf[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311141702599.png" alt="image-20231114170241494"></p><h2 id="404、左叶子之和"><a href="#404、左叶子之和" class="headerlink" title="404、左叶子之和"></a>404、左叶子之和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311142043922.png" alt="image-20231114204344749"></p><p>思路：</p><p>本题采用DFS的方式去解决。需要注意到底什么是左叶子，左叶子是指该节点不为空，同时其左右孩子为空，通过递归的方式去寻找这样的结点，然后对其求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 递归程序如果碰到结点为空则返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果该节点没有左右孩子 也返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        left_num = self.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="comment"># 如果有左孩子并且孩子为叶子结点则进行统计</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            left_num = root.left.val</span><br><span class="line">        right_num = self.sumOfLeftLeaves(root.right)</span><br><span class="line">        <span class="keyword">return</span> left_num + right_num</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311161713500.png" alt="image-20231116171305355"></p><h2 id="236、二叉树的最近公共祖先"><a href="#236、二叉树的最近公共祖先" class="headerlink" title="236、二叉树的最近公共祖先"></a>236、二叉树的最近公共祖先</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311161714944.png" alt="image-20231116171451621"></p><p>从下往上对结点进行处理，采用后序遍历的方法，先左再右再中</p><p>情况1： p和q都为某个节点的孩子结点</p><p>情况2：p是q的父节点或者q是p的父节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root==q <span class="keyword">or</span> root==p:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> right <span class="keyword">and</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h2 id="106、从中序和后序遍历序列构造二叉树"><a href="#106、从中序和后序遍历序列构造二叉树" class="headerlink" title="106、从中序和后序遍历序列构造二叉树"></a>106、从中序和后序遍历序列构造二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171658001.png" alt="image-20231117165833569"></p><p>思路：</p><p>首先在后序遍历序列中找到根结点，然后创建一个根节点</p><p>找到切割的位置</p><ul><li><p>对先序序列进行切割，分为左子树和右子树</p></li><li><p>对后序序列进行切割，分为左子树和右子树</p></li><li><p>构造根节点的左子树，使用递归的方法，传递进去的参数是先序数组的左边和中序数组的左边</p></li><li><p>构造根节点的右子树，使用递归的方法，传递进去的参数是先序数组的右边和中序数组的右边</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到根结点</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        <span class="comment"># 找到切割位置</span></span><br><span class="line">        qiege = inorder.index(root_val)</span><br><span class="line"></span><br><span class="line">        inorder_left = inorder[:qiege]</span><br><span class="line">        inorder_right = inorder[qiege+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        postorder_left = postorder[:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = self.buildTree(inorder_left,postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right,postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="654、最大二叉树"><a href="#654、最大二叉树" class="headerlink" title="654、最大二叉树"></a>654、最大二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171926482.png" alt="image-20231117192616419"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171926733.png" alt="image-20231117192638755"></p><p>思路：使用递归的方式</p><p>首先根据最大值对该数组进行切割，切割完毕后，根据数组的左边与右边分别进行递归，这类似于106从中序和后序遍历序列构造二叉树。最终返回构造好的二叉树root。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        root_val = <span class="built_in">max</span>(nums)</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">        qiege = nums.index(root_val)</span><br><span class="line">        nums_left = nums[:qiege]</span><br><span class="line">        nums_right = nums[qiege+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums_left)</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171928921.png" alt="image-20231117192833812"></p><h2 id="998、最大二叉树II"><a href="#998、最大二叉树II" class="headerlink" title="998、最大二叉树II"></a>998、最大二叉树II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929018.png" alt="image-20231117192902002"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929352.png" alt="image-20231117192919398"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929719.png" alt="image-20231117192933861"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311171929329.png" alt="image-20231117192954360"></p><p>本题和上一题相比，难点就在于可能需要对这颗二叉树进行重新构造，但是在构造的过程中也有省事的地方，就是只需要往右插入。如果<code>val</code>值大于原树的根节点值，则直接将原树放在<code>val</code>结点的左子树即可。如果小于最大值，向右子树进行遍历，同时记录当前结点的父节点，方便<code>val</code>结点的插入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoMaxTree</span>(<span class="params">self, root: Optional[TreeNode], val: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 遍历root 往右子树遍历</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val&gt;val:</span><br><span class="line">            <span class="comment"># 记录当前结点的父节点</span></span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="comment"># 如果val大于原树的最大值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">            node.left = cur</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># 遍历到了右子树合适的位置 换结点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            prev.right = node</span><br><span class="line">            node.left = cur</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="98、验证二叉搜索树（二叉排序树BST）"><a href="#98、验证二叉搜索树（二叉排序树BST）" class="headerlink" title="98、验证二叉搜索树（二叉排序树BST）"></a>98、验证二叉搜索树（二叉排序树BST）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172201462.png" alt="image-20231117220106841"></p><p>本题思路很简单，利用二叉排序树的性质即可：二叉排序树中序遍历的结果是递增的。</p><p>方法：</p><ul><li>采用非递归遍历算法  设置最小值 在中序递归的过程中进行比较</li><li>采用迭代法，设置最小值，如果出现不满足性质的节点直接返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归遍历算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 添加一个最小值 每次进行比较的时候更新最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.min_= <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 左</span></span><br><span class="line">        left = self.isValidBST(root.left)</span><br><span class="line">        <span class="comment"># 根</span></span><br><span class="line">        <span class="keyword">if</span> self.min_ &lt; root.val:</span><br><span class="line">            self.min_ = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        right = self.isValidBST(root.right)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172204241.png" alt="image-20231117220442215"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归遍历算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 中序遍历 判断值是否小于等于</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="comment"># print(min_,p.val)</span></span><br><span class="line">                <span class="keyword">if</span> min_ &lt; p.val:</span><br><span class="line">                    min_ = p.val</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311172204453.png" alt="image-20231117220417506"></p><h2 id="501、二叉搜索树中的众数"><a href="#501、二叉搜索树中的众数" class="headerlink" title="501、二叉搜索树中的众数"></a>501、二叉搜索树中的众数</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311182037439.png" alt="image-20231118203749353"></p><p>思路：</p><p>对二叉树进行中序遍历，遍历的过程中统计字符出现的最大次数。其中在递归的过程中需要将<code>max_freq</code>指定为全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        myhash = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> max_freq</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.left)</span><br><span class="line">            myhash[root.val] = myhash.get(root.val,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, myhash[root.val])</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [k <span class="keyword">for</span> k,v <span class="keyword">in</span> myhash.items() <span class="keyword">if</span> v==max_freq]</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311182037815.png" alt="image-20231118203735546"></p><ul><li>使用迭代法的中序遍历同时不使用字典来统计出现的频率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 使用迭代法的中序遍历</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        freq = <span class="number">0</span></span><br><span class="line">        max_freq = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    freq = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> pre.val == p.val:</span><br><span class="line">                    freq+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freq = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果频率和最大频率相等 则往结果数组中添加</span></span><br><span class="line">                <span class="keyword">if</span> freq==max_freq:</span><br><span class="line">                    res.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> freq &gt; max_freq:</span><br><span class="line">                    res = [p.val]</span><br><span class="line">                    max_freq = freq</span><br><span class="line">                pre = p</span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个方法的核心是用<code>freq</code>和<code>max_freq</code>进行比较，同时使用<code>pre</code>指针指向前一个结点，这样就方便在中旬遍历的过程中记录已经出现的结点值了。有如下几种情况：</p><ul><li>针对<code>pre</code><ul><li>如果<code>pre</code>为<code>None</code>，则更新<code>freq</code>=1</li><li>如果<code>pre</code>不为<code>None</code>且<code>pre</code>的值与<code>p</code>的值相等，则将<code>freq</code>+1</li><li>如果<code>pre</code>不为<code>None</code>且<code>pre</code>的值与``p<code>不相等，仍然将</code>freq`=1</li></ul></li><li>针对<code>freq</code>和<code>max_freq</code><ul><li>如果<code>freq==max_freq</code>，则往返回值的列表中添加该元素（p.val 即结果的众数）</li><li>如果<code>freq&gt;max_freq</code>，则对res列表进行更新，同时更新<code>max_freq</code></li><li>如果<code>freq&lt;max_freq</code>，可以不进行任何处理</li></ul></li></ul><h2 id="701、二叉搜索树中的插入"><a href="#701、二叉搜索树中的插入" class="headerlink" title="701、二叉搜索树中的插入"></a>701、二叉搜索树中的插入</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201059012.png" alt="image-20231120105950581"></p><p>遍历二叉树直到该值应该出现的地方为止，利用二叉搜索树的性质，如果根节点的值小于value，则再右子树进行递归，否则在左子树进行递归。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: Optional[TreeNode], val: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 根</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val&gt;val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201101896.png" alt="image-20231120110120885"></p><h2 id="450、二叉搜索树中的删除"><a href="#450、二叉搜索树中的删除" class="headerlink" title="450、二叉搜索树中的删除"></a>450、二叉搜索树中的删除</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201044219.png" alt="image-20231120104451186"></p><p>题目中要求的返回值是<strong>二叉搜索树中可能被更新的根结点的引用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val==key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left =  self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311201058168.png" alt="image-20231120105811069"></p><h2 id="108、将有序数组转化为二叉搜索树"><a href="#108、将有序数组转化为二叉搜索树" class="headerlink" title="108、将有序数组转化为二叉搜索树"></a>108、将有序数组转化为二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211024882.png" alt="image-20231121102406870"></p><p>思路：本题思路类似于从106、中序和后序遍历构序列构造二叉树和654、最大二叉树的解题思路，需要找到中间的切割点，然后通过递归的方式分别构造左右子树，需要注意的就是对于递归的结束条件的处理如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>一共两种情况，因为再往下就涉及到数组的切割问题。</p><ul><li>如果数组为空，则直接返回None</li><li>如果数组的长度为1，则直接返回以数组中唯一元素构造出二叉树结点即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 本题思路就是通过数组来构造一颗二叉树，需要保持树的平衡，方法将就是从中间进行构造</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        qiege = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># print(qiege)</span></span><br><span class="line">        root = TreeNode(nums[qiege])</span><br><span class="line">        nums_left = nums[:qiege]</span><br><span class="line">        nums_right = nums[qiege+<span class="number">1</span>:]</span><br><span class="line">        root.left = self.sortedArrayToBST(nums_left)</span><br><span class="line">        root.right = self.sortedArrayToBST(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211031663.png" alt="image-20231121103147381"></p><h2 id="538、把二叉搜索树转换为累加树"><a href="#538、把二叉搜索树转换为累加树" class="headerlink" title="538、把二叉搜索树转换为累加树"></a>538、把二叉搜索树转换为累加树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211432312.png" alt="image-20231121143208244"></p><p>针对二叉搜索树的题目，一定要好好利用其中序遍历得到的是一个递增的序列这一性质！！！</p><p>思路：根据题目的要求，本题中的树是二叉搜索树，在中序遍历的过程中是递增的，但是要求实现的是将node节点的的值修改为大于等于该节点值的所有节点值的和。因此我们可以采用逆序中序遍历的方法，逆序中序遍历中的结点值与当前结点的结点值相加起来，得到该结点现在的值。</p><p>需要注意的是，使用Python的时候，局部变量的问题，也就是我们pre指向前一个结点值，我们需要用<code>nonlocal</code> pre来申明<code>pre</code>不是局部变量，这样在递归的过程中才能够访问到外层嵌套函数中定义的<code>pre</code>值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">                <span class="comment"># 使用右中左的遍历顺序进行遍历 往前叠加值</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pre</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(root.right)</span><br><span class="line">            root.val += pre</span><br><span class="line">            pre = root.val</span><br><span class="line">            dfs(root.left)</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root        </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211431170.png" alt="image-20231121143137935"></p><h2 id="1038、从二叉搜索树到更大的和树"><a href="#1038、从二叉搜索树到更大的和树" class="headerlink" title="1038、从二叉搜索树到更大的和树"></a>1038、从二叉搜索树到更大的和树</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211426480.png" alt="image-20231121142641537"></p><p>本题与上一题思路一样，不再重复赘述。</p><h2 id="530、二叉树的最小绝对值差"><a href="#530、二叉树的最小绝对值差" class="headerlink" title="530、二叉树的最小绝对值差"></a>530、二叉树的最小绝对值差</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211435843.png" alt="image-20231121143459700"></p><p>思路：本题的树是二叉搜索树，根据其性质可以进行中序遍历，然后在得到的遍历序列中求最小绝对差</p><p>方法1 递归方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left) + [root.val] + dfs(root.right)</span><br><span class="line">        nums = dfs(root)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">min</span>(<span class="built_in">abs</span>(nums[i]-nums[i+<span class="number">1</span>]),res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>方法2 迭代方法</p><p>在迭代法中，需要用pre记录前一个节点的指针，其初始值可以设置为任意值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 使用中序遍历 然后求差值</span></span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                res = <span class="built_in">min</span>(<span class="built_in">abs</span>(pre-p.val),res)</span><br><span class="line">                pre = p.val</span><br><span class="line">                p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311211504802.png" alt="image-20231121150414365"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311021939061.png&quot; alt=&quot;image-20231102193927953&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉树&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="二叉树" scheme="https://guoxiansen.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux SRv6实验</title>
    <link href="https://guoxiansen.github.io/2023/10/31/Linux-SRv6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://guoxiansen.github.io/2023/10/31/Linux-SRv6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-10-31T11:12:20.000Z</published>
    <updated>2023-10-31T11:55:53.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SRv6实验"><a href="#SRv6实验" class="headerlink" title="SRv6实验"></a>SRv6实验</h1><p><strong>摘要：</strong>本文基于Linux SRv6功能，结合Mininet、Quagga、Python等工具，验证SRv6的一系列功能，包括VPN、流量工程、服务链等。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Linux （推荐Ubuntu20.04）</li><li>最新版Mininet</li><li>Quagga（在Mininet虚拟拓扑下，提供路由器的静态路由/OSPF/BGP等路由协议支持）</li><li>Python（通过脚本建立测试拓扑及初试配置）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Quagga安装"><a href="#Quagga安装" class="headerlink" title="Quagga安装"></a>Quagga安装</h3><p>下载地址</p><p><a href="https://src.fedoraproject.org/repo/pkgs/quagga/">https://src.fedoraproject.org/repo/pkgs/quagga/</a></p><p>下载Quagga1.2.4版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://src.fedoraproject.org/repo/pkgs/quagga/quagga-1.2.4.tar.gz/sha512/3e72440bcccfd3c1a449a62b7ff8623441256399a2bee0a39fa0a19694a5a78ac909c5c2128a24735bc034ea8b0811827293b480a2584a3a4c8ae36be9cf1fcd/quagga-1.2.4.tar.gz</span><br></pre></td></tr></table></figure><p><img src="D:\博客\Hexo\source_posts\images\image-20231031193027677.png" alt="image-20231031193027677"></p><p>安装命令1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-vtysh --enable-user=root --enable-group=root --enable-vty-group=root</span><br></pre></td></tr></table></figure><p>报错</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031193527408.png" alt="image-20231031193527408"></p><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gawk</span><br></pre></td></tr></table></figure><p>重复执行安装命令，继续报错，再来解决</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031194106531.png" alt="image-20231031194106531"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libreadline6-dev</span><br></pre></td></tr></table></figure><p>重复执行安装命令，继续报错，缺少相应的cares资源文件，再来解决</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031194011218.png" alt="image-20231031194011218"></p><p>下载文件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://c-ares.org/download/c-ares-1.12.0.tar.gz</span><br></pre></td></tr></table></figure><p>下载好之后解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ./c-ares-1.12.0.tar.gz</span><br></pre></td></tr></table></figure><p>进入文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd c-ares-1.12.0</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br><span class="line">cp libcares.pc /usr/local/lib/pkgconfig</span><br><span class="line">PKG_CONFIG_PATH=/usr/local/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用第三方库，就少不了要使用到第三方的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库文件的位置。</span></span><br></pre></td></tr></table></figure><p>再次执行命令1，安装无误</p><p><img src="D:\博客\Hexo\source_posts\images\image-20231031195401751.png" alt="image-20231031195401751"></p><p>在Quagga目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="D:\博客\Hexo\source_posts\images\image-20231031195522998.png" alt="image-20231031195522998"></p><h3 id="iproute2安装"><a href="#iproute2安装" class="headerlink" title="iproute2安装"></a>iproute2安装</h3><h2 id="参考Reference"><a href="#参考Reference" class="headerlink" title="参考Reference"></a>参考Reference</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SRv6实验&quot;&gt;&lt;a href=&quot;#SRv6实验&quot; class=&quot;headerlink&quot; title=&quot;SRv6实验&quot;&gt;&lt;/a&gt;SRv6实验&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;本文基于Linux SRv6功能，结合Mininet、Quagga、</summary>
      
    
    
    
    
    <category term="SDN" scheme="https://guoxiansen.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://guoxiansen.github.io/2023/10/21/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://guoxiansen.github.io/2023/10/21/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-10-21T01:53:48.000Z</published>
    <updated>2023-10-30T08:35:54.741Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310210959834.png" alt="image-20231021095935123"></p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>首先介绍一下常见位运算的符号（通常在各个编程语言中位运算的符号都是相似的）</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算，参与运算的两个值如果二进制对应位置都为1结果为1，否则为0</td></tr><tr><td>|</td><td>按位或运算，参与运算的两个值如果二进制对应位置有一个为1结果为1，两个均为0结果才为0</td></tr><tr><td>^</td><td>按位异或运算，当两个二进制位置对应位置不同时，结果为1，否则为0</td></tr><tr><td>~</td><td>按位取反运算，对数据的每个二进制位置取反，把0变为1，把1变为0</td></tr><tr><td>&lt;&lt;</td><td>左移运算符：运算数的各位二进制全部左移若干位，由&lt;&lt;符号右边的数字决定左移多少位，高位丢弃，低位自动补0</td></tr><tr><td>&gt;&gt;</td><td>右移运算符：运算数的各位二进制全部右移若干位，由&gt;&gt;符号右边的数字决定右移多少位。</td></tr></tbody></table><p>位运算在力扣中有很多题目的应用，位运算通常都是常数级别的时间复杂度</p><ol><li><strong>按位与（&amp;）</strong>、<strong>按位或（|）</strong>、<strong>按位异或（^）</strong>等基本位运算的时间复杂度是 O(1)，它们在一个常数时间内完成。</li><li><strong>位左移（&lt;&lt;）**和**位右移（&gt;&gt;）</strong>运算的时间复杂度也是 O(1)，因为它们只是在二进制数的表示上进行了移位操作。</li></ol><h2 id="2135-统计追加字母可以获得的单词"><a href="#2135-统计追加字母可以获得的单词" class="headerlink" title="2135.统计追加字母可以获得的单词"></a>2135.统计追加字母可以获得的单词</h2><h3 id="我第一次解法"><a href="#我第一次解法" class="headerlink" title="我第一次解法"></a>我第一次解法</h3><p>整体思路如下：</p><ol><li>首先将startWords中的单词全部转换为一个集合存放在一个列表中</li><li>将targetWords中的单词也全部转换为集合存放在列表中</li><li>通过两层for循环来遍历所有在target中的单词，和start中的单词集合元素取不同时包含在st集合与ta集合中的元素且要满足ta的长度-1等于st的长度，这样就可以确保由st中的单词随机添加一个就可以构成ta中的单词了</li><li>如果满足条件，将res+1，然后break掉，判断下一个单词是否可以由st中的单词获得</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordCount</span>(<span class="params">self, startWords: List[<span class="built_in">str</span>], targetWords: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = [<span class="built_in">set</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> startWords]</span><br><span class="line">        <span class="comment"># print(&quot;start&quot;,start)</span></span><br><span class="line">        target = [<span class="built_in">set</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> targetWords]</span><br><span class="line">        <span class="comment"># print(&quot;target&quot;,target)</span></span><br><span class="line">        <span class="keyword">for</span> ta <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">for</span> st <span class="keyword">in</span> start:</span><br><span class="line">                <span class="comment"># print(&quot;ta=&#123;&#125;,st=&#123;&#125;&quot;.format(ta,st))</span></span><br><span class="line">                <span class="comment"># if 0&lt;=len((ta-st))&lt;=1 and len((st-ta))==0:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st^ta)==<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(ta)-<span class="number">1</span>==<span class="built_in">len</span>(st):</span><br><span class="line">                    <span class="comment"># print(st)</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于当startWords和targetWords中的单词可能会特别长，在理论上集合最长的情况下，集合取各种关系的时候需要重复遍历整个集合，容易造成很大的时间开销，因此我这个代码在部分测试用例的时候可以通过，整体不能通过</p><h3 id="位运算-哈希表解法"><a href="#位运算-哈希表解法" class="headerlink" title="位运算+哈希表解法"></a>位运算+哈希表解法</h3><p>官方给出的解法是可以使用位运算，我看了下源代码，就是在我用集合进行比较的地方将其换成位运算操作能够极大的减少时间开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordCount</span>(<span class="params">self, startWords: List[<span class="built_in">str</span>], targetWords: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># s是一个用于存放startWords中的元素的哈希表，查询速度为O(1)</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> startWords:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="comment"># 按位或运算 只要对应的二进制有一个为1那么结果就为1，这样就把一个单词中的所有字符用掩码的形式表示出来了</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="comment"># 将每个单词的掩码存放在一个哈希表中</span></span><br><span class="line">            s.add(mask)</span><br><span class="line">        <span class="comment"># print(&quot;startword中的mask&quot;,s)</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> targetWords:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print(&quot;word&quot;,word)</span></span><br><span class="line">            <span class="comment"># 计算整个单词的掩码</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="comment"># 遍历单词，在去掉单词的每个字符的情况下，对比是否在哈希表中，如果在则将结果+1并break出来，</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> mask ^ (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))) <span class="keyword">in</span> s:  <span class="comment"># 去掉这个字符</span></span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>备注：<code>ord()</code>是Python内置方法，用于求一个字符的unicode编码</p><h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371.两整数之和"></a>371.两整数之和</h2><p>给你两个整数<code>a</code>和<code>b</code>，不使用运算符<code>+</code>和<code>-</code>，计算并返回两整数之和。</p><p>思路</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310301635268.png" alt="image-20231026203400843"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310210959834.png&quot; alt=&quot;image-20231021095935123&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;位运算&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python实现单链表（带头结点）</title>
    <link href="https://guoxiansen.github.io/2023/10/20/Python%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89/"/>
    <id>https://guoxiansen.github.io/2023/10/20/Python%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89/</id>
    <published>2023-10-20T08:55:05.000Z</published>
    <updated>2023-10-21T02:22:14.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python实现单链表"><a href="#Python实现单链表" class="headerlink" title="Python实现单链表"></a>Python实现单链表</h1><p>首先定义单个结点的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>单个结点中，包含了一个结点值和下一个结点的指针域</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index = <span class="built_in">max</span>(<span class="number">0</span>, index)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.<span class="built_in">next</span> = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = to_add</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pred = pred.<span class="built_in">next</span></span><br><span class="line">        pred.<span class="built_in">next</span> = pred.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python实现单链表&quot;&gt;&lt;a href=&quot;#Python实现单链表&quot; class=&quot;headerlink&quot; title=&quot;Python实现单链表&quot;&gt;&lt;/a&gt;Python实现单链表&lt;/h1&gt;&lt;p&gt;首先定义单个结点的结构&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    
    <category term="链表" scheme="https://guoxiansen.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>django drf源码之序列化器</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</id>
    <published>2023-10-12T14:01:11.000Z</published>
    <updated>2023-10-12T14:01:11.107Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>django drf源码之解释器</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8/</id>
    <published>2023-10-12T14:00:45.000Z</published>
    <updated>2023-10-12T14:00:46.013Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>django drf源码之API版本管理</title>
    <link href="https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8BAPI%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://guoxiansen.github.io/2023/10/12/django-drf%E6%BA%90%E7%A0%81%E4%B9%8BAPI%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2023-10-12T13:59:55.000Z</published>
    <updated>2023-10-12T14:10:37.148Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122204844.png" alt="image-20231012220431847"></p><h1 id="API版本"><a href="#API版本" class="headerlink" title="API版本"></a>API版本</h1><p>在开发过程中可能会有多版本的API，因此需要对API进行管理。django drf中对于版本的管理也很方便。</p><p><a href="http://www.example.com/api/v1/info">http://www.example.com/api/v1/info</a></p><p><a href="http://www.example.com/api/v2/info">http://www.example.com/api/v2/info</a></p><p>上面这种形式就是很常见的版本管理</p><p>在restful规范中，后端的API需要体现出版本</p><p>在django drf中，共有三种形式的版本管理</p><ol><li>通过GET参数传递</li><li>通过URL路由进行传递</li><li>通过请求头进行传递</li></ol><p>下面将对这三种方法逐一介绍</p><h2 id="1、通过get请求传递版本信息"><a href="#1、通过get请求传递版本信息" class="headerlink" title="1、通过get请求传递版本信息"></a>1、通过get请求传递版本信息</h2><p>视图函数代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.versioning <span class="keyword">import</span> QueryParameterVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeView</span>(<span class="params">APIView</span>):</span></span><br><span class="line">  versioning_class = QueryParameterVersioning</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">      print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">      print(request.versioning_scheme)</span><br><span class="line">      url = request.versioning_scheme.reverse(<span class="string">&quot;home&quot;</span>, request=request)</span><br><span class="line">      print(<span class="string">&quot;drf反向生成的URL为&quot;</span>, url)</span><br><span class="line">      self.dispatch</span><br><span class="line">      <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">123123</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> HomeView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;home/&quot;</span>, HomeView.as_view(), name=<span class="string">&quot;home&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在项目的<code>settings.py</code>文件中，我们还需要进行三个配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># get请求的默认参数名称</span></span><br><span class="line">    <span class="string">&quot;VERSION_PARAM&quot;</span>: <span class="string">&quot;version&quot;</span>,</span><br><span class="line">    <span class="comment"># 默认的版本</span></span><br><span class="line">    <span class="string">&quot;DEFAULT_VERSION&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="comment"># 允许的版本</span></span><br><span class="line">    <span class="string">&quot;ALLOWED_VERSIONS&quot;</span>: [<span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;v3&quot;</span>, <span class="string">&quot;v111&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>VERSION_PARAM</code>代表get请求的默认参数名，后面请求接口<a href="http://127.0.0.1:8000/home/?version=v1%E6%97%B6%EF%BC%8Cdjango%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84version%E8%8E%B7%E5%8F%96%E5%88%B0%EF%BC%8C%E5%B9%B6%E8%B5%8B%E5%80%BC%E5%88%B0request.version%E4%B8%AD%E3%80%82">http://127.0.0.1:8000/home/?version=v1时，django会自动将参数中的version获取到，并赋值到request.version中。</a></p><p>具体的可以参考drf中通过get请求传递版本对应部分的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryParameterVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    GET /something/?version=0.1 HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in query parameter.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用来提取版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 从请求的参数中先获取有没有版本，如果没有版本则赋值为默认的版本参数</span></span><br><span class="line">        version = request.query_params.get(self.version_param, self.default_version)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotFound(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line">    <span class="comment"># 用来方向生成URL</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, viewname, args=<span class="literal">None</span>, kwargs=<span class="literal">None</span>, request=<span class="literal">None</span>, <span class="built_in">format</span>=<span class="literal">None</span>, **extra</span>):</span></span><br><span class="line">        url = <span class="built_in">super</span>().reverse(</span><br><span class="line">            viewname, args, kwargs, request, <span class="built_in">format</span>, **extra</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> request.version <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> replace_query_param(url, self.version_param, request.version)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><p>QueryParameterVersioning类继承自BaseVersioing类。在BaseVersioing类中，有三个默认的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseVersioning</span>:</span></span><br><span class="line">    default_version = api_settings.DEFAULT_VERSION</span><br><span class="line">    allowed_versions = api_settings.ALLOWED_VERSIONS</span><br><span class="line">    version_param = api_settings.VERSION_PARAM</span><br></pre></td></tr></table></figure><p><code>default_version</code> 代表默认的版本，会自动去全局配置中寻找，如果全局中没有配置则去局部进行寻找</p><p><code>allowed_versions</code> 代表允许的版本号，会自动取<code>settings.py</code>文件中去读取相应的配置</p><p><code>version_param</code> 代表get请求参数中的关键字，例如<a href="http://127.0.0.1:8000/home/?version=v1">http://127.0.0.1:8000/home/?version=v1</a> 例如，若<code>settings.py</code>文件中配置了此url中的<code>version_param</code>值为version，那么version就是获取版本的关键字（本质上是字典的键）</p><p>接下来看效果演示，这里通过postman来模拟get和post请求。</p><ul><li>首先，这里我没有在URL中携带版本信息，由于我在全局配置中写了默认是v1，并且关键字是version，因此会帮我按照这个配置信息反向生成一个url链接。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202654.png"></p><ul><li>接下来的请求我会携带version参数，可以看到响应成功，输出api版本信息并反向生成了url</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202936.png"></p><ul><li>接下来我换一个关键词使用?xx=v3，drf会按照之前的配置，默认使用v1参数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202938.png"></p><ul><li>接下来我会使用不在<code>ALLOWED_VERSIONS</code>中的版本信息，v1000，程序报错，不合格的版本信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122202675.png" alt="image-20231009211750100"></p><h2 id="2、通过url路由传递版本信息"><a href="#2、通过url路由传递版本信息" class="headerlink" title="2、通过url路由传递版本信息"></a>2、通过url路由传递版本信息</h2><p>URL路由中携带版本（*）公司中常用的方法 可以直接将其写到settings.py文件中，这样可以方便后续使用，直接去全局配置中找到即可。</p><p>视图类代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home2View</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    versioning_class = URLPathVersioning</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        url = request.versioning_scheme.reverse(<span class="string">&quot;home2&quot;</span>, request=request)</span><br><span class="line">        print(<span class="string">&quot;drf_HOME2反向生成的URL为&quot;</span>, url)</span><br><span class="line">        self.dispatch</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">222222</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这里注意，反向生成URL的时候需要加上一个name</p><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> Home2View</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;api/&lt;str:version&gt;/home2/&quot;</span>, Home2View.as_view(), name=<span class="string">&quot;home2&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在类视图的代码中，我们将<code>versioning_class</code> 赋值为<code>URLPathVersioning</code></p><p>在drf的源代码中，<code>URLPathVersioning</code>是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLPathVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    To the client this is the same style as `NamespaceVersioning`.</span></span><br><span class="line"><span class="string">    The difference is in the backend - this implementation uses</span></span><br><span class="line"><span class="string">    Django&#x27;s URL keyword arguments to determine the version.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    An example URL conf for two views that accept two different versions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    urlpatterns = [</span></span><br><span class="line"><span class="string">        re_path(r&#x27;^(?P&lt;version&gt;[v1|v2]+)/users/$&#x27;, users_list, name=&#x27;users-list&#x27;),</span></span><br><span class="line"><span class="string">        re_path(r&#x27;^(?P&lt;version&gt;[v1|v2]+)/users/(?P&lt;pk&gt;[0-9]+)/$&#x27;, users_detail, name=&#x27;users-detail&#x27;)</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    GET /1.0/something/ HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in URL path.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 从请求的参数中先获取有没有版本，</span></span><br><span class="line">        version = kwargs.get(self.version_param, self.default_version)</span><br><span class="line">        <span class="comment"># 如果没有版本则赋值为默认的版本参数</span></span><br><span class="line">        <span class="keyword">if</span> version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            version = self.default_version</span><br><span class="line">        <span class="comment"># 如果是不合法的API版本，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotFound(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, viewname, args=<span class="literal">None</span>, kwargs=<span class="literal">None</span>, request=<span class="literal">None</span>, <span class="built_in">format</span>=<span class="literal">None</span>, **extra</span>):</span></span><br><span class="line">        <span class="keyword">if</span> request.version <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125; <span class="keyword">if</span> (kwargs <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">else</span> kwargs</span><br><span class="line">            kwargs[self.version_param] = request.version</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().reverse(</span><br><span class="line">            viewname, args, kwargs, request, <span class="built_in">format</span>, **extra</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>本质上就是一个determin_version()函数，首先会从<code>**kwargs</code>中获取有没有版本，如果没有版本信息则将版本赋值为全局配置中的默认版本。如果API是非法的，则抛出异常。</p><h2 id="3、通过请求头传递"><a href="#3、通过请求头传递" class="headerlink" title="3、通过请求头传递"></a>3、通过请求头传递</h2><p>视图类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home3View</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    versioning_class = AcceptHeaderVersioning</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;api_version=&quot;</span>, request.version)</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        url = request.versioning_scheme.reverse(<span class="string">&quot;home3&quot;</span>, request=request)</span><br><span class="line">        print(<span class="string">&quot;drf_HOME2反向生成的URL为&quot;</span>, url)</span><br><span class="line">        self.dispatch</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">333333</span>, <span class="string">&quot;Home&quot;</span>: <span class="string">&quot;Home3&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> app01.views <span class="keyword">import</span> Home3View</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;api/home3/&quot;</span>, Home3View.as_view(), name=<span class="string">&quot;home3&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在类视图的代码中，我们将<code>versioning_class</code> 赋值为<code>AcceptHeaderVersioning</code></p><p>在drf的源代码中，<code>AcceptHeaderVersioning</code>是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于请求头传递版本信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptHeaderVersioning</span>(<span class="params">BaseVersioning</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    GET /something/ HTTP/1.1</span></span><br><span class="line"><span class="string">    Host: example.com</span></span><br><span class="line"><span class="string">    Accept: application/json; version=1.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    invalid_version_message = _(<span class="string">&#x27;Invalid version in &quot;Accept&quot; header.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        media_type = _MediaType(request.accepted_media_type)</span><br><span class="line">        version = media_type.params.get(self.version_param, self.default_version)</span><br><span class="line">        version = unicode_http_header(version)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_allowed_version(version):</span><br><span class="line">            <span class="keyword">raise</span> exceptions.NotAcceptable(self.invalid_version_message)</span><br><span class="line">        <span class="keyword">return</span> version</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We don&#x27;t need to implement `reverse`, as the versioning is based</span></span><br><span class="line">    <span class="comment"># on the `Accept` header, not on the request URL.</span></span><br></pre></td></tr></table></figure><p>这个请求无法再浏览器中模拟，只能通过postman中去添加请求头进行模拟，</p><p>Headers中的KEY为Accept，VALUE为application/json; version=1.0</p><ul><li>这里我先将version设置为1.0，可以看到显示信息为不合法的版本信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122201284.png" alt="image-20231009213432844"></p><ul><li>然后我将version设置为v3，可以看到可以正常访问</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122201464.png" alt="image-20231009213714147"></p><p>如果我不在请求头中设置的话，默认还是会访问v1版本的API，这是由于我在全局中的配置所导致的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310122204844.png&quot; alt=&quot;image-20231012220431847&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;API版本&quot;</summary>
      
    
    
    
    
    <category term="django" scheme="https://guoxiansen.github.io/tags/django/"/>
    
    <category term="drf" scheme="https://guoxiansen.github.io/tags/drf/"/>
    
  </entry>
  
  <entry>
    <title>CloudSim Installation</title>
    <link href="https://guoxiansen.github.io/2023/10/11/CloudSim%20Installation/"/>
    <id>https://guoxiansen.github.io/2023/10/11/CloudSim%20Installation/</id>
    <published>2023-10-11T12:58:11.000Z</published>
    <updated>2023-10-27T14:23:37.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112103086.png" alt="image-20231011210335067"></p><h1 id="CloudSim安装与测试用例运行"><a href="#CloudSim安装与测试用例运行" class="headerlink" title="CloudSim安装与测试用例运行"></a>CloudSim安装与测试用例运行</h1><h1 id="0、CloudSim简介"><a href="#0、CloudSim简介" class="headerlink" title="0、CloudSim简介"></a>0、CloudSim简介</h1><ul><li>CloudSim是由澳大利亚墨尔本大学的网格实验室和Gridbus项目共同推出的开源云计算仿真平台；</li><li>CloudSim是基于<strong>Java语言</strong>开发的，可实现跨平台运行；</li><li>CloudSim有助于加快面向云计算平台的算法设计与测试速度，可降低开发的成本；</li><li>用户可以通过CloudSim提供的众多核心类来进行大规模的云计算基础设施的建模与仿真。</li></ul><h1 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h1><ul><li><p>一台Windows操作系统的电脑</p></li><li><p>Java配置</p></li><li><p>Maven下载与配置</p></li><li><p>工具下载（下面两个都可以，二选一即可）</p><ul><li>Eclipse</li><li>IDEA（推荐）</li></ul></li><li><p>CloudSim下载（本次实验使用<strong>CloudSim 5.0</strong>）</p></li></ul><p><strong>注：以上所有软件的安装包均可在百度网盘中下载</strong></p><p>链接：<a href="https://pan.baidu.com/s/12JT4gDKbOLvHIeqyGbgE6A">https://pan.baidu.com/s/12JT4gDKbOLvHIeqyGbgE6A</a><br>提取码：3fd5</p><h2 id="1-1-Java配置"><a href="#1-1-Java配置" class="headerlink" title="1.1 Java配置"></a>1.1 Java配置</h2><p>首先需要再本地配置好Java的环境，这里不过多赘述，可以参考下面的教程</p><p><strong>注：本文中使用的是jdk8的版本</strong></p><h3 id="1-1-1-安装Java8"><a href="#1-1-1-安装Java8" class="headerlink" title="1.1.1 安装Java8"></a>1.1.1 安装Java8</h3><p>双击下载好百度网盘中的文件，选择你的安装路径即可</p><h3 id="1-1-2-配置环境变量"><a href="#1-1-2-配置环境变量" class="headerlink" title="1.1.2 配置环境变量"></a>1.1.2 配置环境变量</h3><p>在“计算机”图标上点击鼠标右键，点击“属性”命令，单击高级系统设置</p><p><strong>注意 配置不要照抄，要按照你自己本地的文件夹路径来</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181325266.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181325255.png" alt="img"></p><p>在“系统变量”中找到Path变量，点击“编辑”，添加一个 你所安装的jdk/bin目录 </p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310251029518.png" alt="image-20231025102917421"></p><h3 id="1-2-3-确认环境变量配置是否正确"><a href="#1-2-3-确认环境变量配置是否正确" class="headerlink" title="1.2.3 确认环境变量配置是否正确"></a>1.2.3 确认环境变量配置是否正确</h3><p>安装完成后在本地cmd中输入<code>java -version</code>能够显示下面的内容即为安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112108746.png" alt="image-20231011210829423"></p><h2 id="1-2-Maven下载与配置"><a href="#1-2-Maven下载与配置" class="headerlink" title="1.2 Maven下载与配置"></a>1.2 Maven下载与配置</h2><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具 软件。 Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较 高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方 法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><h3 id="1-2-1-下载"><a href="#1-2-1-下载" class="headerlink" title="1.2.1 下载"></a>1.2.1 下载</h3><p>打开<a href="https://maven.apache.org/download.cgi">Maven官网下载界面</a>，下载bin文件，该文件为编译后的Maven，无需在本地进行编译直接使用。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112113924.png" alt="image-20231011211326482"></p><p>下载完成后，保存到本地的一个可靠的路径。</p><p>然后在本地的环境变量中添加一个<code>MAVEN_HOME</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112121376.png" alt="image-20231011212120543"></p><p>同时在系统变量的<code>Path</code>中添加一行：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112124937.png" alt="image-20231011212319179"></p><h3 id="1-2-2-配置本地仓库"><a href="#1-2-2-配置本地仓库" class="headerlink" title="1.2.2 配置本地仓库"></a>1.2.2 配置本地仓库</h3><p><strong>注意下面开始修改<code>settings.xml</code>文件的时候，切记不要将你的内容添加在注释当中，xml是一种类似于html的标记语言，不要将其中的结尾标记给错误的删除了。</strong></p><p>在Maven安装的同级目录下创建maven-repository文件夹，用作maven的本地库。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112127205.png" alt="image-20231011212701529"></p><p>在路径apache-maven-3.9.5/conf文件夹下找到<code>settings.xml</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112130718.png" alt="image-20231011213017409"></p><p>在该文件中找到节点localRepository，在注释外添加。<strong>此处的路径需要修改为你自己创建的路径！！！切勿照抄复制</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>你自己创建的maven仓库路径<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112128393.png" alt="image-20231011212855325"></p><blockquote><p>localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:Users用户名.m2。<br>当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。<br>此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。</p></blockquote><h3 id="1-2-3-配置镜像"><a href="#1-2-3-配置镜像" class="headerlink" title="1.2.3 配置镜像"></a>1.2.3 配置镜像</h3><ol><li>在settings.xml配置文件中找到mirrors节点<strong>（XML文件的标签对要注意！！）</strong></li><li>添加如下配置（注意要添加在和两个标签之间，其它配置同理）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112132387.png" alt="image-20231011213207092"></p><blockquote><p>因为国外的服务器下载jar包很慢所以我们改为阿里云服务器</p><p>虽然mirrors可以配置多个子节点，但是它只会使用其中的一个节点，即默认情况下配置多个mirror的情况下，只有第一个生效，只有当前一个mirror无法连接的时候，才会去找后一个；而我们想要的效果是：当a.jar在第一个mirror中不存在的时候，maven会去第二个mirror中查询下载，但是maven不会这样做。</p></blockquote><h3 id="1-2-4-配置JDK"><a href="#1-2-4-配置JDK" class="headerlink" title="1.2.4 配置JDK"></a>1.2.4 配置JDK</h3><ol><li>在settings.xml配置文件中找到profiles节点</li><li>添加如下配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- java版本 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112134024.png" alt="image-20231011213444786"></p><p>配置完成，win+R运行CMD，输入mvn help:system 命令进行测试，配置成功则本地仓库（maven-repository）中会出现一些文件。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112136587.png" alt="image-20231011213655948"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112139145.png" alt="image-20231011213806766"></p><p>输出以下内容即为Maven安装成功：</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112137938.png" alt="image-20231011213739689"></p><blockquote><p>首次执行 mvn help:system 命令，Maven相关工具自动帮我们到Maven中央仓库下载缺省的或者Maven中央仓库更新的各种配置文件和类库（jar包)到Maven本地仓库中。<br>下载完各种文件后， mvn help:system 命令会打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助。</p></blockquote><h2 id="1-3-集成开发环境安装"><a href="#1-3-集成开发环境安装" class="headerlink" title="1.3 集成开发环境安装"></a>1.3 集成开发环境安装</h2><p>这里推荐使用IDEA，后续在工作中也多数会使用IDEA</p><p>安装教程参考：<a href="https://blog.csdn.net/rbx508780/article/details/126647849">https://blog.csdn.net/rbx508780/article/details/126647849</a></p><p>注：可以直接从官网下载专业版IDEA，利用校园邮箱免费激活。</p><h2 id="1-4-CloudSim下载"><a href="#1-4-CloudSim下载" class="headerlink" title="1.4 CloudSim下载"></a>1.4 CloudSim下载</h2><p>去github中下载CloudSim <a href="https://github.com/Cloudslab/cloudsim/releases">https://github.com/Cloudslab/cloudsim/releases</a></p><p>本实验中使用的是CloudSim5.0</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112142668.png" alt="image-20231011214208781"></p><p>下载后解压缩，然后在IDEA中打开项目，Maven会自动根据pom.xml下载一些配置文件，等待下载完成后即可。</p><p>点击open project，选择解压缩的CloudSim文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112159988.png" alt="image-20231011214707810"></p><p>在IDEA的设置中，设置之前的Maven仓库</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181130059.png" alt="image-20231018113050839"></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181131474.png" alt="image-20231018113120241"></p><p>然后找到example，右击运行，出现如下效果即为安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112144218.png" alt="image-20231011214423011"></p><h1 id="CloudSim介绍"><a href="#CloudSim介绍" class="headerlink" title="CloudSim介绍"></a>CloudSim介绍</h1><h2 id="CloudSim仿真的核心类"><a href="#CloudSim仿真的核心类" class="headerlink" title="CloudSim仿真的核心类"></a>CloudSim仿真的核心类</h2><p>CloudSim仿真的核心类如下</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>DataCenter</td><td><strong>数据中心</strong>，提供虚拟化网络资源</td></tr><tr><td>DataCenterBroker</td><td><strong>代理</strong>，用于提交虚拟机的任务和云任务列表</td></tr><tr><td>Host</td><td><strong>主机</strong>，扩展虚拟机的参数分配策略，一台Host可以对应多台VM</td></tr><tr><td>VM</td><td><strong>虚拟机类</strong>，运行在Host上，与其他虚拟机共享资源</td></tr><tr><td>Cloudlet</td><td><strong>云任务类</strong>，构建云环境任务</td></tr></tbody></table><h2 id="CloudSim仿真流程"><a href="#CloudSim仿真流程" class="headerlink" title="CloudSim仿真流程"></a>CloudSim仿真流程</h2><ol><li>初始化CloudSim</li><li>创建数据中心DataCenter</li><li>创建用户代理Broker</li><li>创建虚拟机VM，添加至Broker</li><li>创建应用Cloudlet，添加至Broker</li><li>开启仿真</li><li>结束模拟仿真</li><li>打印输出</li></ol><h1 id="CloudSim应用"><a href="#CloudSim应用" class="headerlink" title="CloudSim应用"></a>CloudSim应用</h1><p>CloudSim5.0安装包中提供了8个示例代码，后续的实验任务可以参考其中的部分。</p><p><code>CloudSimExample1</code>：展示了如何通过一台主机创建一个云数据中心并在其上运行一个Cloudlet。</p><p><code>CloudSimExample2</code>：展示了如何创建一个包含一个主机的数据中心，并在其上运行两个云任务。这些云任务在具有相同MIPS需求的虚拟机中运行。这些云任务将花费相同的时间来完成执行。</p><p><code>CloudSimExample3</code>：展示了如何创建一个包含两个主机的数据中心，并在其上运行两个Cloudlet云任务。这些云任务在具有不同MIPS需求的虚拟机中运行。云任务将会根据所请求的虚拟机性能，花费不同的时间来完成执行。</p><p><code>CloudSimExample4</code>：展示了如何创建两个包含一个主机的数据中心，并在它们上运行两个云任务。</p><p><code>CloudSimExample5</code>：展示了如何如何创建两个数据中心，每个数据中心包含一个主机，并在它们上运行两个用户的云任务。</p><p><code>CloudSimExample6</code>：展示了如何创建可伸缩的实例。</p><p><code>CloudSimExample7</code>：展示了如何暂停和恢复模拟，以及动态地创建模拟实例（在这个例子中是一个 DatacenterBroker）。</p><p><code>CloudSimExample8</code>：展示了。如何在运行时使用一个全局管理实体（GlobalBroker）创建模拟实体（在这个例子中是一个 DatacenterBroker）。</p><h2 id="仿真步骤"><a href="#仿真步骤" class="headerlink" title="仿真步骤"></a>仿真步骤</h2><p>进行CloudSim仿真前的准备工作包括：首先初始化CloudSim的工具包，创建云数据中心DataCenter和代理DataCenterBroker；然后创建虚拟机列表VmList，将虚拟机列表提交到云数据中心和代理；接着创建云任务列表CloudletList；最后将云任务列表提交给云数据中心和代理。</p><p>在进行CloudSim仿真时，首先需要对CloudSim的核心类参数进行初始化，主要有4个核心类，分别是主机类Host、云数据中心类DataCenter、虚拟机类VirtualMachine和云任务列表类Cloudlet。</p><p>Host参数包括ID、CPU、内存、带宽、外存等，Host参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hostId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ram = <span class="number">2048</span>;              <span class="comment">//Host memory (MB)</span></span><br><span class="line"><span class="keyword">long</span> storage = <span class="number">1000000</span>; <span class="comment">//Host storage</span></span><br><span class="line"><span class="keyword">int</span> bw = <span class="number">10000</span>;</span><br><span class="line">hostList.add( <span class="keyword">new</span> Host(</span><br><span class="line">    hostId,</span><br><span class="line">    <span class="keyword">new</span> RamProvisionerSimple(ram),</span><br><span class="line">    <span class="keyword">new</span> BwProvisionerSimple(bw),</span><br><span class="line">    storage,</span><br><span class="line">    peList,</span><br><span class="line">    <span class="keyword">new</span> VmSchedulerTimeShared(peList)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DataCenter参数包括主机架构、操作系统、虚拟机监视器种类、时区、CPU的使用费用、内存的使用费用、外存的使用费用、带宽的使用费用等。DataCenter参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String arch = <span class="string">&quot;x86&quot;</span>;       <span class="comment">//system architecture</span></span><br><span class="line">String os = <span class="string">&quot;Linux&quot;</span>;        <span class="comment">//operating system</span></span><br><span class="line">String vmm = <span class="string">&quot;Xen&quot;</span>;</span><br><span class="line"><span class="keyword">double</span> time_zone = <span class="number">10.0</span>;  <span class="comment">//time zone this resource located</span></span><br><span class="line"><span class="keyword">double</span> cost = <span class="number">3.0</span>;        <span class="comment">//the cost of using processing in this resource</span></span><br><span class="line"><span class="keyword">double</span> costPerMem = <span class="number">0.05</span>; <span class="comment">//the cost of using memory in this resource</span></span><br><span class="line"><span class="keyword">double</span> costPerStorage = <span class="number">0.001</span>;  <span class="comment">//the cost of using storage in this</span></span><br><span class="line"><span class="comment">//resource</span></span><br><span class="line"><span class="keyword">double</span> costPerBw = <span class="number">0.0</span>; <span class="comment">//the cost of using bw in this resource</span></span><br><span class="line">LinkedList&lt;Storage&gt; storageList = <span class="keyword">new</span> LinkedList&lt;Storage&gt;(); <span class="comment">//we are not adding SAN</span></span><br><span class="line"><span class="comment">//devices by now</span></span><br><span class="line"></span><br><span class="line">DatacenterCharacteristics characteristics = <span class="keyword">new</span> DatacenterCharacteristics(</span><br><span class="line">    arch, os, vmm, hostList, time_zone, cost, costPerMem, costPerStorage, costPerBw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//we need to create a PowerDatacenter object.</span></span><br><span class="line">Datacenter datacenter = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    datacenter = <span class="keyword">new</span> Datacenter(name, characteristics, <span class="keyword">new</span> VmAllocationPolicySimple(hostList),</span><br><span class="line">                             storageList, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>VirtualMachine参数包括ID、MIPS、镜像大小、内存大小、带宽、CPU数、虚拟机命名等。VirtualMachine参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VirtualMachine properties</span></span><br><span class="line"><span class="keyword">int</span> vmid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mips = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">long</span> size = <span class="number">10000</span>;          <span class="comment">//image size (MB)</span></span><br><span class="line"><span class="keyword">int</span> ram = <span class="number">512</span>;             <span class="comment">//vm memory (MB)</span></span><br><span class="line"><span class="keyword">long</span> bw = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> pesNumber = <span class="number">1</span>;            <span class="comment">//number of cpus</span></span><br><span class="line">String vmm = <span class="string">&quot;Xen&quot;</span>;        <span class="comment">//VMM name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//create VM</span></span><br><span class="line">Vm vm = <span class="keyword">new</span> Vm(vmid, brokerId, mips, pesNumber, ram, bw, size, vmm, </span><br><span class="line">                <span class="keyword">new</span> CloudletSchedulerTimeShared());</span><br><span class="line"></span><br><span class="line"><span class="comment">//add the VM to the vmList</span></span><br><span class="line">vmlist.add(vm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit vm list to the broker</span></span><br><span class="line">broker.submitVmList(vmlist);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Cloudlet参数包括编号、执行时的应用长度、用到的CPU数量、提交应用前的文件大小、应用执行完成后的文件大小、CPU和内存的使用模型/策略、网络带宽的使用模型/策略等。Cloudlet参数的定义及初始化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cloudlet properties</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> length = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">long</span> fileSize = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">long</span> outputSize = <span class="number">300</span>;</span><br><span class="line">UtilizationModel utilizationModel = <span class="keyword">new</span> UtilizationModelFull();</span><br><span class="line"></span><br><span class="line">Cloudlet cloudlet = <span class="keyword">new</span> Cloudlet(id, length, pesNumber, fileSize, outputSize, </span><br><span class="line">                                utilizationModel, utilizationModel, utilizationModel);</span><br><span class="line">cloudlet.setUserId(brokerId);</span><br><span class="line">cloudlet.setVmId(vmid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add the cloudlet to the list</span></span><br><span class="line">cloudletList.add(cloudlet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//submit cloudlet list to the broker</span></span><br><span class="line">broker.submitCloudletList(cloudletList);</span><br></pre></td></tr></table></figure><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>现在需要仿真：在<strong>2个</strong>云数据中心上分别各配置<strong>2台</strong>虚拟机，每台虚拟机运行<strong>1个</strong>用户的<strong>4个</strong>Cloudlet，总计<strong>4个</strong>用户<strong>16个</strong>Cloudlet，请进行实验，并给出实验结果截图附在实验报告中。</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310272206306.png" alt="image-20231027220654889"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112103086.png&quot; alt=&quot;image-20231011210335067&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;CloudS</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PROM1014-级数求和</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1014-%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1014-%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2022-03-21T12:17:41.000Z</published>
    <updated>2023-10-18T05:34:32.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在死循环中进行级数求和，每一轮循环进行判断，是否大于输入的<code>K</code>，大于则返回当前的<code>n</code>值</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334932.png" alt="image-20220321202013051"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">sum_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sum_num += <span class="number">1</span> / n</span><br><span class="line">    <span class="keyword">if</span> sum_num &gt; k:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;级数求和&quot;&gt;&lt;a href=&quot;#级数求和&quot; class=&quot;headerlink&quot; title=&quot;级数求和&quot;&gt;&lt;/a&gt;级数求和&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PROM1011-忠诚的骑士</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1011-%E5%BF%A0%E8%AF%9A%E7%9A%84%E9%AA%91%E5%A3%AB/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1011-%E5%BF%A0%E8%AF%9A%E7%9A%84%E9%AA%91%E5%A3%AB/</id>
    <published>2022-03-21T12:12:56.000Z</published>
    <updated>2023-10-18T05:34:20.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="忠诚的骑士"><a href="#忠诚的骑士" class="headerlink" title="忠诚的骑士"></a>忠诚的骑士</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分组的思想，判断输入的数字应该在第几组，然后判断该数字在当前分组的第几个位置，然后进行求和</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334473.png" alt="image-20220321202055824"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n, index</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="built_in">sum</span> += i * i</span><br><span class="line">    <span class="built_in">sum</span> += n * index</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># if k == 1:</span></span><br><span class="line">    <span class="comment">#     print(1)</span></span><br><span class="line">    p = k</span><br><span class="line">    s = k * (k + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= s:</span><br><span class="line">        p = p - <span class="number">1</span></span><br><span class="line">        s = p * (p + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 检测在第三组第几个位置</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="comment"># print(&#x27;p =&#x27;, p)</span></span><br><span class="line">    <span class="comment"># print(&#x27;s =&#x27;, s)</span></span><br><span class="line">    num = p * (p + <span class="number">1</span>) // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p + <span class="number">1</span>):</span><br><span class="line">        nums.append(num)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="comment"># print(&#x27;第&#x27;, nums.index(k) + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算金币总数</span></span><br><span class="line">    <span class="comment"># print(&#x27;金币总数：&#x27;, cal(p + 1, nums.index(k) + 1))</span></span><br><span class="line">    print(cal(p + <span class="number">1</span>, nums.index(k) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;忠诚的骑士&quot;&gt;&lt;a href=&quot;#忠诚的骑士&quot; class=&quot;headerlink&quot; title=&quot;忠诚的骑士&quot;&gt;&lt;/a&gt;忠诚的骑士&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1010-萌萌摘苹果</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1010-%E8%90%8C%E8%90%8C%E6%91%98%E8%8B%B9%E6%9E%9C/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1010-%E8%90%8C%E8%90%8C%E6%91%98%E8%8B%B9%E6%9E%9C/</id>
    <published>2022-03-21T12:07:34.000Z</published>
    <updated>2023-10-18T05:34:43.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="萌萌摘苹果"><a href="#萌萌摘苹果" class="headerlink" title="萌萌摘苹果"></a>萌萌摘苹果</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历苹果高度列表，判断是否能够到苹果，然后将能够到的苹果高度添加到一个新列表，循环结束之后，对两个列表长度进行比较，若长度一样返回<code>Yes</code>，否则返回<code>No</code></p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334844.png" alt="image-20220321200943805"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">height = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)]</span><br><span class="line">high = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">get_height = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> height:</span><br><span class="line">    <span class="keyword">if</span> i &lt;= high+<span class="number">30</span>:</span><br><span class="line">        get_height.append(i)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(get_height))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(get_height)==<span class="built_in">len</span>(height):</span><br><span class="line">    print(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;No&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;萌萌摘苹果&quot;&gt;&lt;a href=&quot;#萌萌摘苹果&quot; class=&quot;headerlink&quot; title=&quot;萌萌摘苹果&quot;&gt;&lt;/a&gt;萌萌摘苹果&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1008-回文回文</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1008-%E5%9B%9E%E6%96%87%E5%9B%9E%E6%96%87/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1008-%E5%9B%9E%E6%96%87%E5%9B%9E%E6%96%87/</id>
    <published>2022-03-21T12:00:30.000Z</published>
    <updated>2023-10-18T05:43:43.652Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181255837.png"></p><h1 id="回文回文"><a href="#回文回文" class="headerlink" title="回文回文"></a>回文回文</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由样例输入输出来看，如果有字母大小写均存在但是回文的话返回<code>Yes</code>。因此将字符串统一转成小写，然后进行回文判断</p><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181254615.png" alt="image-20220321200451662"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">huiwen = <span class="built_in">input</span>()</span><br><span class="line">huiwen = huiwen.lower()</span><br><span class="line"><span class="comment"># print(huiwen, &#x27;1111&#x27;)</span></span><br><span class="line"><span class="keyword">if</span> huiwen == huiwen[::-<span class="number">1</span>]:</span><br><span class="line">    print(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;No&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181255837.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;回文回文&quot;&gt;&lt;a href=&quot;#回文回文&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1007-斐波那契数列</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1007-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1007-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2022-03-21T11:55:11.000Z</published>
    <updated>2023-10-18T05:34:52.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>递归<ul><li>Python解答会超时</li></ul></li><li>滚动数组<ul><li>时间复杂度较低 Python也不会超时</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181334516.png" alt="image-20220321195628243"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">p,q,r = <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">    print(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    print(r)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1006-最大公约数和最小公倍数</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1006-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1006-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</id>
    <published>2022-03-21T11:49:53.000Z</published>
    <updated>2023-10-18T05:35:02.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">m, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> m &lt; n:</span><br><span class="line">        <span class="keyword">return</span> gcd(n, m)</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        m, n = n, m % n</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)]</span><br><span class="line">    print(gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]), nums[<span class="number">0</span>]*nums[<span class="number">1</span>] // gcd(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大公约数和最小公倍数&quot;&gt;&lt;a href=&quot;#最大公约数和最小公倍数&quot; class=&quot;headerlink&quot; title=&quot;最大公约数和最小公倍数&quot;&gt;&lt;/a&gt;最大公约数和最小公倍数&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1001-求最值问题</title>
    <link href="https://guoxiansen.github.io/2022/03/21/PROM1001-%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://guoxiansen.github.io/2022/03/21/PROM1001-%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-21T11:47:22.000Z</published>
    <updated>2023-10-18T05:35:12.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求最值问题"><a href="#求最值问题" class="headerlink" title="求最值问题"></a>求最值问题</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">sum</span>([<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)]))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;求最值问题&quot;&gt;&lt;a href=&quot;#求最值问题&quot; class=&quot;headerlink&quot; title=&quot;求最值问题&quot;&gt;&lt;/a&gt;求最值问题&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROM1003-新对称素数问题</title>
    <link href="https://guoxiansen.github.io/2022/03/20/PROM1003-%E6%96%B0%E5%AF%B9%E7%A7%B0%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>https://guoxiansen.github.io/2022/03/20/PROM1003-%E6%96%B0%E5%AF%B9%E7%A7%B0%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-20T14:40:31.000Z</published>
    <updated>2023-10-18T05:35:51.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新对称素数问题"><a href="#新对称素数问题" class="headerlink" title="新对称素数问题"></a>新对称素数问题</h1><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ul><li>Python中的连续输入</li><li>C语言中常用while(scanf(“%d”,x) !=EOF)判断输入是否碰到文件结束符（EOF）</li></ul><p>两种方法可实现对文件结束符（EOF）的判断</p><h3 id="Python实现方式一"><a href="#Python实现方式一" class="headerlink" title="Python实现方式一"></a>Python实现方式一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: </span><br><span class="line">    a=<span class="built_in">int</span>(line) </span><br><span class="line">    <span class="keyword">if</span> a!=<span class="number">0</span>: </span><br><span class="line">        print(a)</span><br></pre></td></tr></table></figure><h3 id="Python实现方式二"><a href="#Python实现方式二" class="headerlink" title="Python实现方式二"></a>Python实现方式二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>前几次提交就是没有考虑到连续输入的问题，加上上述的实现方式之后，就可以解决该问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(num**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">huiwen</span>(<span class="params">num</span>):</span></span><br><span class="line">    num = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">if</span> num == num[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">99999</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># n = int(input())</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            nums = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> huiwen(i) <span class="keyword">and</span> prime(i) <span class="keyword">and</span> check(i):</span><br><span class="line">                    print(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;新对称素数问题&quot;&gt;&lt;a href=&quot;#新对称素数问题&quot; class=&quot;headerlink&quot; title=&quot;新对称素数问题&quot;&gt;&lt;/a&gt;新对称素数问题&lt;/h1&gt;&lt;h2 id=&quot;需要解决的问题&quot;&gt;&lt;a href=&quot;#需要解决的问题&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>PROB1012-最小质数合数之和问题</title>
    <link href="https://guoxiansen.github.io/2022/03/20/PROB1012-%E6%9C%80%E5%B0%8F%E8%B4%A8%E6%95%B0%E5%90%88%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://guoxiansen.github.io/2022/03/20/PROB1012-%E6%9C%80%E5%B0%8F%E8%B4%A8%E6%95%B0%E5%90%88%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-20T11:47:24.000Z</published>
    <updated>2023-10-18T05:35:19.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小质数合数之和问题"><a href="#最小质数合数之和问题" class="headerlink" title="最小质数合数之和问题"></a>最小质数合数之和问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>查找大于正整数<code>n</code>的最小质数和最小合数之和。</p><p>质数是指在大于<code>1</code>的自然数中，除了<code>1</code>和它本身以外不再有其他因数的自然数。</p><p>合数是指在大于<code>1</code>的整数中除了能被<code>1</code>和本身整除外，还能被其他数（<code>0</code>除外）整除的数。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>一个正整数n，题目保证<code>1≤n≤1000000000</code></p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>一个正整数，表示大于正整数<code>n</code>的最小质数和最小合数之和。</p><h3 id="样例输入："><a href="#样例输入：" class="headerlink" title="样例输入："></a>样例输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输入：-1"><a href="#样例输入：-1" class="headerlink" title="样例输入："></a>样例输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><h3 id="样例输出：-1"><a href="#样例输出：-1" class="headerlink" title="样例输出："></a>样例输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">195</span><br></pre></td></tr></table></figure><h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><p>对于第一组样例：<code>n</code>为<code>1</code>的情况下，最小素数为<code>2</code>，最小合数为<code>4</code>，因此答案为<code>2+4=6</code>。</p><h2 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isprime</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(num**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">nums = []</span><br><span class="line">tag = <span class="number">0</span></span><br><span class="line">n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> isprime(n):</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="number">0</span>:</span><br><span class="line">            nums.append(n)</span><br><span class="line">            tag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums.append(n)</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(<span class="built_in">sum</span>(nums))</span><br><span class="line"><span class="comment"># print(nums)</span></span><br></pre></td></tr></table></figure><p>测试用例通过，但是代码存在问题，原因：可能存在连续有两个合数那么将会退出</p><h2 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h2><p>正确解法，分开来进行单独求，利用两次死循环，一次找最小的质数，一次找最小的合数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(num**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    zhishu = <span class="number">0</span></span><br><span class="line">    heshu = <span class="number">0</span></span><br><span class="line">    k = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime(k):</span><br><span class="line">            zhishu = k</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    k = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isPrime(k):</span><br><span class="line">            heshu = k</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    print(zhishu + heshu)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小质数合数之和问题&quot;&gt;&lt;a href=&quot;#最小质数合数之和问题&quot; class=&quot;headerlink&quot; title=&quot;最小质数合数之和问题&quot;&gt;&lt;/a&gt;最小质数合数之和问题&lt;/h1&gt;&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="NOJ" scheme="https://guoxiansen.github.io/tags/NOJ/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习笔记</title>
    <link href="https://guoxiansen.github.io/2022/03/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://guoxiansen.github.io/2022/03/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-10T06:38:42.000Z</published>
    <updated>2023-10-18T05:36:20.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336898.png" alt="image-20220310144152329"></p><h1 id="准备复试-暂停更新"><a href="#准备复试-暂停更新" class="headerlink" title="准备复试 暂停更新"></a>准备复试 暂停更新</h1><p>2022.3.20</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="1-0-章节框架图"><a href="#1-0-章节框架图" class="headerlink" title="1.0 章节框架图"></a>1.0 章节框架图</h2><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20220301173151773.png" alt="image-20220301173151773"></p><p>操作系统是计算机系统中的系统软件</p><h2 id="操作系统地位、作用"><a href="#操作系统地位、作用" class="headerlink" title="操作系统地位、作用"></a>操作系统地位、作用</h2><h2 id="操作系统的设计目标"><a href="#操作系统的设计目标" class="headerlink" title="操作系统的设计目标"></a>操作系统的设计目标</h2><ul><li>有效性</li><li>方便性</li><li>可扩充</li><li>开放性</li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是主机接收到外部信号或者系统发生随机性事件，停止当前执行的程序，转而处理这一事件，待事件处理完成，主机又可以回到原来的断点继续工作。中断是让操作系统内核夺回CPU使用权限的唯一途径。操作系统是由中断驱动的。</p><h3 id="用户态转到核心态（内核态）的三种方式"><a href="#用户态转到核心态（内核态）的三种方式" class="headerlink" title="用户态转到核心态（内核态）的三种方式"></a>用户态转到核心态（内核态）的三种方式</h3><ul><li>程序请求操作系统服务，执行<strong>系统调用</strong>。</li><li>程序运行时产生<strong>外中断</strong>事件（比如I/O操作完成），运行程序被中断，转向中断程序处理</li><li>在程序运行时发生<strong>内中断</strong>事件（<strong>异常</strong>），运行程序被打断，转向异常处理程序工作</li></ul><h4 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h4><p>也叫目态，即用户进程运行时处理器的状态。</p><h4 id="核心态"><a href="#核心态" class="headerlink" title="核心态"></a>核心态</h4><p>也称管态，即操作系统的自身核心部分及部分系统进程的程序运行时的处理器状态</p><p>操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。</p><h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><p>只能由操作系统调用而不能被用户调用的指令</p><h3 id="核心态转到用户态的方式"><a href="#核心态转到用户态的方式" class="headerlink" title="核心态转到用户态的方式"></a>核心态转到用户态的方式</h3><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><ul><li>外中断<ul><li>也叫中断，狭义上的中断。外中断与当前执行的指令无关，中断信号源于CPU外部，如I/O设备完成终端，表示设备输入输出处理已经完成，CPU能够发送下一个输入输出请求。此外还有<strong>时钟中断</strong>，<strong>控制台中断</strong>等</li></ul></li><li>内中断<ul><li>也叫异常、例外。内中断与当前执行的指令有关，中断信号源于CPU内部，如非法操作码、地址越界、算术溢出、除数为0等</li></ul></li></ul><h3 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h3><p>不同的中断信号，需要不同的中断处理程序来处理。当CPU检测中断信号后，就会根据中断信号的类型去查中断向量表，以此来找到对应的中断处理程序在内存中存放的位置。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h1 id="第二章-处理器管理"><a href="#第二章-处理器管理" class="headerlink" title="第二章 处理器管理"></a>第二章 处理器管理</h1><h2 id="2-0-章节框架图"><a href="#2-0-章节框架图" class="headerlink" title="2.0 章节框架图"></a>2.0 章节框架图</h2><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20220301173331378.png" alt="image-20220301173331378"></p><h2 id="2-1-进程及其实现"><a href="#2-1-进程及其实现" class="headerlink" title="2.1 进程及其实现"></a>2.1 进程及其实现</h2><h3 id="2-1-1-进程定义"><a href="#2-1-1-进程定义" class="headerlink" title="2.1.1 进程定义"></a>2.1.1 进程定义</h3><p>进程包括程序、数据、程序控制块PCB和栈。进程是操作系统进行资源调度和分配的独立的单位</p><h3 id="2-1-2-进程类型及特性"><a href="#2-1-2-进程类型及特性" class="headerlink" title="2.1.2 进程类型及特性"></a>2.1.2 进程类型及特性</h3><h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><ul><li>系统进程<ul><li>如C语言的编译进程</li></ul></li><li>用户进程</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>结构性</li><li>共享性</li><li>动态性</li><li>独立性</li><li>制约性</li><li>并发性</li></ul><h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><ul><li>进程可以描述系统的并发特性，但程序不可以</li><li>进程包含程序、数据、PCB和栈，程序是进程的一部分</li><li>进程是动态的，程序是静态的</li><li>进程有其生命周期，而程序可以长久保存在磁盘中</li><li>一个进程可以有多个进程，一个进程也可以涉及多个程序。</li><li>进程可以创建子进程，而程序不能创建子程序</li></ul><h3 id="2-1-3-进程的状态和转化"><a href="#2-1-3-进程的状态和转化" class="headerlink" title="2.1.3 进程的状态和转化"></a>2.1.3 进程的状态和转化</h3><h4 id="进程的基本状态"><a href="#进程的基本状态" class="headerlink" title="进程的基本状态"></a>进程的基本状态</h4><ul><li>运行态<ul><li>当前进程占有CPU并正在运行，则其所处的状态就是运行态</li></ul></li><li>就绪态<ul><li>当前进程具备了在CPU上执行的所有条件，等待CPU调度程序分配CPU，其状态叫就绪态</li></ul></li><li>等待态<ul><li>也叫阻塞态，当前进程等待系统某个信号、某个资源或等待事件发生，当需求没有被满足，此时的状态为等待态</li></ul></li></ul><h4 id="进程转换图"><a href="#进程转换图" class="headerlink" title="进程转换图"></a>进程转换图</h4><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20220310142855812.png" alt="image-20220310142855812"></p><h4 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h4><p>在三状态模型的基础上添加新建态和终止态</p><p>新建态是指进程刚被创建的时候，系统还没有允许执行该进程，且所需的其他资源还没有被完全满足</p><p>终止态是指进程正常结束或异常终止之后的状态。</p><h4 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h4><p>在五状态模型的基础上新增就绪挂起和等待挂起状态</p><h2 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h2><h3 id="2-2-1-进程控制原语"><a href="#2-2-1-进程控制原语" class="headerlink" title="2.2.1 进程控制原语"></a>2.2.1 进程控制原语</h3><p>原语是指在管态下执行的，具有原子性、能实现特定系统功能的程序段。这里的原子性是指程序段不可分割，即在执行过程中不允许被中断。</p><h2 id="2-3-处理器调度"><a href="#2-3-处理器调度" class="headerlink" title="2.3 处理器调度"></a>2.3 处理器调度</h2><h3 id="2-3-1-处理器调度的模式"><a href="#2-3-1-处理器调度的模式" class="headerlink" title="2.3.1 处理器调度的模式"></a>2.3.1 处理器调度的模式</h3><h3 id="2-3-2-处理器调度的原则"><a href="#2-3-2-处理器调度的原则" class="headerlink" title="2.3.2 处理器调度的原则"></a>2.3.2 处理器调度的原则</h3><h2 id="2-4-进程联系"><a href="#2-4-进程联系" class="headerlink" title="2.4 进程联系"></a>2.4 进程联系</h2><h2 id="2-5-临界区管理"><a href="#2-5-临界区管理" class="headerlink" title="2.5 临界区管理"></a>2.5 临界区管理</h2><h2 id="2-6-信号量与PV操作"><a href="#2-6-信号量与PV操作" class="headerlink" title="2.6 信号量与PV操作"></a>2.6 信号量与PV操作</h2><p>信号量是一种特殊的变量，它的表面形式是一个整型变量附加一个队列，而且它只能被特殊的操作使用。</p><p>P操作和V操作都是原语</p><h3 id="几大问题"><a href="#几大问题" class="headerlink" title="几大问题"></a>几大问题</h3><ul><li>生产者-消费者问题</li><li>读者-写者问题</li><li>吸烟者问题</li><li>哲学家进餐问题</li></ul><h2 id="2-7-进程通信"><a href="#2-7-进程通信" class="headerlink" title="2.7 进程通信"></a>2.7 进程通信</h2><h2 id="2-8-进程死锁"><a href="#2-8-进程死锁" class="headerlink" title="2.8 进程死锁"></a>2.8 进程死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁是在多道进程并发执行的环境下</p><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><ul><li><strong>互斥使用（资源独占）</strong>：资源每次只能给一个进程使用 </li><li><strong>不可抢占（不可剥夺）</strong>：资源申请者不能强行从占有者手中剥夺资源，只能由占有者自愿释放</li><li><strong>保持请求</strong>：进程在申请新资源时，保持对原有资源的占有</li><li><strong>循环等待</strong>：存在进程等待队列{P1,P2,P3……Pn}，P1等待P2占有的资源，P2等待P3占有的资源……Pn等待P1占有的资源，形成环路</li></ul><h3 id="死锁的预防机制"><a href="#死锁的预防机制" class="headerlink" title="死锁的预防机制"></a>死锁的预防机制</h3><h4 id="机制原理"><a href="#机制原理" class="headerlink" title="机制原理"></a>机制原理</h4><ul><li>预先确定资源分配，保证不发生死锁</li><li>通过破坏死锁4个必要条件之一来实现</li><li>破坏“互斥使用”这一条件不现实</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>破坏不可抢占条件<ul><li>允许进程动态申请资源</li><li>进程在申请新资源不能得到满足而变为等待状态之前，必须释放已占有的资源</li><li>若需要资源必须重新申请</li></ul></li><li>破坏请求保持条件<ul><li>不允许进程动态申请资源</li><li>进程运行之前必须一次性申请所需的所有资源</li><li>进程所有资源均可满足时给予一次性分配</li></ul></li><li>破坏循环等待条件<ul><li></li></ul></li></ul><h3 id="进程死锁的避免机制"><a href="#进程死锁的避免机制" class="headerlink" title="进程死锁的避免机制"></a>进程死锁的避免机制</h3><h4 id="机制原理-1"><a href="#机制原理-1" class="headerlink" title="机制原理"></a>机制原理</h4><ul><li>对进程发出的每一个资源申请进行动态检查</li><li>根据检查结果决定是否分配资源</li><li>若试分配后可能发生死锁，则不予分配，否则分配</li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h4 id="死锁原因"><a href="#死锁原因" class="headerlink" title="死锁原因"></a>死锁原因</h4><ul><li>系统资源不足</li><li>进程运行推进顺序不合理</li><li>资源分配不当</li></ul><p>解决原则</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20220228200304386.png" alt="image-20220228200304386"></p><ul><li>单独使用死锁预防、避免、检测与接触并不能全面解决操作系统中遇到的所有死锁问题</li><li>可将系统中的进程、资源分为若干类，对每一类进程、资源使用最适合它的办法解决死锁</li></ul><h1 id="第三章-存储管理"><a href="#第三章-存储管理" class="headerlink" title="第三章 存储管理"></a>第三章 存储管理</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20220301173628409.png" alt="image-20220301173628409"></p><h3 id="3-1-基本概述"><a href="#3-1-基本概述" class="headerlink" title="3.1 基本概述"></a>3.1 基本概述</h3><h4 id="3-1-1-计算机中的存储体系"><a href="#3-1-1-计算机中的存储体系" class="headerlink" title="3.1.1 计算机中的存储体系"></a>3.1.1 计算机中的存储体系</h4><h4 id="3-1-5-存储覆盖和交换技术"><a href="#3-1-5-存储覆盖和交换技术" class="headerlink" title="3.1.5 存储覆盖和交换技术"></a>3.1.5 存储覆盖和交换技术</h4><h1 id="第五章-文件管理"><a href="#第五章-文件管理" class="headerlink" title="第五章 文件管理"></a>第五章 文件管理</h1><h2 id="5-1-基本概述"><a href="#5-1-基本概述" class="headerlink" title="5.1 基本概述"></a>5.1 基本概述</h2><h2 id="5-2-文件目录"><a href="#5-2-文件目录" class="headerlink" title="5.2 文件目录"></a>5.2 文件目录</h2><h2 id="5-3-文件的物理结构"><a href="#5-3-文件的物理结构" class="headerlink" title="5.3 文件的物理结构"></a>5.3 文件的物理结构</h2><h1 id="弱项知识点"><a href="#弱项知识点" class="headerlink" title="弱项知识点"></a>弱项知识点</h1><h2 id="Spooling技术"><a href="#Spooling技术" class="headerlink" title="Spooling技术"></a>Spooling技术</h2><p>假脱机技术</p><h2 id="对比Spooling技术和缓冲区技术"><a href="#对比Spooling技术和缓冲区技术" class="headerlink" title="对比Spooling技术和缓冲区技术"></a>对比Spooling技术和缓冲区技术</h2><h2 id="文件物理结构（索引文件结构）"><a href="#文件物理结构（索引文件结构）" class="headerlink" title="文件物理结构（索引文件结构）"></a>文件物理结构（索引文件结构）</h2><ul><li>顺序文件结构</li><li>链接文件结构</li><li>索引文件结构</li></ul><h3 id="索引文件结构"><a href="#索引文件结构" class="headerlink" title="索引文件结构"></a>索引文件结构</h3><h3 id="混合索引文件结构"><a href="#混合索引文件结构" class="headerlink" title="混合索引文件结构"></a>混合索引文件结构</h3><p>直接索引：索引直接指向物理地址</p><p>一级间接地址索引：索引节点指向的物理地址用来存放地址项</p><p>二级间接地址索引：索引节点指向的物理块用来存放一级索引</p><h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336898.png&quot; alt=&quot;image-20220310144152329&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;准备复试-暂</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://guoxiansen.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode509-斐波那契数</title>
    <link href="https://guoxiansen.github.io/2022/03/09/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://guoxiansen.github.io/2022/03/09/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2022-03-09T14:45:57.000Z</published>
    <updated>2023-10-18T05:36:46.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png"></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>斐波那契数 （通常用<code> F(n)</code> 表示）形成的序列称为 斐波那契数列 。该数列由 <code>0 </code>和 <code>1 </code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>，F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>给定<code> n</code> ，请计算<code> F(n)</code> 。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一 递归"></a>方法一 递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fib(n-<span class="number">1</span>)+self.fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="方法二-动态规划"><a href="#方法二-动态规划" class="headerlink" title="方法二 动态规划"></a>方法二 动态规划</h2><p>利用滚动数组思想</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">p,q,r = <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">    p = q</span><br><span class="line">    q = r</span><br><span class="line">    r = p + q</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode20-有效的括号</title>
    <link href="https://guoxiansen.github.io/2022/03/09/LeetCode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://guoxiansen.github.io/2022/03/09/LeetCode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-03-09T09:32:41.000Z</published>
    <updated>2023-10-18T05:37:33.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘<code>(</code>‘，’<code>)</code>‘，’<code>&#123;</code>‘，’<code>&#125;</code>‘，’<code>[</code>‘，’<code>]&#39;</code> 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="匹配失败的情况"><a href="#匹配失败的情况" class="headerlink" title="匹配失败的情况"></a>匹配失败的情况</h3><ol><li><p>左括号多了   例如</p><p>​     <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181337630.png" alt="image.png"></p></li><li><p>右括号多了   例如</p><p>​        <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181337609.png"></p><p>​        </p></li><li><p>括号不匹配   例如</p><p>​        <img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181337974.png" alt="image.png"></p></li></ol><p>排除掉上面的是那种匹配失败的情况之后，剩余的都是匹配成功</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>核心思想是利用栈去匹配括号</p><p>用字典构造一个哈希表，表示右括号对应的左括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>用一个字符串表示左括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kuohao = <span class="string">&#x27;&#123;([&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 括号匹配问题 使用栈来匹配</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        dic = &#123;<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>&#125;</span><br><span class="line">        kuohao = <span class="string">&#x27;&#123;([&#x27;</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果stack为空的话，则入栈 这种情况排除第一个就是右括号的情况</span></span><br><span class="line">            <span class="comment"># print(stack)          </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                stack.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果是左括号则入栈</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> kuohao:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print(&#x27;dic[i] is &#x27;, dic[i])</span></span><br><span class="line">                <span class="comment"># 哈希表中对应的值与栈尾元素进行比较</span></span><br><span class="line">                <span class="keyword">if</span> dic[i]==stack[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 括号匹配成功之后则弹出栈</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 匹配不成功则是匹配失败的第三种情况</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># print(&#x27;stack is &#x27;,stack)</span></span><br><span class="line">        <span class="comment"># 如果stack栈不为空的话则是匹配失败的第一种和第二种情况</span></span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 排除三种异常情况之外则匹配成功</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://guoxiansen.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>

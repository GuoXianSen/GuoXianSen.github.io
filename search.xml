<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="2021/01/03/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/03/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/u=1167116189,1935478605&fm=26&gp=0.jpg" alt="img"></p><h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="作者：郭寅之"><a href="#作者：郭寅之" class="headerlink" title="作者：郭寅之"></a>作者：郭寅之</h2><p><strong>B站/Youtube：Clay_Guo</strong></p><p><strong>邮箱</strong>：guoyinzhi@foxmail.com</p><h1 id="一-Docker介绍"><a href="#一-Docker介绍" class="headerlink" title="一.Docker介绍"></a>一.Docker介绍</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><blockquote><p>1.我本地运行没有问题，</p><p>​    环境不一致会出现问题</p><p>2.哪个哥们又写死循环了，怎么这么卡。 </p><p>​    在多用户的操作系统下，会相互影响</p><p>3.淘宝在双十一的时候，海量并发的解决方案，用户量暴增的情况下</p><p>​    运维成本过高的问题</p><p>4.学习一门技术，学习安装成本过高</p><p>​    安装软件成本过高</p></blockquote><h2 id="1-2-Docker的由来"><a href="#1-2-Docker的由来" class="headerlink" title="1.2 Docker的由来"></a>1.2 Docker的由来</h2><blockquote><p>一帮年轻人创业，创办了一家公司，2010年的专门做PAAS平台</p><p>到2013年的时候，亚马逊，微软，谷歌都开始做PAAS平台</p><p>2013年，将公司的核心技术对外开源，核心技术就是Docker</p><p>到了2014年的时候，这家公司得到了C轮融资$4000w</p><p>到了2015年的时候，得到了D轮融资 $9500w 用于全神贯注的维护Docker</p><p>所罗门 主要作者之一</p></blockquote><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201127162000792.png" alt="image-20201127162000792"></p><blockquote><p>Docker的作者已经离开了维护Docker的团队。</p></blockquote><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201127162102934.png" alt="image-20201127162102934"></p><h2 id="1-3-Docker思想"><a href="#1-3-Docker思想" class="headerlink" title="1.3 Docker思想"></a>1.3 Docker思想</h2><blockquote><p>1.集装箱</p><p>​    docker会将所有需要的内容放到不同的集装箱中，谁需要这个环境就直接拿到这个集装箱就可以了。</p><p>2.标准化</p><p>​    1. 运输的标准化：Docker有一个码头，所有上传的集装箱都放在了这个码头上面，当谁需要某一个环境，就直接指派大海豚去搬运这个集装箱即可</p><p>​    2. 命令的标准化：Docker提供了一系列的命令，帮助我们去获取集装箱等等操作</p><p>​    3. 提供了REST的API：衍生出了很多图形化界面，Rancher</p><p>3.隔离性</p><p>​    Docker在运行集装箱内的内容时候，会在Linux内核中，单独开辟出一片空间，这片空间不会影响到其他程序</p></blockquote><blockquote><ul><li>注册中心 （超级码头，上面放到就是集装箱）</li><li>镜像（集装箱）</li><li>容器（运行起来的镜像）</li></ul></blockquote><h1 id="二-Docker的基本操作"><a href="#二-Docker的基本操作" class="headerlink" title="二.Docker的基本操作"></a>二.Docker的基本操作</h1><h2 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1 安装docker"></a>2.1 安装docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载关于Docker的依赖环境</span></span><br><span class="line">yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 设置一下下载Docker的镜像源</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 安装Docker</span></span><br><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 启动，并设置为开机自动启动，测试</span></span><br><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>检测安装是否成功</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128015052534.png" alt="image-20201128015052534"></p><h2 id="2-2-Docker中央仓库（注册中心）"><a href="#2-2-Docker中央仓库（注册中心）" class="headerlink" title="2.2 Docker中央仓库（注册中心）"></a>2.2 Docker中央仓库（注册中心）</h2><blockquote><p>1.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度慢</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201127164656745.png" alt="image-20201127164656745"></p><p>2.国内的镜像网站：网易蜂巢（需要登录）、daoCloud</p><p><a href="http://hub.daocloud.io/">http://hub.daocloud.io/</a></p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201127164612997.png" alt="image-20201127164612997"></p><p>3.在公司内部可以 采用私服的方式拉取镜像（添加配置才能生效）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要在/etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://registry.docker-cn.com&quot;</span>],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;ip:port&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 重启两个服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-镜像的操作"><a href="#2-3-镜像的操作" class="headerlink" title="2.3 镜像的操作"></a>2.3 镜像的操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像到本地</span></span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line">docker pull tomcat daocloud.io/library/tomcat:8.5.15-jre8</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 查看全部本地的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 3. 删除本地镜像</span></span><br><span class="line">docker rmi 镜像的标识</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 镜像的导入导出（不规范）</span></span><br><span class="line"><span class="comment"># 将本地的镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line">docker save -o ./nginx.image 55</span><br><span class="line"><span class="comment"># 加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像名称</span></span><br><span class="line">docker tag 镜像id 新镜像名称:版本</span><br></pre></td></tr></table></figure><p>加载本地的镜像文件</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128013941247.png" alt="image-20201128013941247"></p><p>修改镜像名称</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128014135318.png" alt="image-20201128014135318"></p><h2 id="2-4-容器的操作"><a href="#2-4-容器的操作" class="headerlink" title="2.4 容器的操作"></a>2.4 容器的操作</h2><p>容器：运行起来的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 运行容器</span></span><br><span class="line"><span class="comment"># 简单操作</span></span><br><span class="line">docker run 镜像的标识|镜像名称[:tag]</span><br><span class="line"><span class="comment"># 常用的参数</span></span><br><span class="line">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span><br><span class="line"><span class="comment"># -d：代表后台运行容器</span></span><br><span class="line"><span class="comment"># -p 宿主机端口:容器端口：为了映射当前Linux端口和容器端口</span></span><br><span class="line"><span class="comment"># --name 容器名称：指定容器的名称</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 查看正在运行的容器</span></span><br><span class="line">docker ps [-qa]</span><br><span class="line"><span class="comment"># -a：查看全部的容器，包括没有运行</span></span><br><span class="line"><span class="comment"># -p：只查看容器得到标识</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 查看容器的日志</span></span><br><span class="line">docker logs -f 容器id</span><br><span class="line"><span class="comment"># -f：可以滚动查看日志的最后几行</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 进入到容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id bash</span><br><span class="line"><span class="comment"># 可以方便查看容器内部的相关资源</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 删除容器（删除容器前，需要停止容器）</span></span><br><span class="line"><span class="comment"># 停止指定的容器</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="comment"># 停止全部容器</span></span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"><span class="comment"># 删除指定的容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="comment"># 删除全部容器</span></span><br><span class="line">docker rm $(docker pa -qa)</span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. 启动容器</span></span><br><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure><p>查看tomcat服务</p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128033204215.png" alt="image-20201128033204215" style="zoom:80%;" /><h1 id="三-Docker应用"><a href="#三-Docker应用" class="headerlink" title="三.Docker应用"></a>三.Docker应用</h1><h2 id="3-1-准备SSM工程"><a href="#3-1-准备SSM工程" class="headerlink" title="3.1 准备SSM工程"></a>3.1 准备SSM工程</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MySQL数据库的连接用户名和密码改变了，修改db.properties</span></span><br></pre></td></tr></table></figure><h2 id="3-2-准备MySQL容器"><a href="#3-2-准备MySQL容器" class="headerlink" title="3.2 准备MySQL容器"></a>3.2 准备MySQL容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行MySQL容器</span></span><br><span class="line">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:8.0.18</span><br></pre></td></tr></table></figure><h2 id="3-3-准备Tomcat容器"><a href="#3-3-准备Tomcat容器" class="headerlink" title="3.3 准备Tomcat容器"></a>3.3 准备Tomcat容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行Tomcat容器，前面已经搞定，只需要将SSM项目的war包部署到Tomcat容器内部即可</span></span><br><span class="line"><span class="comment"># 可以通过命令将宿主机的内容服务到容器内部</span></span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line">docker cp ssm.war fe:/usr/<span class="built_in">local</span>/tomcat/webapps</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-数据卷"><a href="#3-4-数据卷" class="headerlink" title="3.4 数据卷"></a>3.4 数据卷</h2><blockquote><p>为了部署SSM的工程，需要使用到cp的命令将宿主机内的ssm.war文件复制到容器内部</p><p>数据卷：将宿主机的一个目录映射到容器的一个目录中</p><p>可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会随着一起改变</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建数据卷</span></span><br><span class="line">docker volume create 数据卷名称</span><br><span class="line"><span class="comment"># 创建数据卷之后，默认会放在一个目录下 /var/lib/docker/volumes/数据卷名称/_data</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128025507315.png" alt="image-20201128025507315"></p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 查看数据卷的详细信息</span></span><br><span class="line">docker volume inspect 数据卷名称</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128025705639.png" alt="image-20201128025705639"></p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 查看全部数据卷</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128025758566.png" alt="image-20201128025758566"></p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 删除数据卷</span></span><br><span class="line">docker volume rm 数据卷名称</span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 应用数据卷</span></span><br><span class="line"><span class="comment"># 当你映射数据卷时，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中</span></span><br><span class="line">docker run -v 数据卷名称:容器内部的路径 镜像id</span><br><span class="line"><span class="comment"># 直接指定一个路径作为数据卷的存放位置（此文件不会将其他文件带过来，无法访问tomcat主页）这个路径下是空的。 此方式用的多一些</span></span><br><span class="line">docker run -v 路径：容器内部的路径 镜像id </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128031402401.png" alt="image-20201128031402401"></p><h1 id="四-Docker自定义镜像"><a href="#四-Docker自定义镜像" class="headerlink" title="四.Docker自定义镜像"></a>四.Docker自定义镜像</h1><blockquote><p>中央仓库上的镜像，也是Docker的用户自己上传过去的。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建一个Dockerfile文件，并制定自定义镜像信息</span></span><br><span class="line"><span class="comment"># Dockerfile文件中常用的内容</span></span><br><span class="line">from：制定当前自定义镜像依赖的环境</span><br><span class="line">copy: 将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir： 声明镜像的默认工作目录</span><br><span class="line">cmd:  需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）</span><br><span class="line"><span class="comment"># 举个例子，自定义一个tomcat镜像，并且将ssm.war 部署到tomcat中</span></span><br><span class="line">from daocloud.io/library/tomcat:7.0.56</span><br><span class="line">copy ssm.war /usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将准备好的Dockerfile和相应的文件拖拽到Linux操作系统中，通过Docker的命令制作镜像</span></span><br><span class="line">docker build -t 镜像名称:[tag]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-1-制作镜像"><a href="#4-1-制作镜像" class="headerlink" title="4.1 制作镜像"></a>4.1 制作镜像</h2><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128152400425.png" alt="image-20201128152400425"></p><h2 id="4-2-运行镜像"><a href="#4-2-运行镜像" class="headerlink" title="4.2 运行镜像"></a>4.2 运行镜像</h2><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128152810795.png" alt="image-20201128152810795"></p><h2 id="4-3-访问该服务"><a href="#4-3-访问该服务" class="headerlink" title="4.3 访问该服务"></a>4.3 访问该服务</h2><p>使用8081端口访问到tomcat服务</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128152858265.png" alt="image-20201128152858265"></p><h1 id="五-Docker-Compose"><a href="#五-Docker-Compose" class="headerlink" title="五.Docker-Compose"></a>五.Docker-Compose</h1><blockquote><p>之前运行一个镜像，需要添加大量的参数</p><p>可以通过Docker-compose编写这些参数</p><p>Docker-compose可以帮助我们批量的管理容器</p><p>只需要通过一个docker-compose.yml文件去维护即可</p></blockquote><h2 id="6-1-下载Docker-Compose"><a href="#6-1-下载Docker-Compose" class="headerlink" title="6.1 下载Docker-Compose"></a>6.1 下载Docker-Compose</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 去GitHub官网搜索docker-compose，下载最新版本的Docker-Compose</span></span><br><span class="line">wget https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</span><br><span class="line"><span class="comment"># 2. 将下载好的文件，拖拽到Linux操作系统中</span></span><br><span class="line"><span class="comment"># 3. 需要将Docker-Compose文件名称修改一下，给予DockerCompose文件一个可执行的权限</span></span><br><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br><span class="line"><span class="comment"># 4. 方便后期操作，配置一个环境变量</span></span><br><span class="line"><span class="comment"># 将docker-compose文件移动到/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到PATH中</span></span><br><span class="line">mv docker-compose /usr/<span class="built_in">local</span>/bin</span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>:/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 5. 测试一下</span></span><br><span class="line"><span class="comment"># 在任意目录下输入docker-compose</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证docker-compose是否安装成功</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128174820678.png" alt="image-20201128174820678"></p><h2 id="6-2-Docker-Compose管理MySQL和Tomcat容器"><a href="#6-2-Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="6.2 Docker-Compose管理MySQL和Tomcat容器"></a>6.2 Docker-Compose管理MySQL和Tomcat容器</h2><blockquote><p>yml文件以key: value方式来指定配置信息</p><p>多个配置信息以换行+缩进的方式来区分</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span>                     <span class="comment"># 服务的名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>          <span class="comment"># 代表只要Docker启动，那么这个容器就跟着一起启动</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/mysql:8.0.18</span>     <span class="comment"># 指定镜像路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span>    <span class="comment"># 指定容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span>        <span class="comment"># 指定端口号的映射</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span>         <span class="comment"># 指定MySQL的ROOT用户登录密码</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span>                 <span class="comment"># 指定时区</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker_mysql-tomcat/mysql_data:/var/lib/mysql</span>        <span class="comment"># 映射数据卷</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>          <span class="comment"># 代表只要Docker启动，那么这个容器就跟着一起启动</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span>     <span class="comment"># 指定镜像路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat</span>    <span class="comment"># 指定容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span>        <span class="comment"># 指定端口号的映射</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span>         <span class="comment"># 指定MySQL的ROOT用户登录密码</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span>                 <span class="comment"># 指定时区</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker_mysql-tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span>        <span class="comment"># 映射数据卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker_mysql-tomcat/tomcat_logs:/usr/local/tomcat/logs</span>        <span class="comment"># 映射数据卷</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3-使用Docker-compose命令管理容器"><a href="#6-3-使用Docker-compose命令管理容器" class="headerlink" title="6.3 使用Docker-compose命令管理容器"></a>6.3 使用Docker-compose命令管理容器</h2><blockquote><p>在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.基于docker-compose.yml启动管理的容器</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128213302224.png" alt="image-20201128213302224"></p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 关闭并删除容器</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 开启或关闭已经存在的由docker-compose维护的容器</span></span><br><span class="line">docker-compose start | stop | restart</span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 查看由docker-compose管理的容器</span></span><br><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201128212828179.png" alt="image-20201128212828179"></p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 查看日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h2 id="6-4-docker-compose配置Dockerfile使用"><a href="#6-4-docker-compose配置Dockerfile使用" class="headerlink" title="6.4 docker-compose配置Dockerfile使用"></a>6.4 docker-compose配置Dockerfile使用</h2><blockquote><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yml文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">ssm:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">build:</span>                           <span class="comment"># 构建自定义镜像</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">../</span>                   <span class="comment"># 指定Dockerfile文件所在路径</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>         <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ssm:1.0.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ssm</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="number">8081</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="string">from</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line"><span class="string">copy</span> <span class="string">ssm.war</span> <span class="string">/usr/local/tomcat/webapps</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span></span><br><span class="line"><span class="comment"># 重新构建的话</span></span><br><span class="line"><span class="comment"># 重新构建自定义镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"><span class="comment"># 运行前，重新构建</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><h1 id="六-Docker-CI-CD"><a href="#六-Docker-CI-CD" class="headerlink" title="六.Docker CI/CD"></a>六.Docker CI/CD</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><blockquote><p>项目部署</p><pre><code>1. 将项目通过maven进行编译打包 2. 将文件上传到指定的服务器中 3. 将war包放到tomcat的目录中 4. 通过Dockerfile将tomcat和war包转成一个镜像，由docker-compose去运行容器</code></pre><p>项目更新了</p><p>​    将上述流程再次从头到尾执行一次</p><p>可以将上述流程自动化的去实现</p></blockquote><h2 id="7-2-CI介绍"><a href="#7-2-CI介绍" class="headerlink" title="7.2 CI介绍"></a>7.2 CI介绍</h2><blockquote><p>CI（continuous intergration）持续继承</p><p>持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试</p><ul><li>快速发现错误</li><li>防止代码偏离主分支</li></ul></blockquote><h2 id="7-3-实现持续继承"><a href="#7-3-实现持续继承" class="headerlink" title="7.3 实现持续继承"></a>7.3 实现持续继承</h2><h3 id="7-3-1-搭建Gitlab服务器"><a href="#7-3-1-搭建Gitlab服务器" class="headerlink" title="7.3.1 搭建Gitlab服务器"></a>7.3.1 搭建Gitlab服务器</h3><blockquote><p> 1、创建一个全新的虚拟机，并且至少指定4G的运行内存</p></blockquote><blockquote><p> 2、安装docker以及docker-compose</p></blockquote><blockquote><p> 3、将ssh的默认22端口，修改为60022端口</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">PORT 22 -&gt; 60022</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><blockquote><p> 4、docker-compose.yml问价去安装GitLab</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span> </span><br><span class="line">   <span class="attr">image:</span> <span class="string">&#x27;twang2218/gitlab-ce-zh:11.1.4&#x27;</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">&quot;gitlab&quot;</span></span><br><span class="line">   <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">   <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">hostname:</span> <span class="string">&#x27;gitlab&#x27;</span></span><br><span class="line">   <span class="attr">environment:</span> </span><br><span class="line">     <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">     <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> </span><br><span class="line">       <span class="string">external_url</span> <span class="string">&#x27;http://192.168.199.110&#x27;</span></span><br><span class="line">       <span class="string">gitlab_rails[&#x27;time_zone&#x27;]</span> <span class="string">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">       <span class="string">gitlab_rails[&#x27;smtp_enable&#x27;]</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;]</span> <span class="string">=</span> <span class="number">22</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&#x27;22:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/config:/etc/gitlab</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/data:/var/opt/gitlab</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><code>[1]</code> 千锋教育-2020版-Docker最新超详细版教程通俗易懂 <em><a href="https://www.bilibili.com/video/BV1sK4y1s7Cj">https://www.bilibili.com/video/BV1sK4y1s7Cj</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的b=a</title>
      <link href="2021/01/03/Python%E4%B8%AD%E7%9A%84a-b/"/>
      <url>2021/01/03/Python%E4%B8%AD%E7%9A%84a-b/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20210103165044286.png" alt="image-20210103165044286"></p><h1 id="Python中的b-a"><a href="#Python中的b-a" class="headerlink" title="Python中的b=a"></a>Python中的b=a</h1><a id="more"></a><p>本题目中我进行了一个列表赋值的操作，当时没有注意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    a.remove(i)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>我原本以为这串代码结束之后，输出的结果应该是空列表[]，没想到却是[2,4]</p><p>经过一番调试之后，我发现a和b居然是一个对象，这时候我恍然大悟，原来b=a这个操作竟然是将b和a指向同一个对象。</p><p>要想实现我之前的想法，只需要将我的代码修改一处即可实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = a[:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    a.remove(i)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>这其中不同之处就在于，我将<code>b=a</code>改成了<code>b=a[:]</code>，会创建一个新的与a完全相同的对象，但是与a并不指向同一对象。</p><p>想要判断两个对象是否是一致的，我们可以用Python的<code>id()</code>方法来进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法每日一题1-字符串逆序</title>
      <link href="2021/01/01/%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F/"/>
      <url>2021/01/01/%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/v2-2eeafdaeb2484ec1519ee2185116244a_1440w.jpg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="2020/12/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue学习笔记"><a href="#Vue学习笔记" class="headerlink" title="Vue学习笔记"></a>Vue学习笔记</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/86d6277f9e2f070829b4f3e790f80a9fab01f283.jpeg" alt="img"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote></blockquote><h2 id="Vue概述"><a href="#Vue概述" class="headerlink" title="Vue概述"></a>Vue概述</h2><h3 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h3><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式javascript框架</p><p>声明式渲染-&gt;组件系统-&gt;客户端路由-&gt;集中式状态管理-&gt;项目构建</p><p>vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>①   英文官网: <a href="https://vuejs.org/">https://vuejs.org/</a></p><p>②   中文官网: <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows Terminal使用分享</title>
      <link href="2020/12/29/Windows-Terminal%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB/"/>
      <url>2020/12/29/Windows-Terminal%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-Terminal使用分享"><a href="#Windows-Terminal使用分享" class="headerlink" title="Windows Terminal使用分享"></a>Windows Terminal使用分享</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230002713572.png" alt="image-20201230002713572"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>在使用<code>ubuntu</code>、<code>Kali</code>等Linux发型版本的时候，我们通常是可以对bash终端进行美化的，而在windows上，我们能用到的bash就只有cmd，也就是那个黑乎乎的很丑的控制台，在 Build 2020 全球开发者大会上，微软发布 Windows Terminal 1.0 正式版。这让我们可以在windows上向Linux一样进行控制台操作了。当然在使用性上还是远不及Linux的bash的，这点希望微软在今后进行不断的优化。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+Typora搭建个人笔记系统</title>
      <link href="2020/12/29/Picgo-Typora%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/12/29/Picgo-Typora%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo-Typora搭建个人笔记系统"><a href="#PicGo-Typora搭建个人笔记系统" class="headerlink" title="PicGo+Typora搭建个人笔记系统"></a>PicGo+Typora搭建个人笔记系统</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/a.jpg" alt="a"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>从开始读书的时候，笔记就是我必不可少的一样东西。大学的学习中，每门课都不能缺少笔记。在pc端中，常见的笔记软件有<code>word</code>，<code>印象笔记</code>，<code>OneNote</code>，<code>Sublime Text</code>，<code>Notepad++</code>等。在大学的时候，一次偶然的机会，听学长介绍了markdown以及一款写markdown的软件<code>Typora</code>，至此开始使用markdown记录自己的笔记，并且很多平台，例如微信公众号，知乎等都已经支持markdown语法了。但是在后续的使用过程中，记笔记的同时经常需要放置图片，这时会让我在与其他人共享的时候出现图片无法访问的情况，这是由于图片粘贴过来之后是存储在本地的，而他人在自己的电脑中是无法访问到我的图片的。后来我采取的方案是使用云商提供的对象存储。我使用过的有阿里云、腾讯云以及七牛云。但是后来发现这些云商提供的服务到后面需要收费。因此我又开始琢磨，我自己正好有几台云服务器，为啥不在我的云服务器上面去搭建一个图床呢，这个时候经过一番资料的收集以及多次尝试，最终我敲定了我自己的方案，在我的云服务器上面搭建一个个人图床，采用的模板是Chevereto<sup><code>[1]</code></sup>。当时我还给我的图床配置了一个专属的二级域名（一级域名给了我的博客）。原本以为这样就可以万事大吉了，但是随着我的使用，服务器到期了需要迁移的话，图床需要重新二次部署，图片也会丢失，数据无价，这样的话也会让我自己在使用中碰到不利…..后来我也尝试着将图片存储在GitHub上，但是由于其服务器架设在国外，访问速度上就非常的不占优势。在不断的探索尝试之后，我采用了如下方案。</p></blockquote><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>经过上面的一番周折，我使用了现在的这套解决方案。也就是利用Typora<sup><code>[2]</code></sup>来记笔记，然后使用在使用PicGo<sup><code>[3]</code></sup>进行图片管理，每次将我的图片存储到Gitee<sup><code>[4]</code></sup>上，这样既照顾到了访问速度，在数据的安全性上也相对照顾。</p><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><ul><li>Gitee   <em><a href="https://gitee.com/">https://gitee.com/</a></em></li><li>node.js  <em><a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></em></li><li>Picgo   <em><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></em></li><li>Typora  <em><a href="https://www.typora.io/">https://www.typora.io/</a></em></li></ul><h3 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h3><blockquote><p>Gitee和GitHub类型，都是代码托管平台，和GitHub相比最大的都是就是其访问速度。本次我们需要使用他来存放我们的图片。</p></blockquote><p>传送门：*<a href="https://gitee.com/">https://gitee.com/</a>*</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230215454332.png" alt="image-20201230215454332"></p><p><strong>新建仓库</strong>，这里我取名为<code>pic-bed</code>，是否开源一定要选择公开，否则其他人无法访问到你这个仓库中的图片的。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230220800255.png" alt="image-20201230220800255"></p><p>初始化仓库，选择只创建master分支，最后点击创建</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230221820087.png" alt="image-20201230221820087"></p><p>之后点击自己的头像，点击设置</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230221439002.png" alt="image-20201230221439002"></p><p>在安全设置中，点击私人令牌</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230221519170.png" alt="image-20201230221519170"></p><p>点击生成新令牌</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230221552329.png" alt="image-20201230221552329"></p><p>修改配置如下：</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230221624692.png" alt="image-20201230221624692"></p><p>点击提交，复制一下出现的<code>token</code>，<strong>接下来要用的到的！</strong></p><p><strong>gitee缺陷</strong>，在后续的使用过程中，大概率会碰到，有时候无法访问图片的情况，但是通过图片的地址，是可以访问到图片的，这是因为gitee为了出于安全考虑，大于1M的文件，需要登录之后才可以访问。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/Gitee%E9%99%90%E5%88%B6.png" alt="Gitee限制"></p><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><blockquote><p>node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。为了下面PicGo安装插件，我们需要安装他。这里不推荐使用最新node14+版本，可能会出现各种各样的玄学问题。</p></blockquote><p>下载地址：*<a href="https://nodejs.org/dist/latest-v12.x/">https://nodejs.org/dist/latest-v12.x/</a>*</p><p>大家根据自己的需要选择对应的版本安装包安装即可。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230222326030.png" alt="image-20201230222326030"></p><h3 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h3><p>传送门：  <em><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></em></p><p>根据自己的系统来选择对应的版本</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230215907545.png" alt="image-20201230215907545"></p><p>软件安装成功打开的界面如下：</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230220004989.png" alt="image-20201230220004989"></p><p>可以选择链接格式（markdown、HTML、URL、UBB、Custom等），另外也需要设置一下图床，PicGo默认是没有gitee图床的，但是我们可以通过插件来添加gitee，插件名为<code>gitee-uploade</code>。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230220316974.png" alt="image-20201230220316974"></p><p>安装成功之后，在图床设置中选择gitee即可。</p><p>下面进行图床配置</p><p><code>repo</code> 填写你的gitee仓库全部路径</p><p><code>branch</code> 填写你的master分支（创建的时候选择其他分支的话，就填写你的分支）</p><p><code>token</code> 填写上面Gitee令牌刚生成的token</p><p><code>path</code> 填写img即可</p><p>剩下的不填即可点击确定，设为默认图床即可。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230222513746.png" alt="image-20201230222513746"></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><blockquote><p>Typora是一款用于记录markdown笔记的软件，功能非常强大，真正的可以让程序员无需在文档格式上花费太多时间，仅需要专注于自己的文档写作即可。</p></blockquote><p>下载地址：*<a href="https://www.typora.io/">https://www.typora.io/</a>*</p><p>这里我们可以根据自己的操作系统来选择对应的Typora版本，然后无脑进行下一步即可。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230213056356.png" alt="image-20201230213056356"></p><p>安装完成双击即可打开软件</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230213328719.png" alt="image-20201230213328719"></p><p>然后我们就可以根据markdown语法进行文档写作了。</p><p>这里简单介绍一些Typora的<strong>功能</strong></p><p>首先，我们可以根据自己的需求选择不同的主题</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230213551206.png" alt="image-20201230213551206"></p><p>当然，默认提供的主题种类比较少，但是Typora也想到了这一点，给我们提供了一个主题网站，大家可以根据自己的需要去选择自己所喜欢的主题。</p><p>传送门：<em><a href="https://theme.typora.io/">https://theme.typora.io/</a></em></p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230214557380.png" alt="image-20201230214557380"></p><p>另外，我们可以将markdown写好的文档转换成多种格式，这样方便在其他的设备上也能查看该文档。例如我们可以在markdown上写论文，然后再将它转为<code>.doc</code>格式的文档。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230215030977.png" alt="image-20201230215030977"></p><p>这里仅举两个例子，更多的功能大家可以自行探索。</p><p>让人高兴的是，在typora的一次更新升级中，他的日志显示，其开始支持PicGo图床，这次的更新也让本文的方案成为现实。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201229233855646.png" alt="image-20201229233855646"></p><p>下面进行<strong>图床配置</strong>，点击偏好设置</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230222903097.png" alt="image-20201230222903097"></p><p>在图片选项中，选择插入图片是上传图片，上传服务设定为</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230222949422.png" alt="image-20201230222949422"></p><p>配置好了之后，我们先选择验证图片上传选项，显示如下内容即为成功</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230223342580.png" alt="image-20201230223342580"></p><p>之后，只要我们在typora中粘贴一张图片，就会自动上传到我们的gitee仓库中，是不是非常的方便。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里我们随便粘贴一张图片进来，这个图片可以是截图，可以是直接复制一张图片粘贴，也可以是网络上的图片。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230223716739.png"></p><p>这里我们可以看到，在进行图片上传</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230223741802.png" alt="image-20201230223741802"></p><p>在上传成功之后，windows会进行通知，显示在右下角</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201230223605752.png" alt="image-20201230223605752"></p><p>这样我们就可以进行自己的笔记系统的搭建了，后面可以把我们的笔记快捷的用Hexo发布，也可以发布在其他的博客系统亦或是GitHub中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲述了一种利用PicGo和Typora构建的个人笔记系统，使用体验从我个人角度来说非常的nice，但由于Gitee的1M限制，存储的图片只能是1M以下的，这点就非常的不人性化，当然你也可以牺牲速度换取大小来选择GitHub作为图床，或者你是RMB玩家，可以选择使用诸如腾讯云、阿里云、七牛云等云商提供的对象存储来搭建性能更好的图床。This is your choice, I shall have no right to interfere</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>[1]</code>  Chevereto官网    <em><a href="https://chevereto.com/">https://chevereto.com/</a></em></p><p><code>[2]</code>  Typora官网    <em><a href="https://www.typora.io/">https://www.typora.io/</a></em></p><p><code>[3]</code>  PicGo官网    <em><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></em></p><p><code>[4]</code>  gitee官网    <em><a href="https://gitee.com/">https://gitee.com/</a></em></p><p><code>[5]</code>  node.js官网    <em><a href="https://nodejs.org/">https://nodejs.org/</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> PicGo </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程</title>
      <link href="2020/12/28/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>2020/12/28/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Git与GitHub使用教程"><a href="#Git与GitHub使用教程" class="headerlink" title="Git与GitHub使用教程"></a>Git与GitHub使用教程</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/u=1294953991,2171358706&fm=11&gp=0.jpg" alt="img"></p><blockquote><p>很久很久以前，进行软件项目开发的时候，可能是一个人独自开发，亦或是进行复制粘贴每天写好的项目模块。随着软件项目的庞大，一个项目可能就不会再由一个人独自开发了，往往就需要团队之间进行协作开发，因此，协议团队协作开发版本管理的软件就应运而生了。常见的有SVN<code>[1]</code>、Git<code>[2]</code>。代码托管网站也有很多，例如Github<code>[3]</code>以及国内的Gitee<code>[4]</code>。本文以GitHub+Git来详细说明如何用Git来管理自己的项目以及如何与他人进行团队协作开发。</p></blockquote><h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><ul><li>Git</li><li>GitHub注册好账号</li></ul><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="git更新本地分支与远程同步"><a href="#git更新本地分支与远程同步" class="headerlink" title="git更新本地分支与远程同步"></a>git更新本地分支与远程同步</h3><ol><li>进入到工程目录文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br></pre></td></tr></table></figure><ol start="2"><li>选择一个分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><ol start="3"><li>拉取远程代码到本地</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure><p> 第三步等同于下面的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --prune origin </span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>[1]</code> SVN  <em><a href="https://tortoisesvn.net/">https://tortoisesvn.net/</a></em></p><p><code>[2]</code> Git  <em><a href="https://gitee.com/">https://gitee.com/</a></em></p><p><code>[1]</code> Github  <em><a href="https://github.com/">https://github.com/</a></em></p><p><code>[2]</code> Gitee  <em><a href="https://gitee.com/">https://gitee.com/</a></em></p><p><code>[1]</code> Github  <em><a href="https://github.com/">https://github.com/</a></em></p><p><code>[2]</code> Gitee  <em><a href="https://gitee.com/">https://gitee.com/</a></em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建教程</title>
      <link href="2020/12/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>2020/12/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客搭建教程"><a href="#Hexo博客搭建教程" class="headerlink" title="Hexo博客搭建教程"></a>Hexo博客搭建教程</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213221407115.png" alt="image-20201213221407115"></p><blockquote><p>又一次的搭建自己的hexo博客，这里记录一下hexo博客搭建的教程。之前的博客是部署到Github上的，奈何Github访问速度有点缓慢，因此本次博客搭建是部署到国内的Gitee上，这样加快了博客的访问速度。</p><p>不出意外的话，这次部署之后，以后都会用这个博客了，Butterfly主题也非常的精美。</p></blockquote><h2 id="准备内容"><a href="#准备内容" class="headerlink" title="准备内容"></a>准备内容</h2><ul><li>git  <a href="https://git-scm.com/">下载地址</a></li><li>node <a href="https://nodejs.org/zh-cn/">下载地址</a><ul><li>注意Node的安装版本，不要安装14以及更高，可能会出现不兼容的各种问题</li></ul></li><li>Gitee账号注册 <a href="https://gitee.com/">地址</a></li><li>​测试<sup><code>[1]</code></sup></li></ul><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>一键式傻瓜安装，安装完成后在任意界面右击鼠标，即可查看到<code>git</code>操作指令</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213170157245.png" alt="image-20201213170157245"></p><p>点击Git Bash Here，即可出现Git的命令行窗口，这是类似于Linux操作系统的命令行窗口的。</p><p>输入<code>git version</code>即可查看我们的Git版本</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213170431965.png" alt="image-20201213170431965"></p><p>类似上图即可说明Git安装成功，进行下一步操作。</p><h2 id="Node安装"><a href="#Node安装" class="headerlink" title="Node安装"></a>Node安装</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://nodejs.org/zh-cn/">传送门</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一件傻瓜式安装</p><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>安装完成之后在Git Bash界面输入node -v</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213193027917.png" alt="image-20201213193027917"></p><p>出现上图显示的结果即为安装成功，进入下一步。</p><h2 id="Hexo安装与使用"><a href="#Hexo安装与使用" class="headerlink" title="Hexo安装与使用"></a>Hexo安装与使用</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>接下来我们可以安装生成网站的关键——Hexo架构了，其主要信息和安装命令、主题等都可以从其官 网轻松得到：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><p>为了安装Hexo，只需要在Git Bash中输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>等待片刻即可（取决于网速）</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213171806245.png" alt="image-20201213171806245"></p><p>出现以上内容即安装完成。</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213193808961.png" alt="image-20201213193808961"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Hexo安装成功之后，我们需要先进行初始化在本地生成Hexo相关目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213172409130.png" alt="image-20201213172409130"></p><p>初始化完成之后，进入目录即可看到相关的文件已经生成好了</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201213172440595.png" alt="image-20201213172440595"></p><h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><blockquote><p>hexo默认的主题可能不是特别美观，因此也有许多开发者进行了二次开发从而提供了非常多的精美主题。</p></blockquote><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="部署到GitHub之后无法访问网站的情况"><a href="#部署到GitHub之后无法访问网站的情况" class="headerlink" title="部署到GitHub之后无法访问网站的情况"></a>部署到GitHub之后无法访问网站的情况</h3><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201229111424238.png" alt="image-20201229111424238"></p><p><strong>解决方法：</strong></p><p>可能是受到运营商的DNS污染，导致无法访问。这里可以修改我们TCP/IP协议中的DNS，设置为阿里云的223.5.5.5或者谷歌的8.8.8.8</p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/image-20201229163758897.png" alt="image-20201229163758897"></p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p><code>[1]</code> Hexo: <em><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></em></p><p><code>[2]</code> Butterfly主题魔改参考教程： <em><a href="https://blog.csdn.net/Lott0419/article/details/106688492/">https://blog.csdn.net/Lott0419/article/details/106688492/</a></em></p><p><code>[3]</code> Butterfly官方网站：  <em><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员面试宝典</title>
      <link href="2020/12/13/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
      <url>2020/12/13/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="程序员面试宝典"><a href="#程序员面试宝典" class="headerlink" title="程序员面试宝典"></a>程序员面试宝典</h1><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/u=4089543292,61773639&fm=26&gp=0.jpg" alt="img"></p><p>作者 Clay_Guo  郭寅之</p><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h2 id="运维开发工程师自我介绍"><a href="#运维开发工程师自我介绍" class="headerlink" title="运维开发工程师自我介绍"></a>运维开发工程师自我介绍</h2><p>面试官你好，我叫郭寅之，我本科的专业是软件工程，在校期间有上过C语言，<strong>数据结构</strong>，<strong>操作系统</strong>，计算机网络，数据库、设计模式、java 、java-web等课程。我个人大二大三课余时间学习过系统（主要是Red Hat操作系统）和网络相关的知识，然后考了RHCE的证书。平时的话也会倒腾自己在阿里云上租的一台云服务器（搭建博客、图床、FTP服务器等）本身的专业是开发出生，也了解一些系统网络相关知识，加上之前有一位老师给自己引路，因此我个人对于DEVOPS这个方向比较感兴趣，因此投递了贵公司的运维开发工程师岗位。</p><h3 id="Golang后端开发工程师自我介绍"><a href="#Golang后端开发工程师自我介绍" class="headerlink" title="Golang后端开发工程师自我介绍"></a>Golang后端开发工程师自我介绍</h3><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="RoboCup3D仿真机器人的设计"><a href="#RoboCup3D仿真机器人的设计" class="headerlink" title="RoboCup3D仿真机器人的设计"></a>RoboCup3D仿真机器人的设计</h2><p>在仿真Simspark环境中，设计机器人的各类动作，从而让机器人可以在球场的环境中进行11v11的比赛。</p><p>我主要负责的是对机器人步态以及射门的研究以及机器人高层逻辑决策的设计</p><p>利用Chainer框架中的DDPG算法对我们的Nao机器人进行优化。</p><h2 id="河海大学优必选科技冬令营"><a href="#河海大学优必选科技冬令营" class="headerlink" title="河海大学优必选科技冬令营"></a>河海大学优必选科技冬令营</h2><p>利用优必选科技的Yanshee机器人进行二次开发，我们主要做的就是设计语音模块的调用，舞蹈动作的编排</p><h1 id="技术环节"><a href="#技术环节" class="headerlink" title="技术环节"></a>技术环节</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><blockquote><p>数据结构与算法部分推荐两本书《大话数据结构》《剑指offer》以及刷题平台<strong>LeetCode</strong></p></blockquote><h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h4><blockquote><p>冒泡算法就是从当前的一个数字和后面的数字依次进行比较，从大到小排序或者从小到大排序</p><p>如果比后面的数字小就交换，</p><p>时间复杂度是Ο(n2)</p></blockquote><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote><p>选择排序就是每次从待排序的序列中选择一个最大或者最小的数字，然后进行两层循环，已达到最终的序列是一个有序序列</p><p>他的时间复杂度是Ο(n2)</p></blockquote><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote></blockquote><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序</span><br><span class="line">插入排序</span><br><span class="line">选择排序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全排列算法"><a href="#全排列算法" class="headerlink" title="全排列算法"></a>全排列算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如abc进行全排列的话</span><br><span class="line">使用到递归算法</span><br></pre></td></tr></table></figure><h3 id="如何检测链表是否成环"><a href="#如何检测链表是否成环" class="headerlink" title="如何检测链表是否成环"></a>如何检测链表是否成环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以设置两个指针，一个走的慢一点，一个走的快一点，如果两个相遇，那么就说明链表成环了。</span><br></pre></td></tr></table></figure><h3 id="解释一下什么是哈希表"><a href="#解释一下什么是哈希表" class="headerlink" title="解释一下什么是哈希表"></a>解释一下什么是哈希表</h3><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="用Python写过什么程序"><a href="#用Python写过什么程序" class="headerlink" title="用Python写过什么程序"></a>用Python写过什么程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用Socket模块写了一个即时通信软件</span><br><span class="line">用flask写过一个爬虫程序的接口</span><br></pre></td></tr></table></figure><h3 id="Python中with方法"><a href="#Python中with方法" class="headerlink" title="Python中with方法"></a>Python中<code>with</code>方法</h3><p>文件的打开方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> xx <span class="keyword">as</span> f</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>方法的好处在于，可以不用去处理f.<span class="built_in">open</span>()方法所带来的一场为</span><br><span class="line">可以不用去手动关闭文件，文件会通过自己的上下文管理器的close方法关闭</span><br></pre></td></tr></table></figure><h3 id="如何在函数内部修改全局变量"><a href="#如何在函数内部修改全局变量" class="headerlink" title="如何在函数内部修改全局变量"></a>如何在函数内部修改全局变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用全局变量</span><br><span class="line"><span class="keyword">global</span></span><br></pre></td></tr></table></figure><h3 id="Python的数据结构"><a href="#Python的数据结构" class="headerlink" title="Python的数据结构"></a>Python的数据结构</h3><p>注意各个数据结构的内置方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列表 里面的一些方法</span><br><span class="line">元组  元组不可变</span><br><span class="line">字典</span><br><span class="line">可以使用字典的key()方法或者value()方法来获得字典的全部键值</span><br><span class="line">集合</span><br></pre></td></tr></table></figure><h3 id="可变对象和不可变对象的区别"><a href="#可变对象和不可变对象的区别" class="headerlink" title="可变对象和不可变对象的区别"></a>可变对象和不可变对象的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Python什么情况下会考虑使用lambda函数"><a href="#Python什么情况下会考虑使用lambda函数" class="headerlink" title="Python什么情况下会考虑使用lambda函数"></a>Python什么情况下会考虑使用lambda函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升效率</span><br><span class="line">对于一些临时性的，小巧的函数。</span><br><span class="line">使用lambda函数更为轻巧，方便进行函数式编程</span><br><span class="line">可以作为回调函数，传递给某些应用，比如消息处理</span><br><span class="line"></span><br><span class="line">对于一些功能复杂的函数，还是直接定义为好</span><br></pre></td></tr></table></figure><h3 id="Python深拷贝和浅拷贝的区别是什么？"><a href="#Python深拷贝和浅拷贝的区别是什么？" class="headerlink" title="Python深拷贝和浅拷贝的区别是什么？"></a>Python深拷贝和浅拷贝的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line">深拷贝是将对象本身复制给另一个对象。这意味着如果对对象的副本进行更改时不</span><br><span class="line">会影响原对象。在 Python 中，我们使用 deepcopy（）函数进行深拷贝.</span><br><span class="line">(2)</span><br><span class="line">浅拷贝是将对象的引用复制给另一个对象。因此，如果我们在副本中进行更改，则</span><br><span class="line">会影响原对象。使用 copy（）函数进行浅拷贝</span><br></pre></td></tr></table></figure><h3 id="Python中is和-的区别"><a href="#Python中is和-的区别" class="headerlink" title="Python中is和==的区别"></a>Python中<code>is</code>和<code>==</code>的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。莱布尼茨说过：“世界上没有两片完全相同的叶子”，这个is正是这样的比较，比较是不是同一片叶子（即比较的id是否相同，这id类似于人的身份证标识）。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。这里比较的并非是同一片叶子，可能叶子的种类或者脉络相同就可以了。默认会调用对象的 __eq__()方法。</span><br></pre></td></tr></table></figure><h3 id="Python闭包"><a href="#Python闭包" class="headerlink" title="Python闭包"></a>Python闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在函数的内部定义了一个函数，并且这个函数用到了外面函数的变量，那么将这个函数和外面这个变量称作是闭包</span><br></pre></td></tr></table></figure><h3 id="Python2和Python3的区别"><a href="#Python2和Python3的区别" class="headerlink" title="Python2和Python3的区别"></a>Python2和Python3的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解释一下什么是装饰器"><a href="#解释一下什么是装饰器" class="headerlink" title="解释一下什么是装饰器"></a>解释一下什么是装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">装饰器本只上是一个Python函数，它可以让函数在不进行任何代码改动的前提下增加额外的功能，装饰器的返回值也是一个函数对象</span><br><span class="line"></span><br><span class="line">举例子</span><br><span class="line"></span><br><span class="line">装饰器的用途</span><br><span class="line">装饰器一般可以用来测试函数的运行效率</span><br><span class="line">装饰器常常用于有切面需求的场景，比如插入日志，性能测试，事务处理，缓存，权限的校验等场景，有了装饰器就可以抽出大量与</span><br></pre></td></tr></table></figure><h3 id="Python迭代器"><a href="#Python迭代器" class="headerlink" title="Python迭代器"></a>Python迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Python常用模块"><a href="#Python常用模块" class="headerlink" title="Python常用模块"></a>Python常用模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h2 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h2><h2 id="Java方向"><a href="#Java方向" class="headerlink" title="Java方向"></a>Java方向</h2><h3 id="java集合类"><a href="#java集合类" class="headerlink" title="java集合类"></a>java集合类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集合类型主要有3种：set(集）、list(列表）和map(映射)。</span><br><span class="line">HashSet LinkedHashSet TreeSet的主要使用情境</span><br><span class="line">集合接口分为：Collection和Map，list、set实现了Collection接口</span><br></pre></td></tr></table></figure><h3 id="解释一下JVM虚拟机"><a href="#解释一下JVM虚拟机" class="headerlink" title="解释一下JVM虚拟机"></a>解释一下JVM虚拟机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="简述一下Java中的垃圾回收机制"><a href="#简述一下Java中的垃圾回收机制" class="headerlink" title="简述一下Java中的垃圾回收机制"></a>简述一下Java中的垃圾回收机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运维方向"><a href="#运维方向" class="headerlink" title="运维方向"></a>运维方向</h2><h3 id="常见运维平台有哪些"><a href="#常见运维平台有哪些" class="headerlink" title="常见运维平台有哪些"></a>常见运维平台有哪些</h3><p>腾讯蓝鲸</p><h3 id="对DEVOPS和自动化运维开发的理解SRE思想"><a href="#对DEVOPS和自动化运维开发的理解SRE思想" class="headerlink" title="对DEVOPS和自动化运维开发的理解SRE思想"></a>对DEVOPS和自动化运维开发的理解SRE思想</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在我看来devops是传统运维技术上的进阶分支，应该去学习这些新的技术去扩充自己，而不是担心会被取代</span><br><span class="line">devops很大程度上的代替了传统运维的手工操作，运维人员只需写好自动化运维脚本（需要学习和钻研，各公司业务需求不同脚本也不同，不能生搬硬套），利用自动化工具（zabbix，elk，ansible等）就可以实现自动监控自动告警，省去了很多人力</span><br><span class="line">省去了很多不必要浪费的人力时间，但是更重要的是它做到了服务备用机制，对于公司而言，不可能时时刻刻都能提供正常有效的服务，有时候突发情况导致的服务终端是非常影响客户体验以及公司利益的，在突发情况下，及时发现以及紧急抢修维护必不可少，但突发情况下的服务继续我认为才是devops真正的核心，两地三中心，三地五中心也是这个道理。</span><br></pre></td></tr></table></figure><h3 id="对运维的理解"><a href="#对运维的理解" class="headerlink" title="对运维的理解"></a>对运维的理解</h3><p>举个例子，你可以说：我之前工作容易心急，一直都是非常忙碌的状态，分不清重要和紧急的事，总想把所有事情都尽快解决，很容易慌乱。后来我看了《高效能人士的七个习惯》，学习了事情应该分轻重缓急，理解了什么是重要紧急、重要不紧急等等，慢慢找到了做事的正确方法，让我受益匪浅。</p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/FC55F085707847876136CE156377E1D9.jpg" alt="img" style="zoom:50%;" /><h3 id="持续集成-持续部署CI-CD"><a href="#持续集成-持续部署CI-CD" class="headerlink" title="持续集成/持续部署CI/CD"></a>持续集成/持续部署CI/CD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">持续集成的基本思想是让一个自动化过程监测一个或多个源代码仓库是否有变更。当变更被推送到仓库时，它会监测到更改、下载副本、构建并运行任何相关的单元测 试。</span><br></pre></td></tr></table></figure><h3 id="云计算和DEVOPS的关系"><a href="#云计算和DEVOPS的关系" class="headerlink" title="云计算和DEVOPS的关系"></a>云计算和DEVOPS的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="什么是云原生"><a href="#什么是云原生" class="headerlink" title="什么是云原生"></a>什么是云原生</h3><p><em>云原生</em>是基于分布部署和统一运管的云端服务，以容器、微服务、DevOps等技术为基础建立的一套云技术产品体系。</p><p>分成云和原生</p><p>云是和本地相对的，传统的应用必须跑在本地服务器上，现在流行的应用都跑在云端，云包含了<code>IaaS</code>、<code>PaaS</code>和<code>SaaS</code>。</p><p>原生就是土生土长的意思，我们在开始设计应用的时候就考虑到应用将来是运行云环境里面的，要充分利用云资源的优点，比如️云服务的<strong>弹性</strong>和<strong>分布式</strong>优势。</p><p><strong>微服务</strong><br>微服务解决的是我们软件开发中一直追求的<strong>低耦合+高内聚</strong>，记得有一次我们系统的接口出了问题，结果影响了用户的前台操作，于是黎叔拍案而起，灵魂发问：“为啥这两个会互相影响？！”</p><p>微服务可以解决这个问题，微服务的本质是把一块大饼分成若干块低耦合的小饼，比如一块小饼专门负责接收外部的数据，一块小饼专门负责响应前台的操作，小饼可以进一步拆分，比如负责接收外部数据的小饼可以继续分成多块负责接收不同类型数据的小饼，这样每个小饼出问题了，其它小饼还能正常对外提供服务。</p><p><strong>DevOps</strong><br>DevOps的意思就是<strong>开发和运维</strong>不再是分开的两个团队，而是你中有我，我中有你的一个团队。我们现在开发和运维已经是一个团队了，但是运维方面的知识和经验还需要持续提高。</p><p><strong>持续交付</strong><br>持续交付的意思就是在不影响用户使用服务的前提下频繁把新功能发布给用户使用，要做到这点非常非常难。我们现在两周一个版本，每次上线之后都会给不同的用户造成不同程度的影响。</p><p><strong>容器化</strong><br>容器化的好处在于运维的时候不需要再关心每个服务所使用的技术栈了，每个服务都被无差别地封装在容器里，可以被无差别地管理和维护，现在比较流行的工具是docker和k8s。</p><p>所以你也可以简单地把云原生理解为：<strong>云原生 = 微服务 + DevOps + 持续交付 + 容器化</strong></p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/2220386-2c06a6c6d3ecdcf5.jpg"></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux中你用过哪些指令？"><a href="#Linux中你用过哪些指令？" class="headerlink" title="Linux中你用过哪些指令？"></a>Linux中你用过哪些指令？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ps -ef   #表示查看全格式的全部进程。</span><br><span class="line">ps -ef | grep 应用名</span><br><span class="line">tail #查看文件的最后10行</span><br><span class="line">tail -f #循环读取文件的最后几行，适合读取正在改变的日志文件。</span><br><span class="line">tail -n #读取文件的最后的n行</span><br><span class="line">top</span><br><span class="line">rm -rf </span><br><span class="line">more</span><br><span class="line">help</span><br><span class="line">cat</span><br><span class="line">ping</span><br><span class="line">traceroute</span><br><span class="line">grep</span><br><span class="line">awk</span><br><span class="line">sed</span><br><span class="line">mv </span><br><span class="line">cp</span><br><span class="line">tar</span><br><span class="line">su</span><br><span class="line">ssh</span><br><span class="line">wget</span><br><span class="line">apt-get</span><br><span class="line">vim</span><br><span class="line">chmod</span><br><span class="line">chown</span><br><span class="line">chgrp</span><br><span class="line">ls</span><br><span class="line">alias</span><br><span class="line">cd</span><br><span class="line">tree</span><br><span class="line">pwd</span><br><span class="line">mkdir </span><br><span class="line">touch</span><br><span class="line">kill</span><br><span class="line">free</span><br><span class="line">find</span><br><span class="line">locate</span><br><span class="line">whereis</span><br><span class="line">df</span><br><span class="line">du</span><br><span class="line">date</span><br><span class="line">who</span><br><span class="line">free -m</span><br><span class="line">uname -a</span><br><span class="line">uname -r</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h3><p>正则表达式</p><p><code>grep</code>擅长查找功能，<code>sed</code>擅长取行和替换。<code>awk</code>擅长取列</p><h4 id="grep用法"><a href="#grep用法" class="headerlink" title="grep用法"></a>grep用法</h4><ul><li>-i 忽略字符的大小写</li><li>-o 仅显示匹配到的字符串</li><li>-n 显示行号</li><li>. 匹配任意一个字符（除了换行符）</li><li>[0-9]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sed用法"><a href="#sed用法" class="headerlink" title="sed用法"></a>sed用法</h4><h4 id="awk用法"><a href="#awk用法" class="headerlink" title="awk用法"></a>awk用法</h4><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><h3 id="你在Linux上部署过哪些应用"><a href="#你在Linux上部署过哪些应用" class="headerlink" title="你在Linux上部署过哪些应用"></a>你在Linux上部署过哪些应用</h3><ul><li>个人博客</li><li>ftp服务器</li><li>搭建个人图床</li><li>用来写markdown笔记的Chevereto图床</li><li>在线的jupyter notebook</li><li>用docker 部署java ssm应用 </li></ul><h3 id="apache-和-nginx比较"><a href="#apache-和-nginx比较" class="headerlink" title="apache 和 nginx比较"></a>apache 和 nginx比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx 相对 apache 的优点: </span><br><span class="line"></span><br><span class="line">轻量级，同样起web服务，比apache占用更少的内存及资源 </span><br><span class="line">抗并发，nginx处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下nginx能保持 </span><br><span class="line">低资源低消耗高性能 </span><br><span class="line">高度模块化的设计，编写模块相对简单 </span><br><span class="line">社区活跃，各种高性能模块出品迅速啊 </span><br><span class="line">apache 相对 nginx 的优点: </span><br><span class="line"></span><br><span class="line">ewrite，比nginx的rewrite强大 </span><br><span class="line">模块超多，基本想到的都可以找到 </span><br><span class="line">少bug，nginx的bug相对较多 </span><br><span class="line">超稳定 </span><br><span class="line">一般来说，需要性能的 web 服务，用 nginx 。 如果不需要性能只求稳定，那就 apache 吧。 </span><br></pre></td></tr></table></figure><h3 id="Linux系统开机流程"><a href="#Linux系统开机流程" class="headerlink" title="Linux系统开机流程"></a>Linux系统开机流程</h3><p><a href="https://www.linuxprobe.com/linux-boot-process-steps.html">https://www.linuxprobe.com/linux-boot-process-steps.html</a></p><p><a href="https://www.runoob.com/linux/linux-system-boot.html">https://www.runoob.com/linux/linux-system-boot.html</a></p><p>BIOS -&gt; MBR -&gt; 引导加载程序 -&gt; 内核 -&gt; init process -&gt; login</p><p>Linux预置七种运行级别（0-6）。一般来说，0是关机，1是单用户模式（也就是维护模式），6是重启。运行级别2-5，各个发行版不太一样，对于Debian来说，都是同样的多用户模式（也就是正常模式）。</p><p>Linux系统有7个运行级别(runlevel)：</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line">POST 加电自检--》MBR 引导--》GRUB--》加载内核--》启动 init 进程--》读取&#x2F;etc&#x2F;inittab</span><br><span class="line">文件，&#x2F;etc&#x2F;init&#x2F;*.conf 文件--》使用&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 初始化脚本--》执行&#x2F;etc&#x2F;rc.d&#x2F;rc</span><br><span class="line">脚本（加载&#x2F;etc&#x2F;rc3.d&#x2F;下所有脚本）--》执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local--》执行&#x2F;bin&#x2F;login 登录</span><br><span class="line">程序</span><br><span class="line">(2)</span><br><span class="line">查询程序运行级别：runlevel</span><br><span class="line">(3)</span><br><span class="line">修改运行级别：init [0123456]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux根目录下各个目录的用途的和含义"><a href="#Linux根目录下各个目录的用途的和含义" class="headerlink" title="Linux根目录下各个目录的用途的和含义"></a>Linux根目录下各个目录的用途的和含义</h3><p><a href="https://blog.csdn.net/ZmeiXuan/article/details/78052577?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare">https://blog.csdn.net/ZmeiXuan/article/details/78052577?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare</a></p><p><a href="https://blog.csdn.net/weixin_40331034/article/details/79522923">https://blog.csdn.net/weixin_40331034/article/details/79522923</a></p><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/1009724-20161028163928734-1842519192.png" alt="Linux-根目录"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1. &#x2F;bin - 重要的二进制 (binary) 应用程序</span><br><span class="line">包含二进制文件，系统的所有用户使用的命令都在这个目录下。 </span><br><span class="line">2.&#x2F;boot - 启动 (boot) 配置文件</span><br><span class="line">包含引导加载程序相关的文件</span><br><span class="line">3.&#x2F;dev - 设备 (device) 文件</span><br><span class="line">包含设备文件，包括终端设备，USB或连接到系统的任何设备。</span><br><span class="line">4.&#x2F;etc - 配置文件、启动脚本等 (etc)</span><br><span class="line">包含所有程序所需的配置文件，也包含了用于启动&#x2F;停止单个程序的启动和关闭shell脚本。</span><br><span class="line">5.&#x2F;home - 本地用户主 (home) 目录</span><br><span class="line">所有用户用home目录来存储他们的个人档案</span><br><span class="line">6.&#x2F;lib - 系统库 (libraries) 文件</span><br><span class="line">包含支持位于&#x2F;bin和&#x2F;sbin下的二进制文件的库文件。</span><br><span class="line">7.&#x2F;lost+found - 在根 (&#x2F;) 目录下提供一个遗失+查找(lost+found) 系统</span><br><span class="line">必须在root用户下才可以查看当前目录下的内容。</span><br><span class="line">8.&#x2F;media - 挂载可移动介质 (media)，诸如 CD、数码相机等</span><br><span class="line">用于挂载可移动设备的临时目录</span><br><span class="line">9.&#x2F;mnt - 挂载 (mounted) 文件系统</span><br><span class="line">临时安装目录，系统管理员可以挂载文件系统</span><br><span class="line">10.&#x2F;opt - 提供一个供可选的 (optional) 应用程序安装目录</span><br><span class="line">包含从各个厂商的附加应用程序，附加的应用程序应该安装在&#x2F;opt或者&#x2F;opt的子目录下。</span><br><span class="line">11.&#x2F;proc - 特殊的动态目录，用以维护系统信息和状态，包括当前运行中进程 (processes) 信息。</span><br><span class="line">包含系统进程的相关信息，是一个虚拟的文件系统，包含有关正在运行的进程的信息，系统资源以文本信息形式存在。</span><br><span class="line">12.&#x2F;root - root (root) 用户主文件夹，读作“slash-root”</span><br><span class="line">13.&#x2F;sbin - 重要的系统二进制 (system binaries) 文件</span><br><span class="line">也是包含的二进制可执行文件。在这个目录下的linux命令通常都是由系统管理员使用的，对系统进行维护。</span><br><span class="line">14.&#x2F;sys - 系统 (system) 文件</span><br><span class="line">15.&#x2F;tmp - 临时(temporary)文件</span><br><span class="line">包含系统和用户创建的临时文件。当系统重启时，这个目录下的文件将都被删除</span><br><span class="line">16.&#x2F;usr - 包含绝大部分所有用户(users)都能访问的应用程序和文件</span><br><span class="line">包含二进制文件，库文件。文档和二级程序的源代码</span><br><span class="line">17.&#x2F;var - 经常变化的(variable)文件，诸如日志或数据库等</span><br><span class="line">代表变量文件。在这个目录下可以找到内容可能增长的文件</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="负载均衡以及常见的负载均衡算法"><a href="#负载均衡以及常见的负载均衡算法" class="headerlink" title="负载均衡以及常见的负载均衡算法"></a>负载均衡以及常见的负载均衡算法</h3><p><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782">https://blog.csdn.net/okiwilldoit/article/details/81738782</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加权轮询</span><br><span class="line">随机法</span><br><span class="line">轮询法</span><br></pre></td></tr></table></figure><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="RAID存储"><a href="#RAID存储" class="headerlink" title="RAID存储"></a>RAID存储</h3><p><a href="https://blog.csdn.net/ensp1/article/details/81318135">https://blog.csdn.net/ensp1/article/details/81318135</a></p><p>RAID6和RAID10</p><h3 id="什么是块存储、对象存储和文件存储"><a href="#什么是块存储、对象存储和文件存储" class="headerlink" title="什么是块存储、对象存储和文件存储"></a>什么是块存储、对象存储和文件存储</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="什么是DAS、SAN、NAS"><a href="#什么是DAS、SAN、NAS" class="headerlink" title="什么是DAS、SAN、NAS"></a>什么是DAS、SAN、NAS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DAS(Direct-attached Storage) 直连存储</span><br><span class="line">直连式存储与服务器主机之间的连接通常采用 SCSI 连接 ， SCSI 通道 是 IO 瓶颈 ; 服务器主机 SCSI ID 资源有限，能够建立的 SCSI 通道连接有限。</span><br><span class="line">无论直连式存储还是服务器主机的扩展，从一台服务器扩展为多台服务器组成的群集 (Cluster) ，或 存储阵列 容量的扩展，都会造成业务系统的停机，</span><br><span class="line"></span><br><span class="line">NAS(Network Attached Storage)  网络附加存储——是一个网络上的文件系统</span><br><span class="line">存储设备通过标准的网络拓扑结构 ( 以太网 ) 添加到一群计算机上。应用：文档图片电影共享，云存储。 NAS 即插即用，支持多平台。</span><br><span class="line">NAS 有一关键问题，即备份过程中的带宽消耗， NAS 仍使用网络进行备份和恢复。 NAS 的一个缺点是它将存储事务由并行 SCSI 连接转移到网络上，也就是说 LAN 除了必须处理正常的最终用户传输流外，还必须处理包括备份操作的存储磁盘请求。</span><br><span class="line">NAS 需要服务器自己搜索它的硬盘</span><br><span class="line"></span><br><span class="line">SAN(Storage Area Network)  存储区域网络——是一个网络上的磁盘</span><br><span class="line">通过光纤通道交换机连接存储阵列和服务器主机，最后成为一个专用存储网络。 SAN 提供了一种与现有 LAN 连接的简易方法，并且通过同一物理通道支持广泛使用的 SCSI 和 IP 协议。 SAN 允许企业独立地增加它们的存储容量。 SAN 的结构允许任何服务器连接到任何存储阵列，这样不管数据放在哪里，服务器都可以直接存取所需的数据。因为采用了光纤接口， SAN 还具有更高的带宽。</span><br></pre></td></tr></table></figure><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h4 id="为什么要进行三次握手，而不是两次或者四次握手"><a href="#为什么要进行三次握手，而不是两次或者四次握手" class="headerlink" title="为什么要进行三次握手，而不是两次或者四次握手"></a>为什么要进行三次握手，而不是两次或者四次握手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先TCP是全双工的，也就是客户端和服务器端可以同时进行通讯，同时也需要确保传输的可靠性，如果进行两次握手的话，仅仅是客户端知道服务器端可以进行消息的收发，而服务器端仅仅知道客户端可以发送，是否接收到信息是不知道的，因此需要多加一次握手过程，来让服务器知道客户算具有发送和接受消息的能力。因此三次握手就足够进行消息通信了，没有必要进行四次握手。</span><br></pre></td></tr></table></figure><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/20180208112533496" alt="在这里插入图片描述"></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①客户端想要释放连接，向服务器端发送一段TCP报文，其中：标记位为FIN，表示“请求释放连接“</span><br><span class="line">②服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：标记位为ACK，表示“接收到客户端发送的释放连接的请求”；</span><br><span class="line">③服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。</span><br><span class="line">④客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：标记位为ACK，表示“接收到服务器准备好释放连接的信号”。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/clay_guo/pic-bed/raw/master/img/1044137-20170902002528249-1310506838.png" alt="img" style="zoom:150%;" /><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层 ：为数据端设备提供传送数据通路、传输数据</span><br><span class="line">数据链路层：提供介质访问和链路管理 arp</span><br><span class="line">网络层：ip选址及路由选择 ICMP(ping命令) </span><br><span class="line">传输层：建立管理和维护端到端的连接 tcp&#x2F;udp协议</span><br><span class="line">会话层：建立、管理和维护会话 </span><br><span class="line">表示层：数据格式转换，数据加密</span><br><span class="line">应用层：为应用程序提供服务   http https ftp telnet smtp pop3 DNS</span><br></pre></td></tr></table></figure><h3 id="五层协议有哪些"><a href="#五层协议有哪些" class="headerlink" title="五层协议有哪些"></a>五层协议有哪些</h3><p>去掉七层协议中的<code>会话层</code>和<code>表示层</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">物理层</span><br><span class="line">数据链路层</span><br><span class="line">网络层</span><br><span class="line">传输层</span><br><span class="line">应用层</span><br></pre></td></tr></table></figure><h3 id="四层网络"><a href="#四层网络" class="headerlink" title="四层网络"></a>四层网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网络接口层 包括用于协作IP数据在已有网络介质上传输的协议。ARP,RARP</span><br><span class="line">网间层</span><br><span class="line">传输层</span><br><span class="line">应用层</span><br></pre></td></tr></table></figure><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line"></span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</span><br><span class="line"></span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</span><br><span class="line"></span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line"></span><br><span class="line">5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</span><br></pre></td></tr></table></figure><h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</span><br><span class="line"></span><br><span class="line">2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</span><br><span class="line"></span><br><span class="line">   Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</span><br><span class="line"></span><br><span class="line">3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</span><br><span class="line"></span><br><span class="line">4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</span><br><span class="line"></span><br><span class="line">5、TCP对系统资源要求较多，UDP对系统资源要求较少。</span><br><span class="line">   udp对实施应用很有用如视频会议或者直播，但是在实际开发中直播一般还是采用的tcp。常见的直播方案都是上行采用rtmp；下行采用http-flv或者hls，底层都是tcp。    利用rtmp协议可以很快搭建一套直播系统，客户端、服务器都有成熟稳定的开源实现。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TCP如何确保可靠传输的"><a href="#TCP如何确保可靠传输的" class="headerlink" title="TCP如何确保可靠传输的"></a>TCP如何确保可靠传输的</h3><h4 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP的四种拥塞控制算法: 1.慢开始  2.拥塞控制 3.快重传 4.快恢复</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">一、传输信息安全性不同</span><br><span class="line"></span><br><span class="line">1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</span><br><span class="line"></span><br><span class="line">2、https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。</span><br><span class="line">二、连接方式不同</span><br><span class="line"></span><br><span class="line">1、http协议：http的连接很简单，是无状态的。</span><br><span class="line"></span><br><span class="line">2、https协议：是由SSL（安全套接字协议）＋HTTP协议构建的可进行加密传输、身份认证的网络协议。</span><br><span class="line"></span><br><span class="line">三、端口不同</span><br><span class="line"></span><br><span class="line">1、http协议：使用的端口是80。</span><br><span class="line"></span><br><span class="line">2、https协议：使用的端口是443．</span><br><span class="line"></span><br><span class="line">四、证书申请方式不同</span><br><span class="line"></span><br><span class="line">1、http协议：免费申请。</span><br><span class="line"></span><br><span class="line">2、https协议：需要到ca申请证书，一般免费证书很少，需要交费。</span><br></pre></td></tr></table></figure><h3 id="http1-0-1-1-和2-0的区别"><a href="#http1-0-1-1-和2-0的区别" class="headerlink" title="http1.0 1.1 和2.0的区别"></a>http1.0 1.1 和2.0的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DHCP的工作原理"><a href="#DHCP的工作原理" class="headerlink" title="DHCP的工作原理"></a>DHCP的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端发送广播包到DHCP服务器</span><br></pre></td></tr></table></figure><h3 id="DNS的工作原理"><a href="#DNS的工作原理" class="headerlink" title="DNS的工作原理"></a>DNS的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DNS 全称叫做域名解析系统</span><br><span class="line">例如我们访问www.baidu.com，实际上在背后我们是访问对应web服务器的ip地址，但是对于人来说，记住ip地址要更加繁琐，因此可以用域名来方便人们记忆</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是根据IP地址获取物理地址的一个TCP&#x2F;IP协议</span><br><span class="line">他是工作在数据链路层的一个协议</span><br></pre></td></tr></table></figure><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反向地址转换协议</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用的电脑访问不了外网，排查思路是什么？"><a href="#使用的电脑访问不了外网，排查思路是什么？" class="headerlink" title="使用的电脑访问不了外网，排查思路是什么？"></a>使用的电脑访问不了外网，排查思路是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以来使用traceroute命令进行排查，看具体是内网不同还是上外网不通</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RIP和OSPF有什么区别"><a href="#RIP和OSPF有什么区别" class="headerlink" title="RIP和OSPF有什么区别"></a>RIP和OSPF有什么区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rip和OSPF的学习方式</span><br><span class="line"></span><br><span class="line">rip适合于小型网络</span><br><span class="line">OSPF</span><br></pre></td></tr></table></figure><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是死锁，发生原因是什么，如何解决和避免产生死锁？"><a href="#什么是死锁，发生原因是什么，如何解决和避免产生死锁？" class="headerlink" title="什么是死锁，发生原因是什么，如何解决和避免产生死锁？"></a>什么是死锁，发生原因是什么，如何解决和避免产生死锁？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①多个进程争夺一个资源导致陷入一个互相等待的僵局。</span><br><span class="line">②</span><br><span class="line">③银行家算法</span><br></pre></td></tr></table></figure><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个进程可以包含多个进程</span><br><span class="line">进程是</span><br><span class="line">线程是</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="为什么要用数据库索引，怎么用？如何创建？"><a href="#为什么要用数据库索引，怎么用？如何创建？" class="headerlink" title="为什么要用数据库索引，怎么用？如何创建？"></a>为什么要用数据库索引，怎么用？如何创建？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</span><br><span class="line"></span><br><span class="line">create index xxx on </span><br></pre></td></tr></table></figure><h3 id="数据库冷热备份"><a href="#数据库冷热备份" class="headerlink" title="数据库冷热备份"></a>数据库冷热备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何优化数据库"><a href="#如何优化数据库" class="headerlink" title="如何优化数据库"></a>如何优化数据库</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="请说一下你对“高内聚低耦合”的理解"><a href="#请说一下你对“高内聚低耦合”的理解" class="headerlink" title="请说一下你对“高内聚低耦合”的理解"></a>请说一下你对“高内聚低耦合”的理解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高内聚：修改一个模块的时候不会对其他的模块造成影响</span><br><span class="line">低耦合：模块之间的关联尽量减少</span><br></pre></td></tr></table></figure><h3 id="你开发的程序里面你用过哪些设计模式"><a href="#你开发的程序里面你用过哪些设计模式" class="headerlink" title="你开发的程序里面你用过哪些设计模式"></a>你开发的程序里面你用过哪些设计模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工厂模式</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见的设计模式有哪些？"><a href="#常见的设计模式有哪些？" class="headerlink" title="常见的设计模式有哪些？"></a>常见的设计模式有哪些？</h3><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Java和JS的区别"><a href="#Java和JS的区别" class="headerlink" title="Java和JS的区别"></a>Java和JS的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先，Java和JavaScript是没有一点关系的。</span><br><span class="line">其次就是Java是用来写后端的语言，js是用来写前端的语言。</span><br></pre></td></tr></table></figure><h1 id="最后提问环节"><a href="#最后提问环节" class="headerlink" title="最后提问环节"></a>最后提问环节</h1><ul><li><p>公司对我这个职位的期望是什么？</p><ul><li></li></ul></li><li><p>这个职位未来几年的职业发展是怎样的？</p><ul><li></li></ul></li><li><p>为了胜任这个岗位我还需要学习哪些技</p></li></ul><p>  术知识？</p><ul><li><p>vue</p></li><li><p>Flask</p></li><li><p>OpenStack</p></li><li><p>ceph</p></li><li><p>Django</p></li><li><p>Docker</p></li><li><p>对于实习生或者应届生技能上的要求</p><ul><li>前后端</li></ul></li><li><p>刚才问的那个技术问题某个细节我还不太明白，能解释下吗？</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

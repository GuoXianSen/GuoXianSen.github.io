<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>贪心算法 | Clay_Guo的博客</title><meta name="keywords" content="LeetCode,贪心"><meta name="author" content="Clay_Guo"><meta name="copyright" content="Clay_Guo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="贪心算法大纲题目分类大纲：  什么是贪心算法？贪心算法就是在每个阶段都选择局部最优解，从而达到全局最优。 贪心算法解题步骤 将问题分解为若干个子问题 找出合适的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解  练习题455、分发饼干  思路 遍历胃口和饼干列表，但是需要注意的是饼干列表不是每次都在移动，而是匹配了一个才会移动，因此这里不需要进行两层for循环，只需要一层for循">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Clay_Guo的博客">
<meta property="og:description" content="贪心算法大纲题目分类大纲：  什么是贪心算法？贪心算法就是在每个阶段都选择局部最优解，从而达到全局最优。 贪心算法解题步骤 将问题分解为若干个子问题 找出合适的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解  练习题455、分发饼干  思路 遍历胃口和饼干列表，但是需要注意的是饼干列表不是每次都在移动，而是匹配了一个才会移动，因此这里不需要进行两层for循环，只需要一层for循">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529112.png">
<meta property="article:published_time" content="2023-11-25T07:09:53.000Z">
<meta property="article:modified_time" content="2024-03-05T07:29:16.221Z">
<meta property="article:author" content="Clay_Guo">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="贪心">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529112.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-03-05 15:29:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Clay_Guo的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529112.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Clay_Guo的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">贪心算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-25T07:09:53.000Z" title="Created 2023-11-25 15:09:53">2023-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-03-05T07:29:16.221Z" title="Updated 2024-03-05 15:29:16">2024-03-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529112.png" alt="image-20240305152826178"></p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>题目分类大纲：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252041388.png" alt="贪心算法大纲"></p>
<h2 id="什么是贪心算法？"><a href="#什么是贪心算法？" class="headerlink" title="什么是贪心算法？"></a>什么是贪心算法？</h2><p>贪心算法就是在每个阶段都选择局部最优解，从而达到全局最优。</p>
<h2 id="贪心算法解题步骤"><a href="#贪心算法解题步骤" class="headerlink" title="贪心算法解题步骤"></a>贪心算法解题步骤</h2><ul>
<li>将问题分解为若干个子问题</li>
<li>找出合适的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="455、分发饼干"><a href="#455、分发饼干" class="headerlink" title="455、分发饼干"></a>455、分发饼干</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252045681.png" alt="image-20231125204525836"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252045154.png" alt="image-20231125204541221"></p>
<p><strong>思路</strong></p>
<p>遍历胃口和饼干列表，但是需要注意的是饼干列表不是每次都在移动，而是匹配了一个才会移动，因此这里不需要进行两层for循环，只需要一层for循环来遍历胃口列表即可。然后饼干列表可以使用一个指针index进行遍历，只有在能够进行匹配的情况下才需要将index进行移动。同时使用index来保存返回的结果。==index可以直接用来当做最终的结果进行返回==</p>
<p>利用贪心算法，每次都尽量喂饱胃口最大的，如果满足不了则往后移动判断能否满足下一个胃口最大的。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 先满足大胃口 | 此时胃口在移动</span></span><br><span class="line">        g.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        s.sort(reverse=<span class="literal">True</span>) <span class="comment"># 从大到小</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g)):</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> s[index]&gt;=g[i]:</span><br><span class="line">                index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252104655.png" alt="image-20231125210434577"></p>
<p>本题不能先移动饼干，如果先移动饼干的话，就会出现下面的情况，导致最终没有满足条件的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311252123926.png" alt="img"></p>
<p>当然本题也可以先满足胃口小的，做法是类似的。但是如果是满足小胃口的话，就需要注意循环的顺序，这时候就是先遍历饼干，然后使用index对胃口列表进行遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(g) <span class="keyword">and</span> s[i]&gt;=g[index]:</span><br><span class="line">                index+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>

<h2 id="376、摆动序列"><a href="#376、摆动序列" class="headerlink" title="376、摆动序列(*)"></a>376、摆动序列(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271458628.png" alt="image-20231127145825546"></p>
<p>计算峰值</p>
<p>prediff = nums[i] - nums[i-1]</p>
<p>curdiff = nums[i+1] - nums[i]</p>
<p>如果prediff&gt;0 and curdiff &lt; 0 或者 prediff &lt; 0 and curdiff &gt; 0，就需要统计波动</p>
<p>有三种特殊情况需要考虑：</p>
<ul>
<li>情况一：上下坡中有平坡</li>
<li>情况二：数组首尾两端</li>
<li>情况三：单调坡中有平坡</li>
</ul>
<p><strong>情况一：上下坡中有平坡</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271510146.png" alt="img"></p>
<p>可以统一规则，删除左边的3个2</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271511303.png" alt="img"></p>
<p><strong>情况二：数组首尾两端</strong></p>
<p>如果数组中只包含两个元素，如果这两个元素不相同则摆动序列也为2</p>
<p>例如序列[2, 5]，如果靠统计差值计算峰值，需要有三个数才能进行统计，这时候，我们可以假定这个序列为[2,2,5]，这样<code>preDiff=0 and curDiff=3</code>，满足我们的条件，<code>res+=1</code>，就可以统一写法，不需要单独把<code>len(nums)==2</code>的情况单独拎出来了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271525974.png" alt="376.摆动序列1"></p>
<p>针对上述情况，我们可以假设res = 1，默认最右边有一个峰值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (preDiff&gt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>) <span class="keyword">or</span> (preDiff&lt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            preDiff = curDiff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这样的代码已经可以AC掉力扣中给出的测试用例，但是提交之后还是会有报错，这是因为这个代码忽略了<code>情况三</code>。</p>
<p><strong>情况三：单调坡中有平坡</strong></p>
<p>如果这时候的序列是[1, 2, 2, 2, 5]这样的，在上面的代码中得到的答案是3而不是2，这是因为程序的执行会按照情况一进行了。此时我们只需要进行的改动是只有在满足情况的条件下才会去修改<code>preDiff</code>指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (preDiff&gt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>) <span class="keyword">or</span> (preDiff&lt;=<span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                preDiff = curDiff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271530437.png" alt="image-20231127153052502"></p>
<h2 id="53、最大子数组和（-）"><a href="#53、最大子数组和（-）" class="headerlink" title="53、最大子数组和（*）"></a>53、最大子数组和（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271548474.png" alt="image-20231127154858508"></p>
<p>初次尝试：</p>
<p>两层for循环进行遍历，计算所有子序列的和，碰到最大的就修改max_。这里需要注意<strong>max_</strong>在进行初始化的时候需要初始化为最小值<code>float(&quot;-inf&quot;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># print(i,j)</span></span><br><span class="line">                <span class="comment"># print(nums[i:j+1])</span></span><br><span class="line">                max_ = <span class="built_in">max</span>(max_,<span class="built_in">sum</span>(nums[i:j+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>

<p>力扣中Python代码超时200/210</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271555768.png" alt="image-20231127155543817"></p>
<p>使用==贪心算法==</p>
<p>使用count进行和计算，如果碰到一个负数使得当前的count值小于0，则将count赋值为0重新进行子序列寻找，也设置一个max_初始化为最小值，当count&gt;max_时，就进行更新。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_ = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            count+=nums[i]</span><br><span class="line">            <span class="keyword">if</span> count&gt;max_:</span><br><span class="line">                max_ = count</span><br><span class="line">            <span class="keyword">if</span> count&lt;<span class="number">0</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311271556201.png" alt="image-20231127155602214"></p>
<h2 id="122、买卖股票的最佳时机II"><a href="#122、买卖股票的最佳时机II" class="headerlink" title="122、买卖股票的最佳时机II"></a>122、买卖股票的最佳时机II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272129099.png" alt="image-20231127212916141"></p>
<p>题目中提到只能购买或者出售股票，并且最多持有一支股票。</p>
<p>只统计利润为正的即可得到最大收益。</p>
<p>贪心算法进行求解时，需要对利润进行拆解：以下面这个例子为例，我们只需要收集正利润的区间，就是股票买卖的区间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272133164.png" alt="122.买卖股票的最佳时机II"></p>
<p>贪心算法就体现在每天只取正利润的部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            profit += <span class="built_in">max</span>(<span class="number">0</span>,prices[i]-prices[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>



<h2 id="55、跳跃游戏"><a href="#55、跳跃游戏" class="headerlink" title="55、跳跃游戏"></a>55、跳跃游戏</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272143796.png" alt="image-20231127214313444"></p>
<p>本题思路：通过查看当前结点能够跳跃的最远范围进行校验</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272206381.png" alt="img"></p>
<p>这里nums中的元素所表示的含义是能够跳跃的最远范围，我们只需要判断其能够覆盖的范围，然后用其与len(nums)-1进行比较，如果大于等于则返回True，否则循环结束也无法到达最后一个下标的话，则返回False。</p>
<p>注意这里需要判断<code>i</code>的范围不能超过当前最远能够到达的区域，如果<code>i</code>超过了<code>max_reach</code>则直接break。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        max_reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; max_reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            max_reach = <span class="built_in">max</span>(nums[i]+i, max_reach)</span><br><span class="line">            <span class="keyword">if</span> max_reach &gt;= <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311272209796.png" alt="image-20231127220956157"></p>
<p>在Python中无法动态修改for循环中的循环变量，可以改用while循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= reach:</span><br><span class="line">            reach = <span class="built_in">max</span>(reach, nums[i]+i)</span><br><span class="line">            <span class="keyword">if</span> reach&gt;=<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="45、跳跃游戏II"><a href="#45、跳跃游戏II" class="headerlink" title="45、跳跃游戏II"></a>45、跳跃游戏II</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281000659.png" alt="image-20231128100052826"></p>
<p>跳跃游戏中，需要我们判断是否能够到达最后一个下标，本题需要我们计算从第一个元素开始到最后一个下标的最小跳跃次数。</p>
<p>贪心的思路</p>
<ul>
<li>局部最优<ul>
<li>当前尽可能走更多，如果还没到达终点，步数+1</li>
</ul>
</li>
<li>整体最优<ul>
<li>一步尽可能走更多，从而达到步数最少</li>
</ul>
</li>
</ul>
<p>记录当前可以覆盖的最远距离和下一步可以覆盖的最远距离</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281017722.png" alt="45.跳跃游戏II"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        cur_reach = <span class="number">0</span> <span class="comment"># 当前能够到达的最远距离</span></span><br><span class="line">        next_reach = <span class="number">0</span> <span class="comment"># 下一步能够到达的最远距离</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment"># 记录走的步数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            next_reach = <span class="built_in">max</span>(next_reach, nums[i]+i)</span><br><span class="line">            <span class="keyword">if</span> i == cur_reach:</span><br><span class="line">                res +=<span class="number">1</span></span><br><span class="line">                cur_reach = next_reach</span><br><span class="line">                <span class="keyword">if</span> next_reach&gt;=<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h2 id="1005、K次取反后最大化数组和"><a href="#1005、K次取反后最大化数组和" class="headerlink" title="1005、K次取反后最大化数组和"></a>1005、K次取反后最大化数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281030036.png" alt="image-20231128103034570"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281030159.png" alt="image-20231128103050303"></p>
<p>局部最优解：让绝对值最大的负数变为正数，刚好可以利用Python中排序的<code>key</code>关键字，使用<code>lambda</code>表达式。如果。</p>
<p>如果数组内全部为正数，那么只需要将最小值也就是排序过后的数组中的最后一个元素在k为奇数的时候将其值修改为-1倍。</p>
<p>先按照绝对值大小进行排序，排序后再进行遍历的过程中寻找小于0且此时k大于0，然后将其值修改为-1倍，直到循环结束。如果循环结束之后k==1的话，就让nums中绝对值最小的数×(-1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">abs</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        print(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果nums都大于0呢？？？ 都大于0 不进入循环</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">0</span> <span class="keyword">and</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                nums[i]*=-<span class="number">1</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果nums都大于0 只需要修改最小的那个值 修改其为负数即可</span></span><br><span class="line">        <span class="comment"># 如果k为偶数的话，也可以不修改</span></span><br><span class="line">        <span class="keyword">if</span> k%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281047717.png" alt="image-20231128104748129"></p>
<h2 id="134、加油站（-）"><a href="#134、加油站（-）" class="headerlink" title="134、加油站（*）"></a>134、加油站（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281513600.png" alt="image-20231128151314321"></p>
<p><strong>暴力算法</strong></p>
<p>暴力算法就是通过两层循环嵌套，外层循环表示从哪个加油站出发，内存循环进行判断是否能够绕一周回到当前位置，设置一个index表示当前所到达的加油站位置，经过内层循环如果能够绕一周到原来的位置，即<code>index==i</code>并且剩余的油量还大于等于0的话，返回当前外层循环的循环变量<code>i</code>。</p>
<p>这里index进行增加的时候因为是环形，类似于循环队列，需要除以<code>len(gas)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 绕环路行驶一周</span></span><br><span class="line">        <span class="comment"># 模拟从各个加油站出发是否还能到达当前加油站</span></span><br><span class="line">        mygas = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从编号为i的加油站出发</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            mygas = gas[i]-cost[i] <span class="comment"># 剩余的汽油</span></span><br><span class="line">            index = (i+<span class="number">1</span>)%<span class="built_in">len</span>(gas)</span><br><span class="line">            <span class="keyword">while</span> mygas&gt;=<span class="number">0</span> <span class="keyword">and</span> index!=i:</span><br><span class="line">                mygas += gas[index]</span><br><span class="line">                mygas -= cost[index]</span><br><span class="line">                index = (index+<span class="number">1</span>)%<span class="built_in">len</span>(gas)</span><br><span class="line">            <span class="keyword">if</span> mygas&gt;=<span class="number">0</span> <span class="keyword">and</span> index==i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>算法分析</p>
<ul>
<li>时间复杂度 O(n^2^)</li>
<li>空间复杂度 O(1)</li>
</ul>
<p>暴力算法会超时</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281338161.png" alt="image-20231128133810328"></p>
<p><strong>贪心算法（1）</strong></p>
<p>分情况讨论：</p>
<ul>
<li>情况1：如果gas总量小于cost总量，则无论从哪里出发都无法绕一圈回到起点</li>
<li>情况2：rest[i]=gas[i]-cost[i]为一天剩下的油，i从0开始累加到最后一个加油站， 如果累加没有出现负数，那么就从0开始，0号为起点</li>
<li>情况3：如果累加的值为负数，说明不是从0开始，从后向前，看哪个节点可以把这个负数填平，如果能把负数填平的节点就是出发点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(gas)&lt;<span class="built_in">sum</span>(cost):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest+=gas[i]-cost[i]</span><br><span class="line">            min_ = <span class="built_in">min</span>(min_,rest)</span><br><span class="line">        print(rest,min_)</span><br><span class="line">        <span class="comment"># 如果min_&gt;=0 说明从0开始出发即可</span></span><br><span class="line">        <span class="keyword">if</span> min_&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果min_&lt;0  说明需要从非0出发点出发</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># ？</span></span><br><span class="line">            rest = gas[i]-cost[i]</span><br><span class="line">            min_ += rest</span><br><span class="line">            <span class="keyword">if</span> min_&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p><strong>贪心算法2</strong></p>
<p>首先判断gas总和是否小于cost，小于则直接返回-1</p>
<p>然后通过累加gas[i]-cost[i]，如果差值小于0，出发的起点一定不在[0,i]这个区间范围内，需要从i+1开始进行判断。同时如果计算到某个节点rest&lt;0，还需要将rest置为0重新计算。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281855770.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281855126.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas: List[<span class="built_in">int</span>], cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(gas)&lt;<span class="built_in">sum</span>(cost):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>        </span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        rest = <span class="number">0</span> <span class="comment"># 用于计算差值的累加和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest += gas[i]-cost[i]</span><br><span class="line">            <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 下标要从i+1开始</span></span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                rest = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281853030.png" alt="加油站-贪心算法"></p>
<ul>
<li>时间复杂度O(n) 只有单层for循环</li>
<li>空间复杂度O(1)</li>
</ul>
<h2 id="135、分发糖果（-）"><a href="#135、分发糖果（-）" class="headerlink" title="135、分发糖果（*）"></a>135、分发糖果（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281859707.png" alt="image-20231128185903873"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311281859282.png" alt="image-20231128185919854"></p>
<p>题目中说到相邻的两个孩子评分更高的孩子会获得更多的糖果，需要迭代的去进行比较，及时更新每一步。</p>
<p>这里需要注意，如果需要<strong>判断右孩子比左孩子大的话需要从前往后进行遍历</strong>，因为后面的值需要前面的结果，如果是<strong>判断左孩子比右孩子的大的话需要从后往前进行遍历</strong>，因为前面的结果需要依靠后面的结果进行累加，但是需要注意的是，有的结果已经已经比左边大了，同时有比右边大，这时候需要判断当前<code>res[i]</code>和<code>res[i+1]+1</code>哪个值更大就赋值为哪个值避免测试用例的错误。</p>
<p>出错的测试用例 ratings = [1,3,4,5,2]，错误的地方就在于在从后往前进行遍历的时候，ratings[3]&gt;ratings[4]，res[3] = res[4]+1 = 2，但是2小于从左往右进行遍历的结果4，这里我们应该选择的是两者的最大值。因此这里使用res[i] = max(res[i],res[i+1]+1)进行赋值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290955837.png" alt="image-20231129095508509"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]*<span class="built_in">len</span>(ratings)</span><br><span class="line">        <span class="comment"># 从前向后 判断右孩子如果比左孩子大的话，就需要进行ratings[i] = ratings[i-1]+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i-<span class="number">1</span>]:</span><br><span class="line">                res[i] = res[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 从后向前 判断如果左孩子比右孩子大的话，就需要进行ratings[i] = ratings[i+1]+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i+<span class="number">1</span>]:</span><br><span class="line">                res[i] = <span class="built_in">max</span>(res[i],res[i+<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(res)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282040660.png" alt="image-20231128204029877"></p>
<p>本题中用到了两次贪心算法</p>
<ul>
<li>一次从前往后进行遍历的贪心算法</li>
<li>一次从后往前进行遍历的贪心算法</li>
</ul>
<h2 id="860、柠檬水找零"><a href="#860、柠檬水找零" class="headerlink" title="860、柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/">860、柠檬水找零</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282044821.png" alt="image-20231128204410801"></p>
<p>如果付款金额为20美元，优先找1张10美元1张5美元，如果没有才找3张5美元的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 判断除了五美元以外的钞票是否能找开</span></span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># myhash = defaultdict(int)</span></span><br><span class="line">        myhash = &#123;<span class="number">20</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">5</span>:<span class="number">0</span>&#125;</span><br><span class="line">        now = []</span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            myhash[bill]+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 超过5块就进行找零</span></span><br><span class="line">            <span class="comment"># print(bill,myhash)</span></span><br><span class="line">            <span class="keyword">if</span> bill==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> myhash[<span class="number">5</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> bill==<span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> (myhash[<span class="number">10</span>]&gt;<span class="number">0</span> <span class="keyword">and</span> myhash[<span class="number">5</span>]&gt;<span class="number">0</span>):</span><br><span class="line">                    myhash[<span class="number">10</span>]-=<span class="number">1</span></span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> myhash[<span class="number">5</span>]&gt;<span class="number">2</span>:</span><br><span class="line">                    myhash[<span class="number">5</span>]-=<span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282110049.png" alt="image-20231128211003521"></p>
<h2 id="406、根据身高重建队列（-）"><a href="#406、根据身高重建队列（-）" class="headerlink" title="406、根据身高重建队列（*）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406、根据身高重建队列（*）</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282203221.png" alt="image-20231128211340233"></p>
<p>题目理解：</p>
<p>本题中需要注意的地方在于列表中的第二个元素是排在其前面总共有多少个人，矮个子排在高个子前面是没有影响的，但是高个子排在矮个子前面是有影响的。另外如果是身高一样的人，第二个数字越大的人排序越靠后，这是第一个排序的因素，第二个排序的因素是如果数字相同，身高越低的人越靠后。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290933096.png" alt="406.根据身高重建队列"></p>
<p>两个维度进行比较的时候会顾此失彼，类似于<strong>分发糖果</strong>的题目！！！</p>
<p>先确定一个维度，贪心另一个维度</p>
<p>做法：</p>
<p>先按照身高逆序排序再按照前面有几个人正序排序。然后通过构建新的列表往其中按照第二个元素位置顺序添加元素来实现最终的答案。</p>
<p>[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</p>
<p>局部最优：优先按照身高people的k进行插入。插入操作后的people满足队列属性</p>
<p>全局最优：全部插入完成后，整个队列满足题目要求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># print(people)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> po <span class="keyword">in</span> people:</span><br><span class="line">            pos = po[<span class="number">1</span>]</span><br><span class="line">            res.insert(pos,po)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311282213282.png" alt="image-20231128221313071"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311290942417.png" alt="image-20231129094227112"></p>
<h2 id="452、用最少数量的箭引爆气球"><a href="#452、用最少数量的箭引爆气球" class="headerlink" title="452、用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452、用最少数量的箭引爆气球</a></h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291013788.png" alt="image-20231129101311418"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291235167.png" alt="image-20231129123511474"></p>
<p>本题属于==区间问题==</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291027692.png" alt="image-20231129102701369"></p>
<p>思路如上，首先对points依据其第一个元素进行排序，得到[[1, 6], [2, 8], [7, 12], [10, 16]]的结果，然后列表进行遍历。遍历的过程中我们队右边界进行更新，每次更新最小的右边界。</p>
<ul>
<li>如果左边界大于右边界<ul>
<li>res = res + 1</li>
</ul>
</li>
<li>左边界小于等于有边界<ul>
<li>更新当前的最小右边界</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 判断是否有重叠的区间？</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(points)</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="comment"># 左边界大于右边界</span></span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新最小右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i][<span class="number">1</span>], points[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p>优化思路：</p>
<p>这个优化后的算法使用贪心策略，先将气球按右边界进行排序，然后遍历气球列表，如果发现当前气球的起始位置大于当前箭的结束位置，说明需要增加箭的数量，并更新箭的结束位置。这样可以有效减少时间复杂度，避免了多次合并区间的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按照气球的右边界进行排序</span></span><br><span class="line">        arrows = <span class="number">1</span></span><br><span class="line">        end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> start, point_end <span class="keyword">in</span> points:</span><br><span class="line">            <span class="comment"># 如果当前气球的起始位置大于当前箭的结束位置，则增加箭的数量，并更新箭的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                arrows += <span class="number">1</span></span><br><span class="line">                end = point_end</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arrows</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311302159946.png" alt="image-20231130215910639"></p>
<h2 id="435、无重叠区间"><a href="#435、无重叠区间" class="headerlink" title="435、无重叠区间"></a>435、无重叠区间</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291555833.png" alt="image-20231129155501224"></p>
<p><strong>贪心算法基于左边界</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291610038.png" alt="image-20231129161034940"></p>
<p>首先对列表进行排序，然后对其进行循环遍历（从列表中的第二个元素开始，即下标为1），如果当前的左边界要小于前一个区间的右边界则说明发生重叠，将res+1，然后看当前结点的右边界是否大于上一个结点的右边界，如果大于则更新，如果小于则不进行操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>本题计算的是如果构造没有重叠区间的话，需要去掉几个区间。</p>
<p>上一题引爆气球是计算的最少需要多少个箭，本题中需要判断的不重叠的区间，只需要用总区间数减去射箭的次数即可。因为在气球爆炸问题中如果是相邻边界，则使用一支箭即可，但在本题中如果相邻不算重叠，所以本题如果采用上一题的思路则条件需要修改为&gt;=，其余的做法都是一致的，修改最终返回值为len(intervals)-res</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>]&gt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新右边界</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals)-res</span><br></pre></td></tr></table></figure>

<h2 id="763、划分字母区间（-）"><a href="#763、划分字母区间（-）" class="headerlink" title="763、划分字母区间（*）"></a>763、划分字母区间（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311291652057.png" alt="image-20231129165215770"></p>
<p>右指针一直取所走过的最大的下标范围，如果当前循环变量的值刚好等于当前的最大右指针则将切割点加入res，切割点的值为right-left+1，同时更新left为i+1</p>
<p>本题难点就在于如何进行遍历过程中的right修改，用哈希表来存放下标并不难。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311292233307.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        myhash = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            myhash[s[i]] = i</span><br><span class="line">        <span class="comment"># print(myhash)</span></span><br><span class="line">        res = []</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span> <span class="comment"># 右指针 结果是切割点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            right = <span class="built_in">max</span>(right,myhash[s[i]])</span><br><span class="line">            <span class="keyword">if</span> right==i:</span><br><span class="line">                res.append(right-left+<span class="number">1</span>)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311300930178.png" alt="image-20231130093057946"></p>
<h2 id="56、合并区间（-）"><a href="#56、合并区间（-）" class="headerlink" title="56、合并区间（*）"></a>56、合并区间（*）</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301912613.png" alt="image-20231130191256419"></p>
<p>思路：首先对区间进行排序，然后对其进行比较</p>
<p>这里需要注意的是，比较res[-1]的时候，用其右边界和当前区间的左边界进行比较，比较的时候是&gt;=，因为[1,2]和[2,3]区间是被视为重叠的区间的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="comment"># print(intervals)</span></span><br><span class="line">        res = [intervals[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> res[-<span class="number">1</span>][<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 合并</span></span><br><span class="line">                res[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], res[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 加入结果集</span></span><br><span class="line">                res.append(intervals[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301917690.png" alt="image-20231130191723043"></p>
<h2 id="区间问题的复盘"><a href="#区间问题的复盘" class="headerlink" title="区间问题的复盘"></a>区间问题的复盘</h2><ol>
<li>用最少数量的箭引爆气球</li>
<li>无重叠区间</li>
<li>划分字母区间</li>
<li>合并区间</li>
</ol>
<h2 id="57、插入区间"><a href="#57、插入区间" class="headerlink" title="57、插入区间"></a>57、插入区间</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922699.png" alt="image-20231130192222475"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922303.png" alt="image-20231130192239982"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311301922614.png" alt="image-20231130192252618"></p>
<h2 id="738、单调递增的数字"><a href="#738、单调递增的数字" class="headerlink" title="738、单调递增的数字"></a>738、单调递增的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202311302145958.png" alt="image-20231130214520514"></p>
<p>暴力解法（超时）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">num</span>):</span></span><br><span class="line">            <span class="comment"># 判断一个数是否是递增的数</span></span><br><span class="line">            nums = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">            nums_sort = <span class="built_in">sorted</span>(nums)</span><br><span class="line">            <span class="comment"># nums_set = list(set(nums))</span></span><br><span class="line">            <span class="comment"># print(nums,nums_sort)</span></span><br><span class="line">            <span class="keyword">return</span> nums==nums_sort</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> judge(i):</span><br><span class="line">                res = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>贪心算法</p>
<p>从后往前进行比较，另外每次修改后都需要将后面的数修改为9，避免类似100这样的问题</p>
<p>从后往前进行遍历 332–&gt; 329 –&gt; 299</p>
<p>从前往后比较会出现问题，例如332，从前往后比较332–&gt;329，此时第二个2小于3了。</p>
<p>从前往后遍历使得后面修改导致数字并不是递增的，从后往前遍历就可以避免这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># num = list(str(n))</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(n)))</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># nums[i+1] = 9</span></span><br><span class="line">                nums[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                    nums[j] = <span class="number">9</span></span><br><span class="line">        <span class="comment"># 如何快速把[1,2,3,4]合并成1234数字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,nums)))</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011719641.png" alt="image-20231201171906141"></p>
<h2 id="968、监控二叉树"><a href="#968、监控二叉树" class="headerlink" title="968、监控二叉树(*)"></a>968、监控二叉树(*)</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011659177.png" alt="image-20231201165920904"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202312011719864.png" alt="image-20231201171951677"></p>
<p>思路：</p>
<h1 id="贪心总结"><a href="#贪心总结" class="headerlink" title="贪心总结"></a>贪心总结</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Clay_Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">https://guoxiansen.github.io/2023/11/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a><a class="post-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529112.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051527105.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">动态规划</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051529522.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">回溯算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/09/LeetCode20-有效的括号/" title="LeetCode20-有效的括号"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">LeetCode20-有效的括号</div></div></a></div><div><a href="/2022/03/09/LeetCode509-斐波那契数/" title="LeetCode509-斐波那契数"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181336431.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">LeetCode509-斐波那契数</div></div></a></div><div><a href="/2023/11/02/二叉树相关总结/" title="二叉树相关总结"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403082043609.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-02</div><div class="title">二叉树相关总结</div></div></a></div><div><a href="/2023/10/21/位运算/" title="位运算"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310210959834.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="title">位运算</div></div></a></div><div><a href="/2023/12/12/单调栈/" title="单调栈"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051526964.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="title">单调栈</div></div></a></div><div><a href="/2023/11/25/动态规划/" title="动态规划"><img class="cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051527105.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">动态规划</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Clay_Guo</div><div class="author-info__description">生活可以忙忙碌碌随大流，思想偷偷摸摸求上进</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GuoXianSen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GuoXianSen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guoyinzhi@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">这是我的博客，欢迎关注！博客还在不断的完善中，敬请期待...<br>QQ:775741842<br>微信:Clay_Guo<br></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.1.</span> <span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">什么是贪心算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.</span> <span class="toc-text">贪心算法解题步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#455%E3%80%81%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">2.1.</span> <span class="toc-text">455、分发饼干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#376%E3%80%81%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">376、摆动序列(*)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%88-%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">53、最大子数组和（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-number">2.4.</span> <span class="toc-text">122、买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">2.5.</span> <span class="toc-text">55、跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII"><span class="toc-number">2.6.</span> <span class="toc-text">45、跳跃游戏II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1005%E3%80%81K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">2.7.</span> <span class="toc-text">1005、K次取反后最大化数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134%E3%80%81%E5%8A%A0%E6%B2%B9%E7%AB%99%EF%BC%88-%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">134、加油站（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135%E3%80%81%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88-%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">135、分发糖果（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#860%E3%80%81%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number">2.10.</span> <span class="toc-text">860、柠檬水找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#406%E3%80%81%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%EF%BC%88-%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">406、根据身高重建队列（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#452%E3%80%81%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">2.12.</span> <span class="toc-text">452、用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#435%E3%80%81%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">2.13.</span> <span class="toc-text">435、无重叠区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763%E3%80%81%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%EF%BC%88-%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">763、划分字母区间（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88-%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">56、合并区间（*）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%8D%E7%9B%98"><span class="toc-number">2.16.</span> <span class="toc-text">区间问题的复盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="toc-number">2.17.</span> <span class="toc-text">57、插入区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#738%E3%80%81%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">2.18.</span> <span class="toc-text">738、单调递增的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#968%E3%80%81%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.19.</span> <span class="toc-text">968、监控二叉树(*)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">贪心总结</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/08/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈希表"/></a><div class="content"><a class="title" href="/2024/03/08/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a><time datetime="2024-03-08T09:25:40.000Z" title="Created 2024-03-08 17:25:40">2024-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/08/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" title="常见设计模式总结"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见设计模式总结"/></a><div class="content"><a class="title" href="/2024/03/08/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" title="常见设计模式总结">常见设计模式总结</a><time datetime="2024-03-08T02:05:59.000Z" title="Created 2024-03-08 10:05:59">2024-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/07/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="HashMap底层源码分析"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072003833.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HashMap底层源码分析"/></a><div class="content"><a class="title" href="/2024/03/07/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="HashMap底层源码分析">HashMap底层源码分析</a><time datetime="2024-03-07T12:03:18.000Z" title="Created 2024-03-07 20:03:18">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="链表相关知识"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051513674.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表相关知识"/></a><div class="content"><a class="title" href="/2024/03/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="链表相关知识">链表相关知识</a><time datetime="2024-03-05T07:12:53.000Z" title="Created 2024-03-05 15:12:53">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/05/LinkedList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="LinkedList底层源码分析"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403051438291.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LinkedList底层源码分析"/></a><div class="content"><a class="title" href="/2024/03/05/LinkedList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="LinkedList底层源码分析">LinkedList底层源码分析</a><time datetime="2024-03-05T06:36:39.000Z" title="Created 2024-03-05 14:36:39">2024-03-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Clay_Guo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试准备2024.md | Clay_Guo的博客</title><meta name="keywords" content="mytag"><meta name="author" content="Clay_Guo"><meta name="copyright" content="Clay_Guo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="自我介绍面试官您好，我叫xxx，目前是南京邮电大学计算机学院研二的学生，很荣幸能够参加美团的暑期实习面试。在课余时间主要学习了Java、Python以及一些框架知识。 我之前有过一段在博世软件中心实习的实习的经历，实习的项目主要是xxx，在里面我主要负责的工作是：单点登录、权限管理、数据可视化工作。 除此之外，我在去年8月份参加了中国软件杯大学生软件设计大赛，参加的组别是智能简历解析系统，在其中我">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备2024.md">
<meta property="og:url" content="https://guoxiansen.github.io/2023/03/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%872024/index.html">
<meta property="og:site_name" content="Clay_Guo的博客">
<meta property="og:description" content="自我介绍面试官您好，我叫xxx，目前是南京邮电大学计算机学院研二的学生，很荣幸能够参加美团的暑期实习面试。在课余时间主要学习了Java、Python以及一些框架知识。 我之前有过一段在博世软件中心实习的实习的经历，实习的项目主要是xxx，在里面我主要负责的工作是：单点登录、权限管理、数据可视化工作。 除此之外，我在去年8月份参加了中国软件杯大学生软件设计大赛，参加的组别是智能简历解析系统，在其中我">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-03-22T13:22:17.000Z">
<meta property="article:modified_time" content="2024-04-04T08:46:26.399Z">
<meta property="article:author" content="Clay_Guo">
<meta property="article:tag" content="mytag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://guoxiansen.github.io/2023/03/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%872024/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-04-04 16:46:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Clay_Guo的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">47</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Clay_Guo的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试准备2024.md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-22T13:22:17.000Z" title="Created 2023-03-22 21:22:17">2023-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-04-04T08:46:26.399Z" title="Updated 2024-04-04 16:46:26">2024-04-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好，我叫xxx，目前是南京邮电大学计算机学院研二的学生，很荣幸能够参加美团的暑期实习面试。在课余时间主要学习了Java、Python以及一些框架知识。</p>
<p>我之前有过一段在博世软件中心实习的实习的经历，实习的项目主要是xxx，在里面我主要负责的工作是：单点登录、权限管理、数据可视化工作。</p>
<p>除此之外，我在去年8月份参加了中国软件杯大学生软件设计大赛，参加的组别是智能简历解析系统，在其中我主要做的工作是：系统的开发工作，如简历上传，最终我们团队获得了国赛的二等奖。</p>
<p>平时自己也会写写自己博客，之前知乎上分享了一篇基于<code>Picgo</code>+<code>gitee</code>+<code>Typora</code>搭建个人笔记系统获得了300多点赞；以及买云服务器来搞一些小的项目练手。如果能够有幸通过面试的话，我可以实习的时间为为4到6个月。</p>
<h1 id="个人技能部分"><a href="#个人技能部分" class="headerlink" title="个人技能部分"></a>个人技能部分</h1><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403271751276.png" alt="image-20240327175144599"></p>
<p>集合框架</p>
<ul>
<li>Collection 单列集合<ul>
<li>List 有序，可重复<ul>
<li>vector 数组结构，线程安全，性能相对较低</li>
<li><strong>ArrayList</strong> 数组结构，非线程安全</li>
<li><strong>LinkedList</strong> 链表结构，非线程安全，底层使用的是双向链表</li>
</ul>
</li>
<li>Set 无序，唯一<ul>
<li>HashSet  哈希表结构<ul>
<li>LinkedHashSet  哈希表和链表结构</li>
</ul>
</li>
<li>TreeSet 底层使用红黑树结构</li>
</ul>
</li>
</ul>
</li>
<li>Map 双列集合<ul>
<li>HashTable 哈希表结构，线程安全  Properties</li>
<li><strong>HashMap</strong> 哈希表结构，非线程安全 LinkedHashMap 哈希表+链表结构</li>
<li><strong>ConcurrentHashMap</strong> 哈希表结构，线程安全</li>
<li>TreeMap 红黑树的结构</li>
</ul>
</li>
</ul>
<h3 id="ArrayList底层实现原理"><a href="#ArrayList底层实现原理" class="headerlink" title="ArrayList底层实现原理"></a>ArrayList底层实现原理</h3><ul>
<li>ArrayList底层是使用动态数组实现的</li>
<li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>ArrayList在进行扩容的时候是原来的1.5倍，每次扩容都需要拷贝数组</li>
<li>ArrayList在添加数据的时候<ul>
<li>确保数组已使用的长度size+1之后能够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1大于当前数组的长度，则调用grow方法进行扩容，扩容为原来的1.5倍</li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>根据源码，这个只是声明和实例了一个<code>ArrayList</code>，指定了容量为10的数组，未进行扩容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403272000717.png" alt="image-20240327200006545"></p>
<h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h3><p>在使用空参构造进行初始化的时候，会创建了一个长度为0的数组，并且有一个变量<code>size</code>，代表当前数组的长度和下一个元素的位置。</p>
<p>在插入第一个元素的时候，系统会创建一个长度为10的数组，</p>
<p><strong>扩容情况1：</strong>当数组存满的时候，会创建一个新数组长度是原来的1.5倍，然后再把所有的元素拷贝到新数组中；如果继续添加元素长度不够了，那么就会按照同样的方式继续扩容1.5倍</p>
<p><strong>扩容情况2：</strong>当使用<code>addAll()</code>方法进行扩容的时候，扩容1.5倍数组长度不够用的情况下，则扩容会以实际元素长度大小为准。</p>
<h3 id="ArrayList和LinkedList的区别是什么？"><a href="#ArrayList和LinkedList的区别是什么？" class="headerlink" title="ArrayList和LinkedList的区别是什么？"></a>ArrayList和LinkedList的区别是什么？</h3><ul>
<li><p>底层数据结构</p>
<ul>
<li><p>ArrayList底层是<strong>动态数组</strong>的数据结构实现，扩容时需要进行数组的拷贝</p>
</li>
<li><p>LinkedList是<strong>双向链表</strong>的数据结构实现</p>
</li>
</ul>
</li>
<li><p>效率</p>
<ul>
<li>ArrayList按照下标查询的时间复杂度为O(1)，【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</li>
<li>查找（未知索引）：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</li>
<li>新增和删除</li>
</ul>
</li>
<li><p>空间占用</p>
<ul>
<li>ArrayList底层是数组，内存连续，节省内存</li>
<li>LinkedList是双向链表需要存储数据和两个指针，更占用内存</li>
</ul>
</li>
<li><p>线程是否安全</p>
<ul>
<li>这两个都不是线程安全的</li>
<li>如果需要保证线程安全，有两种方案：<ul>
<li>在方法内使用，局部变量是线程安全的</li>
<li>使用线程安全的ArrayList和LinkedList</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404020956463.png" alt="image-20240327201009105"></p>
<h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3><p><code>HashMap</code>底层实现是数组+链表+红黑树</p>
<p>使用空参构造的时候，是将<code>loadFactor</code>初始化为0.75</p>
<p>put操作：</p>
<p>如果当前位置没有值，直接在数据中添加键值对即Node对象</p>
<p>如果数组长度超过16 * 0.75=12的时候，进行扩容，扩容到原来的2倍</p>
<p>如果当前位置有值：</p>
<ul>
<li>key值一致：进行覆盖更新</li>
<li>key值不一致：则在其后以链表的形式进行追加，如果链表长度达到8，则会调用<code>treeifyBin()</code>方法，此方法会根据HashMap数组长度来判断是否需要转换为红黑树，只有当数组长度大于等于64的时候才会进行转换红黑树的操作，以减少搜索时间。否则只会执行resize()方法对数组进行扩容。</li>
</ul>
<h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032055867.png" alt="image-20240324155529607"></p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>当一个程序被运行，从磁盘加载这个程序的代码到内存中，这个时候就开启了一个进程。分为两种：</p>
<ul>
<li>多实例进程<ul>
<li>可以打开多个的</li>
</ul>
</li>
<li>单实例进程<ul>
<li>微信等只能打开一份的</li>
</ul>
</li>
</ul>
<p>二者对比：</p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程可以执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</li>
</ul>
<h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>在多核CPU下：</p>
<ul>
<li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li>
<li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li>
</ul>
<h3 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h3><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>线程池创建线程</li>
</ul>
<h3 id="线程池相关面试题"><a href="#线程池相关面试题" class="headerlink" title="线程池相关面试题"></a>线程池相关面试题</h3><ul>
<li>线程池核心参数？</li>
<li>如何确定核心线程数量</li>
<li>如何确定线程池大小？<ul>
<li>CPU密集型：将线程数设置为<code>N+1</code>。这里的N是机器的CPU核心数，多加1是因为可以防止某个线程发生缺页中断，或者其他原因导致任务暂停带来的影响。</li>
<li>IO密集型：将线程数设置为<code>2N</code>，这样的设置可以在线程进行I/O操作的时候，让出CPU执行权给其他线程使用，提高使用效率。</li>
</ul>
</li>
</ul>
<h3 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h3><ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
<h3 id="实现Runnable接口和Callable接口有什么区别？"><a href="#实现Runnable接口和Callable接口有什么区别？" class="headerlink" title="实现Runnable接口和Callable接口有什么区别？"></a>实现Runnable接口和Callable接口有什么区别？</h3><ul>
<li>Runnable无法获取线程执行之后的结果</li>
<li>Callable接口的call方法有返回值，是个泛型，和Future、FutureTask配合使用可以来获取异步执行的结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ul>
<h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><p>start()：用来启动线程，通过该线程调用run方法执行run方法中所执行的逻辑代码。start方法只能调用一次</p>
<p>run()：封装了要被线程执行的代码，可以被调用多次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404011959679.png" alt="image-20240328135617956"></p>
<h3 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a>线程包括哪些状态，状态之间是如何变化的？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404011959888.png" alt="image-20240328135735537"></p>
<ul>
<li>创建线程对象进入新建状态</li>
<li>线程获得CPU执行权进入运行状态</li>
<li>如果没有获得CPU执行权限：<ul>
<li>如果没有获取锁，进入阻塞状态</li>
<li>如果线程调用wait()方法，进入等待状态</li>
<li>超时等待状态</li>
</ul>
</li>
<li>线程执行完毕进入死亡状态</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404031709129.png" alt="image-20240328150037270"></p>
<h3 id="新建T1、T2、T3三个线程，如何保证他们按顺序执行？"><a href="#新建T1、T2、T3三个线程，如何保证他们按顺序执行？" class="headerlink" title="新建T1、T2、T3三个线程，如何保证他们按顺序执行？"></a>新建T1、T2、T3三个线程，如何保证他们按顺序执行？</h3><p>join()方法</p>
<h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><ul>
<li>notifyAll()：唤醒所有wait的线程</li>
<li>notify()：只随机唤醒一个wait线程</li>
</ul>
<h3 id="wait-和sleep-方法有什么不同？"><a href="#wait-和sleep-方法有什么不同？" class="headerlink" title="wait()和sleep()方法有什么不同？"></a>wait()和sleep()方法有什么不同？</h3><p><strong>共同点：</strong>效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态。</p>
<p><strong>不同点：</strong></p>
<ul>
<li>方法的归属不同<ul>
<li>sleep()是Thread的静态方法</li>
<li>而wait()、wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等待下雨。</li>
<li>他们都可以被打断唤醒</li>
</ul>
</li>
<li>锁特性不同（重点）<ul>
<li>wait方法的调用必须先获取wait对象的锁【配合synchronize使用】，而sleep则无限制</li>
<li>wait方法执行后会释放对象锁，允许其他线程获得该对象锁（我放弃CPU，但是你们还可以用）</li>
<li>sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃CPU，你们也不能用）</li>
</ul>
</li>
</ul>
<h3 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a>如何停止一个正在运行的线程</h3><p>有三种方式停止线程</p>
<ul>
<li>使用退出标志，volatile boolean flag = false;</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li>调用interrupt方法中断线程<ul>
<li>打断阻塞的线程（sleep、wait、join），线程会抛出<code>InterruptedException</code></li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<h3 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404031713255.png" alt="image-20240325161658745"></p>
<p>多个窗口卖票的案例，多个线程模拟多个窗口</p>
<p>synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其他线程再想获取这个对象锁时就会阻塞。</p>
<p>底层是monitor，其结构中包括下面三个部分：</p>
<ul>
<li><strong>WaitSet</strong> 关联的是等待的线程，即调用wait()方法的线程，处于waiting状态的线程</li>
<li><strong>EntryList</strong> 关联的是处于阻塞状态的线程，并且只能关联一个线程；</li>
<li><strong>Owner</strong> 存储当前获取锁的线程，只有一个线程能获取</li>
</ul>
<p>谁抢到了Owner哪个线程就拿到了锁</p>
<p>javap -v xx.class 查看class字节码文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404031710029.png" alt="image-20240328172239477"></p>
<p>Monitor被翻译为监视器，是由jvm提供，C++实现的</p>
<h3 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h3><ul>
<li><p>语法层面</p>
<ul>
<li>synchronized是<strong>关键字</strong>，源码在JVM中，用C++实现</li>
<li>ReentrantLock是实现Lock接口的类，源码由JDK提供，用java语言实现</li>
<li>使用synchronized时，退出同步代码块会自动释放锁，而使用Lock时，需要手动调用unlock方法释放锁。</li>
</ul>
</li>
<li><p>功能层面</p>
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量</li>
<li>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWriteLock</li>
</ul>
</li>
<li><p>性能层面</p>
<ul>
<li>没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能也还不错</li>
<li>在竞争激烈时，Lock的实现通常会有更好的性能</li>
</ul>
</li>
<li><p>二者都是可重入锁</p>
</li>
<li><p>synchronized在使用时，退出同步代码块锁就会自动释放，而使用Lock时，需要手动调用unlock方法释放锁</p>
</li>
<li><p>synchronized依赖于jvm，而reentrantLock依赖于API</p>
</li>
<li><p>reentrantLock比synchronized增加了一些高级功能</p>
<ul>
<li>等待可中断</li>
<li>可实现公平锁</li>
<li>可实现选择性通知<strong>（锁可以绑定多个条件）</strong></li>
</ul>
</li>
</ul>
<h3 id="ReentrantLock底层原理是什么？"><a href="#ReentrantLock底层原理是什么？" class="headerlink" title="ReentrantLock底层原理是什么？"></a>ReentrantLock底层原理是什么？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404031120503.png" alt="image-20240402142317954"></p>
<ul>
<li>可重入锁，这一点跟synchronized一致</li>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置超时时间</li>
</ul>
<p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者实现是类似的</p>
<h3 id="Monitor属于重量级锁，你了解锁升级吗？"><a href="#Monitor属于重量级锁，你了解锁升级吗？" class="headerlink" title="Monitor属于重量级锁，你了解锁升级吗？"></a>Monitor属于重量级锁，你了解锁升级吗？</h3><p>Monitor实现的锁属于<strong>重量级锁</strong>，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
<p>jdk1.6之后引入了两种新型锁机制：<strong>偏向锁</strong>和<strong>轻量级锁</strong>，他们的引入是为了解决在没有多线程竞争或者基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032013175.png" alt="image-20240328173100002"></p>
<p>Java中的synchronized有三种： </p>
<ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032015343.png" alt="image-20240328173900311"></p>
<h3 id="聊一聊concurrentHashMap"><a href="#聊一聊concurrentHashMap" class="headerlink" title="聊一聊concurrentHashMap"></a>聊一聊concurrentHashMap</h3><p>底层数据结构：</p>
<ul>
<li>jdk1.7采用分段的数组+链表实现</li>
<li>jdk1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑树</li>
</ul>
<p>加锁的方式：</p>
<ul>
<li>jdk1.7采用Segment分段锁，锁定的范围比较大，底层使用的是ReentrantLock</li>
<li>jdk1.8采用CAS添加新节点，采用synchronized锁定链表或红黑树的首节点，相较于Segment分段锁粒度更细，性能更好</li>
</ul>
<h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><ul>
<li>JMM是java内存模型，定义了共享内存中多线程程序的读写操作的行为规范， 通过这些规则来规范对内存的读写操作从而保证指令的正确性。</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域 （<strong>工作内存</strong>），一块是所有线程的共享区域（<strong>主内存</strong>）</li>
<li>线程跟线程之间是相互隔离的，线程和线程的交互需要通过主内存来共享数据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012254245.png" alt="image-20240325162411558"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012254371.png" alt="image-20240325162003603"></p>
<p>工作内存中的数据是对线程私有的，线程之间无法互相访问</p>
<p>主内存：多个线程如果想要同步数据的话，只能通过主内存进行同步</p>
<h3 id="CAS你知道吗？"><a href="#CAS你知道吗？" class="headerlink" title="CAS你知道吗？"></a>CAS你知道吗？</h3><p>Compare And Swap，它体现了一种<strong>乐观锁</strong>的思想，在无锁的情况下保证线程操作共享数据的原子性。</p>
<p>JUC（java.util.concurrent）包下有很多使用的地方：AQS框架、AtomicXXX类</p>
<p>操作共享变量的时候使用自旋锁，效率上更高一些</p>
<ul>
<li>因为没有加锁，所以线程不会陷入阻塞，效率较高</li>
<li>如果竞争激烈，重试频繁发生，效率会受影响</li>
</ul>
<h3 id="CAS底层实现"><a href="#CAS底层实现" class="headerlink" title="CAS底层实现"></a>CAS底层实现</h3><p>CAS底层依赖于一个<strong>Unsafe</strong>类来直接调用操作系统底层的CAS指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012300145.png" alt="image-20240325163559951"></p>
<p>ReentrantLock中有一段CAS代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404012300635.png" alt="image-20240325163848663"></p>
<h3 id="CAS存在什么问题"><a href="#CAS存在什么问题" class="headerlink" title="CAS存在什么问题?"></a>CAS存在什么问题?</h3><ul>
<li>ABA问题<ul>
<li>一个变量V初始的时候值为A，并且准备赋值的时候检查其值仍然为A，那么就能说明这中间的值没有被修改过了吗？</li>
<li>可能是先被修改为B然后再修改为A，这个问题就被叫做ABA问题</li>
<li>解决思路：在变量前面追加上版本号或者时间戳</li>
</ul>
</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h3 id="CAS算法存在哪些问题？"><a href="#CAS算法存在哪些问题？" class="headerlink" title="CAS算法存在哪些问题？"></a>CAS算法存在哪些问题？</h3><ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul>
<li><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。<strong>【重试/自旋】</strong></p>
<ul>
<li>自旋锁：通过循环不断地尝试获取锁，直到成功为止<ul>
<li>锁的保持时间短的情况；</li>
<li>并发冲突较少的情况；</li>
<li>获取锁的操作是不可阻塞的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>synchronized是基于悲观锁的思想，最悲观的估计，需要防止其他线程来修改共享变量，上锁之后其他的线程都无法进行修改直到释放锁。</p>
</li>
</ul>
<p>高并发下，乐观锁相较于悲观锁来说，不存在锁竞争导致的线程阻塞问题，也不会有死锁的问题，在性能上也会更胜一筹。</p>
<p>悲观锁适合用于写较多的情况下，读较少</p>
<p>乐观锁适合用于写较少的情况下，读较多</p>
<h3 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h3><ul>
<li>版本号机制</li>
<li>CAS算法</li>
</ul>
<h3 id="谈谈你对Volatile关键字的理解"><a href="#谈谈你对Volatile关键字的理解" class="headerlink" title="谈谈你对Volatile关键字的理解"></a>谈谈你对Volatile关键字的理解</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403251701648.png" alt="image-20240325170121414"></p>
<ul>
<li>保证线程之间的可见性</li>
<li>禁止进行指令重排序</li>
</ul>
<p>用<code>volatile</code>修饰共享变量，能够防止编译器等优化发生，让一个线程对<strong>共享变量的修改对另一个线程可见</strong></p>
<p>JVM虚拟机中有一个JIT（即使编译器）给代码做了优化</p>
<p>解决方案一：</p>
<p>解决方案二：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032056256.png" alt="image-20240325165143251"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032056807.png" alt="image-20240325170204826"></p>
<p>volatile使用技巧</p>
<ul>
<li>写变量让volatile修饰的变量在代码的最后位置</li>
<li>读变量让volatile修饰的变量在代码最开始的位置</li>
</ul>
<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><ul>
<li>抽象队列同步器，是一种锁机制，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032046656.png" alt="image-20240402141252399"></p>
<p><strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer，抽象队列同步器。他是构建锁或者其他同步组件的基础框架。</p>
<p>AQS常见的实现类</p>
<ul>
<li>ReentrantLock 阻塞式锁</li>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时锁</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403251706919.png" alt="image-20240325170559357"></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch允许count个线程阻塞在一个地方，直到所有线程的任务全都执行完毕。</p>
<p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制在对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p>
<p><strong>原理：</strong></p>
<p>CountDownLatch是共享锁的一种实现，它默认构造AQS的state值为count。</p>
<p>闭锁/倒计时锁同来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<ul>
<li><p>在实际开发中如果想要计算多个线程的运行总时间，就可以使用CountDownLatch进行计算</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutorService es = Executors.newFixedThreadPool(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">300</span>);</span><br><span class="line">    Runnable task = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多线程实际开发中的实际场景（数据汇总）"><a href="#多线程实际开发中的实际场景（数据汇总）" class="headerlink" title="多线程实际开发中的实际场景（数据汇总）"></a>多线程实际开发中的实际场景（数据汇总）</h3><h3 id="谈谈对ThreadLocal的理解"><a href="#谈谈对ThreadLocal的理解" class="headerlink" title="谈谈对ThreadLocal的理解"></a>谈谈对ThreadLocal的理解</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032048814.png" alt="image-20240402125351828"></p>
<p>线程内部的存储类，让多个线程只操作自己内部的值，实现了线程的隔离</p>
<ul>
<li><p>ThreadLocal可以实现对【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免竞争引发的线程安全问题</p>
</li>
<li><p>ThreadLocal同时实现了线程内的资源共享</p>
</li>
<li><p>每个线程内都有一个ThreadLocalMap类型的成员变量，用来存储资源对象</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032049705.png" alt="image-20240402125034874"></p>
<p>强引用不管什么情况都不会被垃圾回收</p>
<p>弱引用一旦进行垃圾回收就会被回收</p>
<p>Entry对象继承自WeakReference，其中key为使用弱引用的ThreadLocal对象，value为线程变量的副本</p>
<p>使用remove清除对象</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021733730.png" alt="image-20240323220734608"></p>
<h3 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021733087.png" alt="image-20240323220809364"></p>
<p>程序计数器是线程私有的，每个线程一份，内部保存字节码的行号，用于记录正在执行的字节码指令的地址。</p>
<h3 id="你能给我详细介绍Java的堆吗？"><a href="#你能给我详细介绍Java的堆吗？" class="headerlink" title="你能给我详细介绍Java的堆吗？"></a>你能给我详细介绍Java的堆吗？</h3><p>Java堆是线程共享的区域：主要用来保存<strong>对象实例</strong>，<strong>数组</strong>等，当堆中没有内存空间可以分配给实例，也无法再扩展的时候，则抛出<code>OutOfMemoryError</code>异常（<strong>OOM</strong>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021733188.png" alt="image-20240323221848963"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021733827.png" alt="image-20240323221923971"></p>
<p>S0和S1被称为幸存者区Survivor，一个对象来了会到Eden区，假如这个对象在垃圾回收之后还能存活，就会被复制到S0或者S1，假如移动一定次数之后，还能够存活，就会被移动到老年代区域。</p>
<p><strong>老年代</strong>：主要保存的是声明周期长的对象，一般是一些老的对象。</p>
<p><strong>回答</strong></p>
<p>Java堆是线程共享的区域：主要用来保存对象实例，数组等，内存不够则抛出OOM异常</p>
<p>组成包括：年轻代和老年代，其中年轻代又分为Eden和两个大小严格相同的Survivor区，老年代主要保存生命周期长的对象，一般是一些老的对象。</p>
<p>JDK7和JDK8的区别：</p>
<ul>
<li>Java7中有一个永久代，存储类信息、静态变量、常量、编译后的代码；</li>
<li>Java8中移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出。</li>
</ul>
<h3 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈?"></a>什么是虚拟机栈?</h3><ul>
<li>每个线程运行时所需要的内存，被称为虚拟机栈，先进后出，栈内存也是线程安全的</li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前正在执行的那个方法</li>
</ul>
<h4 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h4><blockquote>
<p>垃圾回收主要指的是<strong>堆内存</strong>，当栈帧弹栈以后，内存就会释放</p>
</blockquote>
<h4 id="栈内存分配的越大越好吗？"><a href="#栈内存分配的越大越好吗？" class="headerlink" title="栈内存分配的越大越好吗？"></a>栈内存分配的越大越好吗？</h4><blockquote>
<p>未必，默认的栈内存通常为<strong>1024k</strong></p>
<p>栈帧过大会导致线程数变少，例如机器总内存为512M，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
</blockquote>
<h4 id="方法内的局部变量是否安全？"><a href="#方法内的局部变量是否安全？" class="headerlink" title="方法内的局部变量是否安全？"></a>方法内的局部变量是否安全？</h4><blockquote>
<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041551133.png" alt="image-20230506095306061"></p>
</blockquote>
<h4 id="栈内存溢出情况"><a href="#栈内存溢出情况" class="headerlink" title="栈内存溢出情况"></a>栈内存溢出情况</h4><blockquote>
<ul>
<li>栈帧过多导致栈溢出，典型问题：递归调用</li>
<li>栈帧过大导致栈内存溢出，</li>
</ul>
</blockquote>
<h4 id="栈堆的区别是什么？"><a href="#栈堆的区别是什么？" class="headerlink" title="栈堆的区别是什么？"></a>栈堆的区别是什么？</h4><blockquote>
<ul>
<li>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会。</li>
<li>栈内存是线程私有的，而堆内存是线程共有的。</li>
<li>两者异常错误不同，但如果堆内存或者栈内存不足都会抛出异常<ul>
<li>栈空间不足：<code>java.lang.StackOverFlowError</code></li>
<li>堆空间不足：<code>java.lang.OutOfMemoryError</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="能不能解释一下方法区"><a href="#能不能解释一下方法区" class="headerlink" title="能不能解释一下方法区"></a>能不能解释一下方法区</h3><ul>
<li>方法区是各个线程共享的内存区域</li>
<li>主要存储<strong>类的信息</strong>、<strong>运行时常量池</strong></li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError:Metaspace</code></li>
</ul>
<p>jdk8以前，方法区是存在堆内存中的永久代中的；jdk8以后，方法区是存在元空间中的</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240942284.png" alt="image-20240324094253631"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240946411.png" alt="image-20240324094324633"></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>常量池：可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
</ul>
<h3 id="你听过直接内存吗？"><a href="#你听过直接内存吗？" class="headerlink" title="你听过直接内存吗？"></a>你听过直接内存吗？</h3><p>直接内存：</p>
<ul>
<li>并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存【即操作系统内存】</li>
<li>常见于<strong>NIO</strong>操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240952904.png" alt="image-20240324095210802"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240954132.png" alt="image-20240324095302031"></p>
<h3 id="什么是类加载器，类加载器有哪些？"><a href="#什么是类加载器，类加载器有哪些？" class="headerlink" title="什么是类加载器，类加载器有哪些？"></a>什么是类加载器，类加载器有哪些？</h3><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让java程序能够运行起来</p>
<h4 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h4><ul>
<li>启动类加载器：主要加载<code>JAVA_HOME/jre/lib</code>目录下的库</li>
<li>扩展类加载器：主要加载<code>JAVA_HOME/jre/lib/ext</code>目录下的类</li>
<li>应用类加载器：用于加载<code>classPath</code>下的类</li>
<li>自定义加载器：自定义继承<code>ClassLoader</code>，实现自定义类加载规则</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032051568.png" alt="image-20240324095638560"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240954403.png" alt="image-20240324095421056"></p>
<h4 id="什么是双亲委派模型？（-）"><a href="#什么是双亲委派模型？（-）" class="headerlink" title="什么是双亲委派模型？（*）"></a>什么是双亲委派模型？（*）</h4><p>加载某一个类，先委托上一级的类加载器进行加载，如果上级类加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。</p>
<p>如果子类加载器也无法加载这个类，那么会抛出<code>ClassNotFoundException</code>异常。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021839629.png" alt="image-20240324100312737"></p>
<p>例如，我们自定义的Student类，加载的时候先找<code>AppClassLoader</code>，发现有上级，则继续往上找<code>ExtClassLoader</code>，还有上级继续往上委托找，然后发现里面没有<code>lib</code>和<code>ext</code>里面没有，然后由<code>AppClassLoader</code>加载器进行加载</p>
<h4 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h4><p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</p>
<p>（2）为了安全，保证类库API不会被修改</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021839765.png" alt="image-20240324113301135"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021839043.png" alt="image-20240324100535187"></p>
<h3 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h3><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这七个阶段。其中<em>验证、准备和解析</em>这三部分统称为<strong>连接</strong>。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li>通过类的全名，获取类的二进制数据流</li>
<li>解析类的二进制数数据流为方法区内的数据结构（JAVA类模型）</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证<ul>
<li> Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查他们是否存在</li>
</ul>
</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li>
<li>static变量是final的基本类型，以及<strong>字符串常量</strong>，值已确定，赋值在准备阶段完成</li>
<li>static变量是final的引用类型，那么复制也会在初始化阶段完成</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241144389.png" alt="image-20240324114451829"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>把类的符号引用转换为直接引用</p>
<p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>对静态变量、静态代码块执行初始化操作</strong></p>
<ul>
<li>如果说初始化一个类的时候，其父类尚未初始化，则优先初始化其父类</li>
<li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行</li>
</ul>
<blockquote>
<p>静态代码块通过static关键字进行修饰，随着类加载而加载，并且自动触发，只执行一次。</p>
<p>使用场景：在类加载的时候需要做一些数据初始化的时候使用。例如Redis的Java客户端，使用静态初始化配置一些连接池的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// 配置连接池</span></span><br><span class="line">  JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">  poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">  poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">  poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">  poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建连接池对象</span></span><br><span class="line">  jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;1.94.65.33&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>JVM开始从入口方法开始执行用户的程序代码</p>
<ul>
<li>调用静态类成员信息（比如：静态字段、静态方法）</li>
<li>使用new关键字为其创建对象实例</li>
</ul>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当用户程序代码执行完毕后，JVM便开始销毁创建的Class文件</p>
<h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><ul>
<li>加载：查找和导入class文件</li>
<li>链接<ul>
<li>验证：保证加载类的准确性</li>
<li>准备：为静态变量分配内存并设置类变量初始值</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li>初始化：对类的静态变量、静态代码块进行初始化操作</li>
<li>使用：JVM开始从入口方法执行用户的代码</li>
<li>卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class文件</li>
</ul>
<h3 id="对象什么时候可以被垃圾回收器回收（-）"><a href="#对象什么时候可以被垃圾回收器回收（-）" class="headerlink" title="对象什么时候可以被垃圾回收器回收（*）"></a>对象什么时候可以被垃圾回收器回收（*）</h3><p>垃圾回收主要是<strong>回收堆中的对象</strong>，堆是一个共享的区域，我们创建的对象或者数组都存在这个区域</p>
<p>如果一个对象或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能被垃圾回收器回收。</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是<strong>引用计数法</strong>，第二个是<strong>可达性分析算法</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241159878.png" alt="image-20240324115942944"></p>
<h4 id="引用记数法"><a href="#引用记数法" class="headerlink" title="引用记数法"></a>引用记数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可以被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String demo = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当对象间出现了<strong>循环引用</strong>的话，则引用计数法就会失效</p>
<p>循环引用会导致内存泄漏</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241207672.png" alt="image-20240324120659365"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241208634.png" alt="image-20240324120809861"></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>现在的虚拟机采用的都是通过可达性分析算法来确定那些内容是垃圾</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241212441.png" alt="image-20240324121227564"></p>
<ul>
<li>Java虚拟机中垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着<strong>GC Root</strong>对象为起点的引用链找到该对象，找不到表示可以回收。</li>
</ul>
<h4 id="哪些对象可以作为GC-Root？"><a href="#哪些对象可以作为GC-Root？" class="headerlink" title="哪些对象可以作为GC Root？"></a>哪些对象可以作为GC Root？</h4><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（一般说的Native方法）引用的对象</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241220953.png" alt="image-20240324122012584"></p>
<h3 id="JVM垃圾回收算法有哪些？"><a href="#JVM垃圾回收算法有哪些？" class="headerlink" title="JVM垃圾回收算法有哪些？"></a>JVM垃圾回收算法有哪些？</h3><ul>
<li>标记清除算法</li>
<li>复制算法</li>
<li>标记整理算法</li>
</ul>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>将垃圾回收分为2个阶段，分别是<strong>标记</strong>和<strong>清除</strong></p>
<ol>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ol>
<p>优点：标记和清除速度较快</p>
<p>缺点：碎片化比较严重，内存不连贯，可能导致没有连续的空间来存储较大的对象例如数组。</p>
<p>一般这个算法用的比较少</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241226034.png" alt="image-20240324122601908"></p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>清除之后会把存活的对象进行整理，避免了内存碎片的整理</p>
<p>优缺点同标记清除算法，解决了标记清除算法的碎片化问题，但是多了对象内存移动的步骤，效率有一定的影响。</p>
<p><strong>很多老年代的垃圾回收器会采用这个算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241227402.png" alt="image-20240324122745116"></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法会将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个存储空间，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收；无碎片，内存使用率低。</p>
<p>优点：</p>
<ul>
<li>在垃圾对象多的情况，效率较高</li>
<li>清理后，内存无碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用效率低</li>
</ul>
<p><strong>年轻代的垃圾回收器一般会使用复制算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241231302.png" alt="image-20240324123100637"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241237064.png" alt="image-20240324123744980"></p>
<h3 id="JVM中的分代回收"><a href="#JVM中的分代回收" class="headerlink" title="JVM中的分代回收"></a>JVM中的分代回收</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>在Java8中，堆被分成了两份：新生代和老年代<strong>【1:2】</strong></p>
<p>年轻代被分为三个区域：</p>
<ul>
<li>Eden区，新生的对象都分配到这里</li>
<li>幸存者区survivor（分成from和to）</li>
<li>Eden区，from区，to区<strong>【8:1:1】</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241250088.png" alt="image-20240324125021100"></p>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241252577.png" alt="image-20240324125251344"></p>
<h3 id="Minor-GC、Mixed-GC、Full-GC的区别是什么？"><a href="#Minor-GC、Mixed-GC、Full-GC的区别是什么？" class="headerlink" title="Minor GC、Mixed GC、Full GC的区别是什么？"></a>Minor GC、Mixed GC、Full GC的区别是什么？</h3><p>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</p>
<p>Mixed GC 新生代和老年代部分区域的垃圾回收，G1收集器特有</p>
<p>Full GC：新生代和老年代<strong>完整垃圾回收</strong>，暂停时间长（SWT），应尽力避免</p>
<p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p>
<h3 id="JVM有哪些垃圾回收器（-）"><a href="#JVM有哪些垃圾回收器（-）" class="headerlink" title="JVM有哪些垃圾回收器（*）"></a>JVM有哪些垃圾回收器（*）</h3><p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS（并发）垃圾收集器(Concurrent Mark-Sweep)</li>
<li>G1垃圾收集器</li>
</ul>
<h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial作用于新生代，采用<strong>复制算法</strong></li>
<li>Serial Old作用于老年代，采用<strong>标记整理算法</strong></li>
</ul>
<p>垃圾回收时，只有一个线程在工作，并且Java应用中的所有线程都要暂停（SWT），等待垃圾回收的完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241344400.png" alt="image-20240324134419063"></p>
<h4 id="并行垃圾回收器（很多jdk版本默认的）"><a href="#并行垃圾回收器（很多jdk版本默认的）" class="headerlink" title="并行垃圾回收器（很多jdk版本默认的）"></a>并行垃圾回收器（很多jdk版本默认的）</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，JDK8默认使用此垃圾回收器</p>
<ul>
<li>Parallel New作用于新生代，采用复制算法</li>
<li>Parallel Old作用于老年代，采用标记整理算法</li>
</ul>
<p>垃圾回收时，多个线程在工作，并且Java应用中素有的线程都要暂停（STW），等待垃圾回收的完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241352096.png" alt="image-20240324135225802"></p>
<h4 id="CMS（并发）垃圾收集器"><a href="#CMS（并发）垃圾收集器" class="headerlink" title="CMS（并发）垃圾收集器"></a>CMS（并发）垃圾收集器</h4><p>CMS全称Concurrent Mark-Sweep，是一款并发的、使用标记清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，<strong>停顿时间短</strong>，用户体验就好。</p>
<p><strong>其最大的特点是在进行垃圾回收时，应用仍然能正常进行。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241356865.png" alt="image-20240324135625606"></p>
<p><strong>总结</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241400048.png" alt="image-20240324140003701"></p>
<h3 id="详细聊一下G1垃圾回收器（-）"><a href="#详细聊一下G1垃圾回收器（-）" class="headerlink" title="详细聊一下G1垃圾回收器（*）"></a>详细聊一下G1垃圾回收器（*）</h3><p>G False或者G One垃圾回收器</p>
<ul>
<li>应用在新生代和老年代，在<strong>JDK9之后默认使用G1</strong></li>
<li>划分多个区域，每个区域都可以充当Eden、survivor、old、<strong>humongous</strong>，其中humongous专门为大对象准备</li>
<li>采用复制算法【没有内存碎片】</li>
<li>特别注重响应时间和吞吐量</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），则会触发Full GC</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241403539.png" alt="image-20240324140354230"></p>
<h4 id="Yong-GC（年轻-新生代垃圾回收）"><a href="#Yong-GC（年轻-新生代垃圾回收）" class="headerlink" title="Yong GC（年轻/新生代垃圾回收）"></a>Yong GC（年轻/新生代垃圾回收）</h4><ul>
<li>初始时，所有区域都处于空闲状态</li>
<li>创建了一些对象，挑出一些空闲区域作为Eden区存储这些对象</li>
<li>当Eden区需要垃圾回收时，挑出一个空闲区域作为幸存区，使用可达性分析算法来判断哪些对象可以存活，然后采用复制算法复制存活对象到幸存者区中，需要短暂暂停用户线程 STW，幸存者区是比较少的，所以暂停时间相对来说也比较短</li>
</ul>
<p>G1收集器中Eden占比**5%-6%**左右</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241417895.png" alt="image-20240324141749665"></p>
<ul>
<li>随着时间的流逝，Eden区内存又不足了</li>
<li>将Eden以及之前幸存者中的存活对象采用复制算法，复制到新的幸存者区，其中较老的对象晋升至老年代</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041617787.png" alt="image-20240324142038941"></p>
<h4 id="Yong-GC-并发标记阶段"><a href="#Yong-GC-并发标记阶段" class="headerlink" title="Yong GC+并发标记阶段"></a>Yong GC+并发标记阶段</h4><p>当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程。</p>
<p>重新标记阶段需要STW</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041621536.png" alt="image-20240324142240999"></p>
<h4 id="混合收集阶段"><a href="#混合收集阶段" class="headerlink" title="混合收集阶段"></a>混合收集阶段</h4><ul>
<li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程</li>
<li>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这些是Garbage First名称的由来）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041621349.png" alt="image-20240324143253115"></p>
<p>混合收集阶段，参与复制的有Eden、survivor、old</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041621908.png" alt="image-20240324143505252"></p>
<p>复制完成，内存得到释放。进入下一轮新生代回收、并发标记、混合收集</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041621600.png" alt="image-20240324143517298"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041622348.png" alt="image-20240324143733477"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041604945.png" alt="image-20240324143752040"></p>
<h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次发出垃圾回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">SoftReference softReference = <span class="keyword">new</span> SoftReference(user);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041603098.png" alt="image-20240324144113726"></p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">WeakReference weakReference = <span class="keyword">new</span> WeakReference(user);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041603745.png" alt="image-20240324144640695"></p>
<p>ThreadLocal中，其键是弱引用类型，在垃圾回收的时候会被清理，而值为强引用，不会被回收</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>必须配合队列使用，被引用对象回收时，会将虚引用入队，由<strong>Reference Handler</strong>线程调用虚引用相关方法释放直接内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(user, queue)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041604845.png" alt="image-20240324145033648"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041604684.png" alt="image-20240324145048169"></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403220932792.png" alt="image-20240322093243262"></p>
<h3 id="了解过索引吗（什么是索引？）"><a href="#了解过索引吗（什么是索引？）" class="headerlink" title="了解过索引吗（什么是索引？）"></a>了解过索引吗（什么是索引？）</h3><p>索引是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，也就是B+树，这些结构以引用的形式指向数据，这样就可以在B+树中高效的查找到所需要的数据。</p>
<ul>
<li><p>索引是帮助MySQL高效获取数据的数据结构（有序）</p>
</li>
<li><p>索引提高了数据检索的效率，降低数据库的IO成本（不需要全表扫描）</p>
</li>
<li><p>索引列数据进行排序，降低了数据的排序成本，也降低了CPU的消耗</p>
</li>
</ul>
<h3 id="索引的底层的数据结构了解过吗？"><a href="#索引的底层的数据结构了解过吗？" class="headerlink" title="索引的底层的数据结构了解过吗？"></a>索引的底层的数据结构了解过吗？</h3><p>MySQL5.7版本以后的默认存储引擎<code>InnoDB</code>采用的是B+树的数据结构来存储索引的。</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代码B+树更低，非叶子节点只存储指针，叶子节点存储数据</li>
<li>B+树便于<strong>扫库</strong>和<strong>区间查询</strong></li>
</ul>
<p>索引的底层使用的是B+树，B+树是一种在B树上进行优化的数据结构，其中非叶子结点只存放指针和键值，只有在叶子节点上才存放相应的数据</p>
<p>相较于B树而言：</p>
<ul>
<li>磁盘读写代价B+树更低<ul>
<li>B树在查找的过程中查找路径上的节点的数据也会进行加载，所以磁盘的读写代价更大</li>
</ul>
</li>
<li>查询效率B+树更加稳定<ul>
<li>所有的数据全部存储在叶子节点上</li>
</ul>
</li>
<li>B+树便于扫库和区间查询<ul>
<li>所有的叶子节点是通过双向指针链接的，在进行范围查询的时候会非常方便</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403212313470.png" alt="image-20240321231346022"></p>
<h3 id="什么是聚簇索引和非聚簇索引？"><a href="#什么是聚簇索引和非聚簇索引？" class="headerlink" title="什么是聚簇索引和非聚簇索引？"></a>什么是聚簇索引和非聚簇索引？</h3><p>题目中也可能会问什么是聚集索引和二级索引（二级索引就是非聚集索引）</p>
<p><strong>聚簇索引（聚集索引）：</strong>将数据和索引存储在一起，也就是B+树的叶子节点保存了整行数据，必须有，且只有一个。如果没有<code>InnoDB</code>会自动创建一个隐藏主键<code>DB_ROW_ID</code></p>
<p><strong>非聚簇索引（二级索引）：</strong>将索引和数据分开存储，B+树的叶子节点存储的是对应的<strong>主键</strong>，可以有多个。</p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li>
<li>如果表中没有主键，或者没有合适的唯一索引，则<code>innoDB</code>会自动生成一个<code>DB_ROW_ID</code>作为隐藏的聚集索引。</li>
</ul>
<h4 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h4><p>直接问什么是<strong>回表查询</strong>需要再解释一下什么是聚簇索引和非聚簇索引</p>
<p>先通过二级索引找到对应的主键值，再拿着这个主键去聚簇索引中去查询找到整行的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041622235.png" alt="image-20240325134027113"></p>
<h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p>覆盖索引是指查询使用了索引，并且需要返回的列在该索引中已经能够查询到了。例如我们使用主键id进行查询，它会直接走聚集索引，一次索引扫描直接返回全部数据，这样的性能更高。</p>
<p>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发<strong>回表查询</strong>，应该尽量避免使用<code>select *</code>进行查询，尽量在返回的列中都包含添加索引的字段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221005284.png" alt="image-20240322100505967"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403220959679.png" alt="image-20240322095905646"></p>
<h4 id="MySQL超大分页处理"><a href="#MySQL超大分页处理" class="headerlink" title="MySQL超大分页处理"></a>MySQL超大分页处理</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221003322.png" alt="image-20240322100346365"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221003010.png" alt="image-20240322100315540"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_sku t, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000000</span>,<span class="number">10</span>) a</span><br><span class="line"><span class="keyword">where</span> t.id = a.id;</span><br></pre></td></tr></table></figure>



<h3 id="索引的创建原则有哪些？"><a href="#索引的创建原则有哪些？" class="headerlink" title="索引的创建原则有哪些？"></a>索引的创建原则有哪些？</h3><ul>
<li>先陈述自己在实际工作中是如何使用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引（复合/联合索引）</li>
</ul>
<p><strong>1）针对数据量较大，且查询比较频繁的表建立索引。单表超过10万条数据（增加用户体验）</strong></p>
<p><strong>2）针对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</strong></p>
<p>3）尽量选择区分度高的列作为索引，尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度高，使用索引的效率越高。</p>
<p>4）如果是字符串类型的字段，字段的长度较长，可以针对与字段的特点建立前缀索引</p>
<p>5）尽量使用<strong>联合索引（复合索引）</strong>，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p>
<p><strong>6）要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</strong></p>
<p>7）如果索引列不能存储NULL值，请在创建表的时候使用NOT NULL约束他。当优化器知道每列是否包含NULL值的时候，它可以更好地确定那个索引最有效地用于查询。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221015007.png" alt="image-20240322101551460"></p>
<h3 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h3><p>1）违反了最左前缀法则。</p>
<ul>
<li>如果索引了多列，就要遵循最左前缀法则，指的是查询从索引的最左前列开始，并且不跳过索引中的列，匹配最左前缀法则，走索引：</li>
<li>违反了最左前缀法则，索引会失效</li>
<li>如果复合最左法则，但是出现中间跳过某一列，则只有最左索引失效。</li>
</ul>
<p>2）范围查询右边的列，不能使用索引。例如：where name = “小米” and status &gt; 1 and address = “北京”; 这个情况下address索引就无法生效了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403230936620.png" alt="image-20240323093625881"></p>
<p>3）不要在索引列上进行运算操作，索引将会失效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403230937508.png" alt="image-20240323093738631"></p>
<p>4）字符串不加单引号，造成索引失效</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403230938631.png" alt="image-20240323093824349"></p>
<p>5）以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引会消失。</p>
<p>  通常情况下如果需要判断这条sql的索引是否失效可以使用<strong>EXPLAIN</strong>执行计划来进行分析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221027036.png" alt="image-20240322102702759"></p>
<h3 id="谈谈你对sql优化的经验"><a href="#谈谈你对sql优化的经验" class="headerlink" title="谈谈你对sql优化的经验"></a>谈谈你对sql优化的经验</h3><ul>
<li>表的设计优化</li>
<li>索引优化 （参考优化创建原则和索引失效）</li>
<li>SQL语句优化</li>
<li>主从复制、读写分离</li>
<li>分库分表 （后面有专门的章节介绍）</li>
</ul>
<h4 id="表的设计的优化"><a href="#表的设计的优化" class="headerlink" title="表的设计的优化"></a>表的设计的优化</h4><p><strong>参考阿里开发手册嵩山版</strong></p>
<p>比如设置合适的数值（<code>tinyint</code>、<code>int</code>、<code>bigint</code>）根据实际情况进行选择</p>
<p>设置合适的字符串类型（<code>char</code>和<code>varchar</code>）</p>
<h4 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221032603.png" alt="image-20240322103219935"></p>
<h4 id="主从复制、读写分离"><a href="#主从复制、读写分离" class="headerlink" title="主从复制、读写分离"></a>主从复制、读写分离</h4><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221033862.png" alt="image-20240322103355298"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221034937.png" alt="image-20240322103449543"></p>
<h3 id="事务的特性是什么？"><a href="#事务的特性是什么？" class="headerlink" title="事务的特性是什么？"></a>事务的特性是什么？</h3><p><strong>ACID</strong>来自于下面四个单词的首字母</p>
<ul>
<li><strong>原子性Atomicity：</strong>事务中的所有操作要么全部成功要么全部执行失败，事务是一个不可分割的最小执行单元，要么全部完成，要么全部不完成</li>
<li><strong>一致性Consistency：</strong>一致性是事务执行的结果必须使数据库从一个一致性状态转变到另一个一致性状态。即事务执行前后数据库的完整性约束没有被破坏。</li>
<li><strong>隔离性Isolation：</strong>隔离性要求事务的执行不受其他事务的影响，即事务之间应该相互隔离。多个事务并发执行时，每个事务都感觉不到其他事务的存在，互相之间不会产生影响。</li>
<li><strong>持久性Durability：</strong>持久性是指事务一旦成功提交，所有的修改都会永久保存在数据库中，及时数据库发生故障，事务的提交结果也不会丢失。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118639.png" alt="image-20240322104629664"></p>
<ul>
<li>事务特性</li>
<li>隔离级别</li>
<li>MVCC</li>
</ul>
<h3 id="并发事务会带来哪些问题？怎么去解决这些问题？MySQL默认的隔离级别是？"><a href="#并发事务会带来哪些问题？怎么去解决这些问题？MySQL默认的隔离级别是？" class="headerlink" title="并发事务会带来哪些问题？怎么去解决这些问题？MySQL默认的隔离级别是？"></a>并发事务会带来哪些问题？怎么去解决这些问题？MySQL默认的隔离级别是？</h3><p>并发事务的问题：脏读、丢失修改、不可重复度、幻读</p>
<ul>
<li><strong>脏读：</strong>一个事务读取到了另一个事务尚未提交的数据就是脏读。</li>
<li><strong>丢失修改：</strong>有两个事务，第一个事务读取一个数据的时候，第二个事务也访问了这个数据，第一个事务修改这个数据之后，第二个数据也修改了这个数据，那么第一个事务的修改就丢失了。</li>
<li><strong>不可重复读：</strong>有点类似于接口的幂等性问题，一个事务先后读取同一条记录，但是两次读取的数据值不同，被称之为不可重复读。【重点在与第二个事务对数据进行了修改】</li>
<li><strong>幻读：</strong>一个事务查询数据的时候，没有对应的数据行，第二个事务在之后插入了几条数据，然后第一个事务在读取数据的时候，出现了原本根本不存在的数据，好像出现了幻觉【重点在于记录的新增，多次执行DQL语句的时候发现记录增加了】</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221132263.png" alt="image-20240322113245242"></p>
<h3 id="如何解决这些并发事务产生的问题呢？"><a href="#如何解决这些并发事务产生的问题呢？" class="headerlink" title="如何解决这些并发事务产生的问题呢？"></a>如何解决这些并发事务产生的问题呢？</h3><p><strong>解决方案：对事务进行隔离</strong></p>
<p>隔离级别：读已提交、读取未提交、可重复读、串行化</p>
<ul>
<li>读取未提交：允许读取事务尚未提交的数据，属于最低的隔离级别，可能会导致脏读、不可重复读和幻读</li>
<li>读取已提交：允许读取并发事务已经提交的数据，可以<em>阻止脏读</em>，但是幻读和不可能重复度仍然有可能会发生</li>
<li><strong>可重复读（是MySQL默认的隔离级别）：</strong>对同一字段多次读取的结果是一致的，除非数据是被事务自己本身所修改，可以阻止脏读和不可重复读，但是幻读仍然会产生。</li>
<li>串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读和幻读。</li>
</ul>
<p>事务的隔离级别越高，数据越安全，但是性能也越低</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221333985.png" alt="image-20240322133347496"></p>
<h3 id="redo-log和undo-log的区别？（-）"><a href="#redo-log和undo-log的区别？（-）" class="headerlink" title="redo log和undo log的区别？（*）"></a>redo log和undo log的区别？（*）</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118230.png" alt="image-20240322134930345"></p>
<p>日志文件</p>
<p>redo log是重做日志，<strong>记录的是事务提交时数据页的物理修改</strong>，是用来实现事务的<strong>持久性</strong>的。服务宕机时可以用来同步数据。</p>
<p>该日志由两部分组成：<strong>重做日志缓存</strong>（redo log buffer）以及<strong>重做日志文件</strong>（redo log file），前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<ul>
<li>缓冲池<ul>
<li>主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（如果缓冲池中没有数据，则从磁盘加载并缓存），并以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
</ul>
</li>
<li>数据页<ul>
<li>时<code>InnoDB</code>存储引擎磁盘管来的最小单元，每个页的大小默认为16KB。页中存储的是行数据</li>
</ul>
</li>
</ul>
<p>把数据页加载到内存中，在内存中进行操作，这样性能更高。当操作完成之后，会按照一定的频率再把数据同步到磁盘中。</p>
<p>在内存中尚未同步到磁盘中的数据页被称为脏页，只有把脏页同步到磁盘中才叫持久化。</p>
<p>如果服务器宕机了，同步脏页数据到磁盘中失败了，数据会产生丢失，违背了事务的特性持久性</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041622814.png" alt="image-20240323095249511"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041623397.png" alt="image-20240323151701115"></p>
<p>redo log主要可以用来保证事务的<strong>持久性</strong></p>
<p>WAL（write-AHead Logging) 先写日志，如果脏页数据能够正常同步到磁盘中的时候，redo log就没什么用了</p>
<p><strong>undo log</strong></p>
<p>回滚日志，用于记录数据被修改之前的信息，作用包括两个：<strong>提供回滚</strong>和<strong>MVCC</strong>。undo log和redo log记录物理日志不一样，他是逻辑日志。</p>
<ul>
<li>可以认为当delete一条记录时，undo logo中会记录一条对应的insert记录，反之亦然。</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p>undo log可以保证事务的<strong>原子性</strong>和<strong>一致性</strong>。</p>
<h3 id="redo-log和binlog有什么区别？（-）"><a href="#redo-log和binlog有什么区别？（-）" class="headerlink" title="redo log和binlog有什么区别？（*）"></a>redo log和binlog有什么区别？（*）</h3><ul>
<li><p>适用对象不同</p>
<ul>
<li>binlog是MySQL Server层实现的日志，所有的存储引擎都是可以使用的</li>
<li>redo log是InnoDB存储引擎实现的日志，MyISAM无法使用，这也是在崩溃恢复上InnoDB优于MyISAM的原因</li>
</ul>
</li>
<li><p>文件格式不同</p>
<ul>
<li><p>binlog是逻辑日志，记录的是这个语句的原始逻辑，比如给这个id=2的字段c加1操作</p>
</li>
<li><p>redo log是物理日志，记录的是在某个数据页上做了什么修改</p>
</li>
</ul>
</li>
<li><p>写入方式不同：</p>
<ul>
<li><p>binlog是追加写，写满一个文件就会新建一个文件继续写入，不会覆盖以前的日志，保存的是全量的日志信息。</p>
</li>
<li><p>redo log是<strong>循环写</strong>，日志空间大小是固定的，写到最后就会从头开始重新写，保存未被刷入磁盘的脏页日志。</p>
</li>
</ul>
</li>
<li><p>用途：</p>
<ul>
<li><p>binlog用于备份恢复、主从复制，保证MySQL集群架构的数据一致性</p>
</li>
<li><p>redo log用于断电等故障崩溃恢复</p>
</li>
</ul>
</li>
</ul>
<p>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写</p>
<p>binlog三种记录格式：</p>
<ul>
<li>statement</li>
<li>row</li>
<li>mixed</li>
</ul>
<p>redo log保证事务的持久性</p>
<p>undo log保证事务的原子性</p>
<h3 id="事务的隔离性是如何保证的？（-）"><a href="#事务的隔离性是如何保证的？（-）" class="headerlink" title="事务的隔离性是如何保证的？（*）"></a>事务的隔离性是如何保证的？（*）</h3><ul>
<li>锁<ul>
<li>排他锁（如果一个事务获取了一行数据的排他锁，其他事务就不能再获取改行的其他锁）</li>
</ul>
</li>
<li>MVCC<ul>
<li>多版本并发控制</li>
</ul>
</li>
</ul>
<p>MVCC，Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，<strong>使得读写操作没有冲突。</strong></p>
<p>MVCC的具体实现主要是依赖于数据库记录中的<strong>隐藏字段</strong>、<strong>undo log</strong>日志和<strong>readView</strong></p>
<ul>
<li>隐藏字段<ul>
<li><code>DB_TRX_ID</code>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</li>
<li><code>DB_ROW_ID</code>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</li>
</ul>
</li>
<li>undo log<ul>
<li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li>
<li>当insert的时候 ，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅仅在回滚时需要，mvcc版本访问也需要，不会立即删除。</li>
</ul>
</li>
</ul>
<p>undo log版本链</p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的就记录，链表的尾部是最早的旧记录。然后隐藏字段中的<code>DB_ROLL_PTR</code>回滚指针会指向链表的开头。</p>
<ul>
<li>readview<ul>
<li>读视图是<strong>快照读</strong>SQL执行时MVCC提交数据的依据，记录并维护系统当前活跃的事务（未提交的）id</li>
<li>当前读<ul>
<li>当前读是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如select … lock in share mode<strong>（共享锁）</strong>，select … for update、insert、delete<strong>（排他锁）</strong>都是一种当前读。</li>
</ul>
</li>
<li>快照读<ul>
<li>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</li>
<li>Read Commited（读取已提交<code>RC</code>）：每次select都，都生成一个快照读</li>
<li>Repeatable Read（可重复读<code>RR</code>）：开启事务后第一个select语句才是快照读的地方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>readview中包含了四个核心字段</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>m_ids</code></td>
<td align="center">当前活跃的事务ID</td>
</tr>
<tr>
<td align="center"><code>min_trx_id</code></td>
<td align="center">最小活跃事务ID</td>
</tr>
<tr>
<td align="center"><code>max_trx_id</code></td>
<td align="center">预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>
</tr>
<tr>
<td align="center"><code>creator_trx_id</code></td>
<td align="center">ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118857.png" alt="image-20240322153036919"></p>
<h3 id="MySQL的主从同步原理"><a href="#MySQL的主从同步原理" class="headerlink" title="MySQL的主从同步原理"></a>MySQL的主从同步原理</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119144.png" alt="image-20240322153205352"></p>
<p>MySQL主从复制的核心就是二进制日志</p>
<p>二进制日志<code>binlog</code>记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（select、show）语句</p>
<p>复制分成三步：</p>
<ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制文件<code>binlog</code>中</li>
<li>从库读取主库的二进制文件<code>binlog</code>，写入到从库的中继日志replay log</li>
<li>slave重做中继日志中的事件，将改变反映他自己的数据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403221537234.png" alt="image-20240322153706221"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119855.png" alt="image-20240322153755715"></p>
<h3 id="你们项目用过分库分表吗？"><a href="#你们项目用过分库分表吗？" class="headerlink" title="你们项目用过分库分表吗？"></a>你们项目用过分库分表吗？</h3><p>什么情况下需要进行分库分表？</p>
<ol>
<li>前提，项目业务逐渐增多，或者业务发展比较迅速。阿里巴巴规约中<strong>单表行数超过500万条</strong>或者<strong>单表容量超过2G</strong>才推荐进行分库粉笔哦啊</li>
<li>优化已经解决不了性能问题（主从读写分离、查询索引…）</li>
<li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119494.png" alt="image-20240322161010117"></p>
<h4 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h4><p>垂直拆分</p>
<ul>
<li>垂直分库</li>
<li>垂直分表</li>
</ul>
<p>水平拆分</p>
<ul>
<li>水平分库</li>
<li>水平分表</li>
</ul>
<p><strong>垂直分库：</strong>以表为依据，根据业务将不同表拆分到不同库中。（用户、商品、订单）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119775.png" alt="image-20240322163945529"></p>
<p>特点：</p>
<ul>
<li>按业务对数据分级管理、维护、监控和扩展</li>
<li>在高并发下，提高磁盘IO和数据量连接数</li>
</ul>
<p><strong>垂直分表：</strong>以字段为依据，根据字段属性讲不同字段拆分到不同表中</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119609.png" alt="image-20240322163918199"></p>
<p>拆分规则：</p>
<ul>
<li>把不常用的字段单独放在一张表</li>
<li>把text、blob等大字段拆分出来放在附表中</li>
</ul>
<p>特点：</p>
<ul>
<li>冷热数据分离【热数据经常被查询，冷数据不常被查询】</li>
<li>减少IO过度争抢，两表互不影响</li>
</ul>
<p><strong>水平分库：</strong>将一个库的数据拆分到多个库中</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119354.png" alt="image-20240322163850354"></p>
<p>路由规则：</p>
<ul>
<li>根据ID节点取模</li>
<li>按ID也就是范围路由，节点1（1-100万），节点2（100万到200万）</li>
</ul>
<p>特点：</p>
<ul>
<li>解决了单库大数据量，高并发的性能瓶颈问题</li>
<li>提高了系统的稳定性和可用性</li>
</ul>
<p><strong>水平分表：</strong>将一个表的数据拆分到多个表中（可以在同一个库内）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119406.png" alt="image-20240322164347401"></p>
<p>特点：</p>
<ul>
<li>优化单一表数据量过大而产生的性能瓶颈问题</li>
<li>避免IO争抢并减少锁表的几率</li>
</ul>
<p>分库之后的问题：</p>
<ul>
<li>分布式事务一致性问题？</li>
<li>跨节点关联查询</li>
<li>跨节点进行分页、排序函数</li>
<li>主键避重【ID重复问题】</li>
</ul>
<p>添加中间件用于分库分表</p>
<ul>
<li>sharding-sphere</li>
<li>mycat</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119950.png" alt="image-20240322164944822"></p>
<h3 id="MySQL中如何定位慢查询"><a href="#MySQL中如何定位慢查询" class="headerlink" title="MySQL中如何定位慢查询"></a>MySQL中如何定位慢查询</h3><ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
<p>表象：页面加载过慢、接口压测响应时间过长（超过1s）</p>
<h4 id="解决方法1：开源工具"><a href="#解决方法1：开源工具" class="headerlink" title="解决方法1：开源工具"></a>解决方法1：开源工具</h4><ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、<strong>Skywalking</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211710726.png" alt="image-20240321171024619"></p>
<h4 id="解决方法2：MySQL自带的慢日志查询"><a href="#解决方法2：MySQL自带的慢日志查询" class="headerlink" title="解决方法2：MySQL自带的慢日志查询"></a>解决方法2：MySQL自带的慢日志查询</h4><p>需要开启慢日志查询</p>
<p>1、介绍当时产生问题的场景（我们当时的接口测试的时候非常慢，压测的结果大概为5秒钟）</p>
<p>2、我们系统中采用了运维工具Skywalking，可以检测出哪个接口，最终是因为sql问题</p>
<p>3、在MySQL中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行时间超过2秒就会被记录到日志中（<strong>调试阶段</strong>）生产环境中如果开启慢日志查询则会有一定的性能损耗。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403211716727.png" alt="image-20240321171650088"></p>
<h3 id="一条SQL执行的很慢，是如何进行分析的呢？"><a href="#一条SQL执行的很慢，是如何进行分析的呢？" class="headerlink" title="一条SQL执行的很慢，是如何进行分析的呢？"></a>一条SQL执行的很慢，是如何进行分析的呢？</h3><p>使用MySQL的SQL执行计划来分析具体执行慢的原因</p>
<p>可以使用<code>EXPLAIN</code>或者<code>DESC</code>命令进行分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222119539.png" alt="image-20240321172434125"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404021836106.png" alt="image-20240402183602265"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222120046.png" alt="image-20240321172826027"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222120104.png" alt="image-20240321172902356"></p>
<h3 id="怎么看项目里慢查询语句有哪些？"><a href="#怎么看项目里慢查询语句有哪些？" class="headerlink" title="怎么看项目里慢查询语句有哪些？"></a>怎么看项目里慢查询语句有哪些？</h3><ul>
<li>MySQL慢查询日志<ul>
<li>在MySQL的配置我呢间中开启慢查询日志功能，设置合适的阈值，MySQL将会自动记录执行时间，超过阈值的查询语句将会被记录到慢查询日志文件中，可以通过查询慢查询日志找出慢查询语句。</li>
<li>show variables like ‘%slow_query_log%’;</li>
<li>explain + 慢的语句\G</li>
<li><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403151208170.png" alt="image-20240315120810516"></li>
</ul>
</li>
<li>IO</li>
<li>CPU</li>
<li>网络带宽</li>
</ul>
<h3 id="怎么优化慢sql？举例说明"><a href="#怎么优化慢sql？举例说明" class="headerlink" title="怎么优化慢sql？举例说明"></a>怎么优化慢sql？举例说明</h3><ul>
<li>索引优化</li>
<li>查询优化<ul>
<li>优化sql查询语句的写法，尽量避免全表扫描和不必要的数据读取。可以通过添加where条件，合理使用join操作，减少子查询的方式来优化查询，另外避免使用select * 查询所有列</li>
</ul>
</li>
<li>分页查询优化</li>
<li>适当调整<code>innodb_buffer_pool_size</code>、<code>sort_buffer_size</code>等内存参数,避免过度使用临时表和磁盘文件。</li>
<li>使用数据库集群或者读写分离<ul>
<li>对于一些大查询可以从 从库中查询，减轻主库的压力。</li>
</ul>
</li>
</ul>
<h3 id="MySQL索引是怎么实现的，你有了解吗？"><a href="#MySQL索引是怎么实现的，你有了解吗？" class="headerlink" title="MySQL索引是怎么实现的，你有了解吗？"></a>MySQL索引是怎么实现的，你有了解吗？</h3><p>MySQL的索引是通过B+树实现的。</p>
<p>B+树是一种多路平衡搜索树，它具有以下几种特点：</p>
<ul>
<li>平衡性：B+树是一颗平衡树，保持所有叶子结点到根结点的距离是相同的，从而保证的检索的稳定性和高效性</li>
<li>多路性：每个节点都可以拥有多个子节点，这样可以减少树的高度，从而提高检索效率</li>
<li>有序性：B+树所有叶子结点都按照顺序连接起来，可以方便地进行查询</li>
</ul>
<p>MySQL中索引主要分为：</p>
<ul>
<li>聚集索引：在Innodb存储的</li>
</ul>
<h3 id="MySQL的mylsam和innoDB存储引擎有什么区别？怎么选择？"><a href="#MySQL的mylsam和innoDB存储引擎有什么区别？怎么选择？" class="headerlink" title="MySQL的mylsam和innoDB存储引擎有什么区别？怎么选择？"></a>MySQL的mylsam和innoDB存储引擎有什么区别？怎么选择？</h3><p>在MySQL中可以使用<code>show engines;</code>命令查看存储引擎，由于我本人使用的是MySQL8的版本，因此默认的存储引擎是<code>InnoDB</code>，<code>InnoDB</code>有四个特点：</p>
<ul>
<li>支持事务，事务是可以在一系列操作中保证数据的一致性</li>
<li>行级锁，<code>InnoDB</code>使用行级锁，而<code>MyISAM</code>使用表级锁定。行级锁定只锁定需要修改的行，可以提高并发性能，而表级锁定需要锁定整个表，可以导致锁定冲突。</li>
<li>支持外键，<code>InnoDB</code>支持外键，可以确保数据的完整性和一致性，而<code>MyISAM</code>不支持外键。</li>
<li>崩溃异常恢复。</li>
<li>ACID支持：<code>InnoDB</code>遵循ACID（原子性、一致性、隔离性、持久性）的原则，可以确保数据的完整性和一致性，而<code>MyISAM</code>不支持。<ul>
<li><strong>原子性Atomicity：</strong>事务中的所有操作要么全部成功要么全部执行失败，事务是一个不可分割的最小执行单元，要么全部完成，要么全部不完成</li>
<li><strong>一致性Consistency：</strong>一致性是事务执行的结果必须使数据库从一个一致性状态转变到另一个一致性状态。即事务执行前后数据库的完整性约束没有被破坏。</li>
<li><strong>隔离性Isolation：</strong>隔离性要求事务的执行不受其他事务的影响，即事务之间应该相互隔离。多个事务并发执行时，每个事务都感觉不到其他事务的存在，互相之间不会产生影响。</li>
<li><strong>持久性Durability：</strong>持久性是指事务一旦成功提交，所有的修改都会永久保存在数据库胡总，及时数据库发生故障，事务的提交结果也不会丢失。</li>
</ul>
</li>
</ul>
<p>而<code>myISAM</code>的话不支持事务，并且<code>myISAM</code>使用的是表级锁。行级锁可以提高并发性，减少锁冲突的可能性</p>
<p><code>myISAM</code>不支持外键约束</p>
<p>对于崩溃恢复的话，<code>InnoDB</code>也可以给到一个很好的支持，具有很好的可靠性和稳定性，而<code>myISAM</code>对于这方面的支持是比较弱的。</p>
<p>综上所述，选择MyISAM还是InnoDB存储引擎取决于项目的具体需求和场景。如果项目需要支持事务、外键约束，或者有大量的并发写入操作，推荐选择InnoDB存储引擎。如果项目只需要简单的数据存储和查询，并且对事务和并发性要求不高，可以考虑使用MyISAM存储引擎。</p>
<p>MyISAM在处理大量数据的时候比INnoDB更快，但是在处理大量并发的时候INnoDB比MyISAM更快。</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="RabbitMQ消息队列和Redis消息队列有什么区别？项目里应该怎么选型？"><a href="#RabbitMQ消息队列和Redis消息队列有什么区别？项目里应该怎么选型？" class="headerlink" title="RabbitMQ消息队列和Redis消息队列有什么区别？项目里应该怎么选型？"></a>RabbitMQ消息队列和Redis消息队列有什么区别？项目里应该怎么选型？</h3><ul>
<li>数据模型的差异<ul>
<li>RabbitMQ是基于AMQP协议，核心理念是买你想消息的队列，数据存储是以消息为主</li>
<li>Redis则是基于键值对的数据结构存储系统，虽然也可以用List模拟队列，但是更适合用于当做缓存</li>
</ul>
</li>
<li>消息传递方式<ul>
<li>RabbitMQ采用了AMQP协议中的push模式，生产者直接将消息推送到消息队列中</li>
<li>Redis则需要消费者主动pull模式，消费这需要不断地从Redis中读取消息队列数据</li>
</ul>
</li>
<li>消息持久性<ul>
<li>RabbitMQ支持消息的持久化,保证了消息的可靠传输</li>
<li>Redis虽然可以定期将数据持久化到磁盘,但这仍有丢失数据的风险</li>
</ul>
</li>
<li>集群模式：<ul>
<li>RabbitMQ支持集群模式,可以实现高可用和负载均衡</li>
<li>Redis也支持主从集群,但主节点写数据存在单点风险</li>
</ul>
</li>
<li>处理能力<ul>
<li>RabbitMQ具有较好的路由、消息分发、事件传播等消息队列功能</li>
<li>Redis较适合处理较小的消息,对大消息数据的处理能力较差</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>可靠性传输场景,例如订单处理、消息推送等,建议使用RabbitMQ</li>
<li>高读写性能场景,如分布式session、分布式锁等,建议使用Redis</li>
<li>如果对消息队列的需求较轻,Redis也是一种可选方案</li>
</ul>
<h3 id="MySQL三大日志"><a href="#MySQL三大日志" class="headerlink" title="MySQL三大日志"></a>MySQL三大日志</h3><ul>
<li>错误日志</li>
<li>查询日志</li>
<li>慢查询日志</li>
<li>事务日志</li>
<li>二进制日志  <code>binlog</code>（归档日志）</li>
</ul>
<p>重要的：</p>
<ul>
<li><code>binlog</code>（归档日志）</li>
<li><code>redo log</code> （事务日志）</li>
<li><code>undo log</code> （回滚日志）</li>
</ul>
<h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117728.png" alt="img"></p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>想要查看MySQL存储引擎，可以使用<code>show engines;</code>命令查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117380.png" alt="image-20240309172956178"></p>
<p>可以看出MySQL默认的存储引擎是Innodb，Innodb支持事务、行级锁以及外键</p>
<ul>
<li><strong>事务：</strong></li>
<li><strong>行级锁：</strong>同一时间可以有多个用户同时对不同的行进行读写操作，而不会互相影响。这有助于提高数据库的并发性能，多个用户可以同时访问数据库而不发生冲突。</li>
<li><strong>外键：</strong></li>
<li><strong>崩溃恢复：</strong></li>
</ul>
<p>MySQL存储引擎架构采用的是插件式架构，支持多种存储引擎。</p>
<h3 id="设计MySQL的表结构要考虑什么问题？"><a href="#设计MySQL的表结构要考虑什么问题？" class="headerlink" title="设计MySQL的表结构要考虑什么问题？"></a>设计MySQL的表结构要考虑什么问题？</h3><ul>
<li>主键设计要合理</li>
<li>优先考虑逻辑删除，而不是物理删除</li>
<li>一张表的字段不宜过多</li>
<li>尽可能使用not null定义字段</li>
<li>设计表时，评估那些字段需要加索引</li>
</ul>
<h3 id="MySQL的char和varchar有什么区别？"><a href="#MySQL的char和varchar有什么区别？" class="headerlink" title="MySQL的char和varchar有什么区别？"></a>MySQL的char和varchar有什么区别？</h3><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403252117902.png" alt="image-20240325211718784"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403252117001.png" alt="image-20240325211736893"></p>
<h3 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h3><p>需要结合业务进行回答</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041628520.png" alt="image-20240325211823477"></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403270931363.png" alt="image-20240327093110617"></p>
<p><strong>缓存穿透：</strong>是指查询一条数据，缓存中不存在，并且在MySQL中也查询不到该条数据，导致数据不会直接写入缓存，每次请求都会到数据库</p>
<p>例如一个请求api/news/getById/1</p>
<p>解决方案1：<strong>缓存空值</strong></p>
<p>如果查询的这个对象在数据库中是不存在的，则会在缓存中缓存空值，{key: 1, value: null}</p>
<p><strong>优点：</strong>简单</p>
<p><strong>缺点：</strong>消耗内存，可能会发生数据不一致的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403270920947.png" alt="image-20240327092013420"></p>
<p>解决方案2：<strong>布隆过滤器</strong></p>
<p>在查询数据的时候，首先在布隆过滤器中进行判断该数据是否存在于缓存中，如果存在则从缓存中进行查询，如果不存在直接拦截请求进行返回。</p>
<p>在进行缓存预热的时候就需要将布隆过滤器预热了。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>bitmap（位图）：相当于是一个以（bit）位为单位的数组，数组中每个单位只能存储二进制0和1</p>
<p>布隆过滤器可以检索一个元素是否在一个集合中</p>
<p>首先初始化的时候会创建一个全为0的数组，流程如下：</p>
<ul>
<li>存储数据的时候，id为1的数据，通过多个hash函数获取哈希值，根据哈希值计算出数组对应的位置全部修改为1</li>
<li>查询数据的时候，会根据相同的hash函数计算出hash值，然后判断对应的位置是否都为1，如果为都为1则说明缓存中存在，否则不存在。</li>
</ul>
<p>缺点：布隆过滤器可能会存在一定概率的误判，即一个数据计算hash值在布隆过滤器中均为1但是实际上并不存在，产生了hash碰撞</p>
<p>误判率：数组越小误判率越高，数组越大误判率越小，但是带来了更多的内存消耗</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403270929100.png" alt="image-20240327092924451"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403270924028.png" alt="image-20240327092457241"></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指同一时间段内，有大量的缓存key失效或者Redis服务器宕机，导致大量请求到达数据库中，带来了很大压力</p>
<p>解决方案1：给不同key的TTL添加随机值</p>
<p>解决方案2：利用Redis集群提高服的可用性</p>
<ul>
<li>哨兵模式</li>
<li>集群模式</li>
</ul>
<p>解决方案3：给缓存业务添加降级限流策略</p>
<ul>
<li>Nginx</li>
<li>Spring Cloud Gateway</li>
</ul>
<p>解决方案4：给业务添加多级缓存</p>
<ul>
<li>Guava</li>
<li>Caffeine</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>给key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能会瞬间把DB击垮。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041629252.png" alt="image-20240327095644525"></p>
<h4 id="解决方案1：互斥锁"><a href="#解决方案1：互斥锁" class="headerlink" title="解决方案1：互斥锁"></a>解决方案1：互斥锁</h4><p>能够保证数据的<strong>强一致性</strong>，但是性能较差</p>
<h4 id="解决方案2：设置逻辑过期时间"><a href="#解决方案2：设置逻辑过期时间" class="headerlink" title="解决方案2：设置逻辑过期时间"></a>解决方案2：设置逻辑过期时间</h4><p>能够保证高可用，性能是比较好的</p>
<p>两种方案都是可以的，需要根据具体的适用场景来进行选择，比如金融行业是需要保证数据的强一致性的选择方案1，互联网行业需要保证用户体验选择方案2</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403270946571.png" alt="image-20240327094648384"></p>
<h3 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h3><p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库中的数据要保持一致</p>
<ul>
<li>读数据：缓存命中，直接返回；缓存未命中，写入缓存，设定超时时间</li>
<li>写数据：延迟双删<ul>
<li>删除缓存</li>
<li>操作数据库</li>
<li>延时删除缓存</li>
</ul>
</li>
</ul>
<p>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作，但是不能进行写操作</p>
<p>排他锁：独占锁，writeLock，加锁之后，阻塞其他线程的读写操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041629800.png" alt="image-20240327111706656"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041629170.png" alt="image-20240327111728295"></p>
<p>读写锁在业务必须保持强一致的情况下才会进行使用。</p>
<h4 id="允许短暂的不一致"><a href="#允许短暂的不一致" class="headerlink" title="允许短暂的不一致"></a>允许短暂的不一致</h4><p>能够保证最终的一致性，就是使用了消息队列的服务，主要取决于MQ的可靠性</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041629946.png" alt="image-20240327111931951"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630182.png" alt="image-20240327112000493"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630025.png" alt="image-20240327112122868"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630957.png" alt="image-20240327112148363"></p>
<h3 id="zset的底层原理是什么？"><a href="#zset的底层原理是什么？" class="headerlink" title="zset的底层原理是什么？"></a>zset的底层原理是什么？</h3><p>Redis中的有序集合是它的一种数据结构，使用了跳表和哈希表来实现。有序集合在功能上类似于普通的集合set，但是每个元素都关联了一个分数，可以根据分数对元素进行排序。</p>
<ul>
<li><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4></li>
</ul>
<p>Redis中使用跳跃表作为有序集合的底层实现之一。跳跃表是一种有序的数据结构，类似于多级索引的链表。</p>
<p>跳跃表包含多个层级，每个层级都是一个有序的链表，每个元素在不同的层级都有一个指针，使得在搜索的过程中可以跳过部分元素，提高了搜索效率。</p>
<p>跳跃表中的元素按照分数值从小到大排列，相同分数的元素按照成员值的字典序排列。</p>
<ul>
<li><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4></li>
</ul>
<p>除了跳跃表，Redis也会使用哈希表来存储有序集合的数据，尤其是当元素数量较少或者分数值较大的情况下。</p>
<p>哈希表使用哈希函数将元素的成员值映射到一个桶中，并在每个桶中存储一个有序链表，保持元素的顺序。</p>
<p>哈希表在元素数量较少时具有较好的性能，但随着元素数量的增加，哈希冲突的概率也会增加，影响检索的效率。</p>
<h3 id="Redis的持久化方式有哪些？"><a href="#Redis的持久化方式有哪些？" class="headerlink" title="Redis的持久化方式有哪些？"></a>Redis的持久化方式有哪些？</h3><blockquote>
<p>Redis的读写操作都是在内存中，所以Redis的性能才会高，但是当Redis重启之后，内存中的数据就会丢失。因此为了保证内存中的数据不会丢失，Redis实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在Redis重启之后，就能够从磁盘中恢复原有的数据了。</p>
</blockquote>
<p>Redis的持久化方式有两种：</p>
<ul>
<li><h4 id="AOF日志（Append-Only-File）追加文件"><a href="#AOF日志（Append-Only-File）追加文件" class="headerlink" title="AOF日志（Append Only File）追加文件"></a>AOF日志（Append Only File）追加文件</h4><ul>
<li>每执行一条<strong>写操作</strong>命令，就把该命令以追加的方式写入到一个文件里，看作是命令日志文件；</li>
<li>AOF默认是关闭的，需要把No改为Yes</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630614.png" alt="image-20240325102326437"></p>
<p>因为是记录文件，AOF文件会比RDB文件大得多。而AOF文件会记录对同一个key的多次写操作，但实际上只有最后一次写操作才有意义。通过bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<ul>
<li><h4 id="RDB快照（Redis-Database-Backup-file）redis数据备份文件"><a href="#RDB快照（Redis-Database-Backup-file）redis数据备份文件" class="headerlink" title="RDB快照（Redis Database Backup file）redis数据备份文件"></a>RDB快照（Redis Database Backup file）redis数据备份文件</h4><ul>
<li>将某一时刻的内存中的所有数据，以二进制的方式写入磁盘</li>
<li>使用<code>bgsave</code>开启子进程执行RDB，避免主进程受到影响</li>
<li>save是主进程来执行RDB，会阻塞所有命令</li>
</ul>
</li>
</ul>
<p>AOF日志记录的是操作命令，不是实际的数据，所以用AOF方法做故障恢复时，需要把日志都执行一遍，一旦AOF日志非常多，势必会造成Redis的恢复操作缓慢。</p>
<p>为了解决这个问题，Redis增加了RDB快照。所谓的快照，就是记录某一个瞬间的东西，比如当我们给风景拍照的时候，那一个瞬间的画面和信息就记录到了一张照片。</p>
<p>因此在Redis恢复数据的时候，RDB恢复数据的效率会比AOF高一些，因为直接将RDB文件读入内存就可以，不需要像AOF那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630077.png" alt="image-20240325102907802"></p>
<h4 id="RDB的执行原理"><a href="#RDB的执行原理" class="headerlink" title="RDB的执行原理"></a>RDB的执行原理</h4><p>bgsave开始时会fork主进程得到紫禁城，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041630972.png" alt="image-20240325102139084"></p>
<h3 id="Redis数据过期策略"><a href="#Redis数据过期策略" class="headerlink" title="Redis数据过期策略"></a>Redis数据过期策略</h3><p>Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p>
<ul>
<li><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041631295.png" alt="image-20240325104438157"></p>
<ul>
<li><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4></li>
</ul>
<p>每隔一段时间，就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数据量的随机key进行检查，并删除其中的过期key）</p>
<p>slow模式：定时任务，执行频率默认为10Hz，每次不超过25ms，以通过修改配置文件redis.conf的hz选项来调整这个次数</p>
<p>fast模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041634149.png" alt="image-20240325103901266"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041634146.png" alt="image-20240325104038046"></p>
<h3 id="Redis数据淘汰策略"><a href="#Redis数据淘汰策略" class="headerlink" title="Redis数据淘汰策略"></a>Redis数据淘汰策略</h3><p>默认的淘汰策略是：<code>noeviction</code>，不淘汰任何key，当内存写满时不允许写入新数据，直接报错</p>
<p>LRU：最近最少使用</p>
<p>LFU：最少使用频率</p>
<p>平时开发中使用较多的是<em>allkeys-lru</em>（结合自己的业务场景）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041635657.png" alt="数据淘汰策略"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041635849.png" alt="image-20240325105749146"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041636046.png" alt="image-20240325110029534"></p>
<p>内存用完了会看数据的淘汰策略是什么？如果是默认的配置就会直接报错</p>
<h3 id="Redis是单线程还是多线程的？"><a href="#Redis是单线程还是多线程的？" class="headerlink" title="Redis是单线程还是多线程的？"></a>Redis是单线程还是多线程的？</h3><p>Redis单线程是指【接收客户端请求-&gt;请求解析-&gt;进行数据读写等操作-&gt;发送数据给客户端】这个过程是由一个线程（主线程）来完成的，这也是我们常说Redis是单线程的原因。</p>
<p>但是Redis程序并不是单线程的，Redis在启动的时候，是会启动后台线程BIO的：</p>
<h3 id="Redis大key会有什么问题？怎么解决？"><a href="#Redis大key会有什么问题？怎么解决？" class="headerlink" title="Redis大key会有什么问题？怎么解决？"></a>Redis大key会有什么问题？怎么解决？</h3><p>四种问题：</p>
<ul>
<li>客户端超时阻塞</li>
<li>引发网络阻塞</li>
<li>阻塞工作线程</li>
<li>内存分布不均</li>
</ul>
<p>解决方法</p>
<ul>
<li>拆分成多个小key，降低单key大小，读取可以用mget批量读取</li>
<li>设置合理的过期时间。</li>
<li>启用内存淘汰策略。</li>
<li>数据分片</li>
<li>删除大Key</li>
</ul>
<h3 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h3><ul>
<li> 基于内存，内存的访问速度比磁盘快很多</li>
<li> Redis内置了很多优化过后的数据结构</li>
<li> 单线程事件循环和 IO 多路复用</li>
</ul>
<h2 id="消息队列中间件"><a href="#消息队列中间件" class="headerlink" title="消息队列中间件"></a>消息队列中间件</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403240913255.png" alt="image-20240323152707475"></p>
<p>削峰填谷</p>
<h3 id="RabbitMQ如何保证消息不丢失？"><a href="#RabbitMQ如何保证消息不丢失？" class="headerlink" title="RabbitMQ如何保证消息不丢失？"></a>RabbitMQ如何保证消息不丢失？</h3><p>适用场景：</p>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118102.png" alt="image-20240322202956222"></p>
<p>消息可能丢失的环节：</p>
<p>各个环节都有可能存在消息丢失的可能。</p>
<ul>
<li><p>生产者发送消息没有到达交换机或者没有到达队列</p>
</li>
<li><p>MQ宕机消息丢失</p>
</li>
<li><p>消费者服务宕机消息丢失</p>
</li>
</ul>
<h4 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h4><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否发送成功。</p>
<p><strong>nack  publish-confirm</strong></p>
<p><strong>ack publish-return</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041640045.png" alt="image-20240327142028977"></p>
<p>消息失败之后如何处理？</p>
<ul>
<li>回调方法即时重发</li>
<li>记录日志</li>
<li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据<strong>【定时任务】</strong></li>
</ul>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>MQ默认是内存存储信息，开启持久化功能可以确保缓存在MQ中消息不丢失</p>
<ul>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化，SpringAMQP中的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来制定</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118657.png" alt="image-20240322203441139"></p>
<h4 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h4><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后向MQ发送ack回执，MQ收到ack回执之后才会删除该消息。SpringAMQP允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack</li>
<li><strong>auto：自动ack，由spring检测listener代码是否出现异常，如果没有异常则返回ack，抛出异常则返回nack</strong>【选择这个模式】</li>
<li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>
</ul>
<p>可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118219.png" alt="image-20240322203700727"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041641281.png" alt="image-20240327143041337"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041641700.png" alt="image-20240327143053773"></p>
<h3 id="RabbitMQ消息的重复问题是如何解决的？"><a href="#RabbitMQ消息的重复问题是如何解决的？" class="headerlink" title="RabbitMQ消息的重复问题是如何解决的？"></a>RabbitMQ消息的重复问题是如何解决的？</h3><p>消费者消费完毕需要给MQ发送确认</p>
<ul>
<li><p>网络抖动</p>
</li>
<li><p>消费者挂了</p>
<p>解决方案：</p>
</li>
</ul>
<p>每条消息设置一个唯一的标识id</p>
<p>幂等方案：【分布式锁、数据库锁（乐观锁、悲观锁）】</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041641448.png" alt="image-20240327143913436"></p>
<h3 id="RabbitMQ中死信交换机（延迟队列了解过吗）"><a href="#RabbitMQ中死信交换机（延迟队列了解过吗）" class="headerlink" title="RabbitMQ中死信交换机（延迟队列了解过吗）"></a>RabbitMQ中死信交换机（延迟队列了解过吗）</h3><p>延迟队列：进入队列的消息会被延迟消的队列</p>
<p>场景：超时订单、限时优惠【优惠剩余时间】、定时发布【抖音作品选择明天进行发布】</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041641450.png" alt="超时订单"></p>
<p>当一个队列中的消息满足下列情况之一，就可以称之为死信（dead letter）：</p>
<ul>
<li><p>消费者使用basic.reject或者basic.nack声明消费失败，并且消息的requeue参数设置为fasle</p>
</li>
<li><p>消息是一个过期消息，超时无人消费</p>
</li>
<li><p>要投递的队列消息堆积满了，最早的消息可能成为死信</p>
</li>
</ul>
<p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就会被称为<strong>死信交换机</strong>（Dead Letter Exchange，简称DLX）</p>
<p>死信交换机也可以绑定搞一个死信队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404041641986.png" alt="image-20240327145731858"></p>
<p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况：</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间</li>
</ul>
<p><img src="./images/image-20240327150004506.png" alt="image-20240327150004506"></p>
<p>延迟队列通过TTL+死信队列实现</p>
<p><img src="./images/image-20240327150132941.png" alt="image-20240327150132941"></p>
<p><img src="./images/image-20240327150322665.png" alt="image-20240327150322665"></p>
<p><img src="./images/image-20240327150333573.png" alt="image-20240327150333573"></p>
<h3 id="如何解决消息堆积问题？"><a href="#如何解决消息堆积问题？" class="headerlink" title="如何解决消息堆积问题？"></a>如何解决消息堆积问题？</h3><p>如果有100万消息堆积在MQ，如何解决？</p>
<p>解决消息堆积有三种思路：</p>
<ul>
<li>增加更多消费者</li>
<li>在</li>
</ul>
<h3 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h3><p>是一个开源的消息中间件，使用Erlang 语言开发。这种语言天然适用分布式场景。</p>
<p>RabbitMQ也非常适用于在分布式应用程序之间传递消息。RabbitMQ有非常多的显著的特点：</p>
<ul>
<li>消息传递模式，包括发布/订阅模式、点对点和工作队列等，使其灵活运用于各种消息通信场景。</li>
<li>消息路由和交换机：RabbitMQ引入了Exchange的概念，用于将消息路由到一个或多个队列。这允许根据消息的内容、</li>
</ul>
<h3 id="RabbitMQ的原理"><a href="#RabbitMQ的原理" class="headerlink" title="RabbitMQ的原理"></a>RabbitMQ的原理</h3><p>RabbitMQ的四大核心：</p>
<ul>
<li>生产者</li>
<li>消费者</li>
<li>队列</li>
<li>交换机</li>
</ul>
<p>AMQ协议是一种二进制的协议，它定义了一组规则和标准，以确保消息可以在不同的应用程序和平台之间传递消息。</p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul>
<li>物理层<br>+ </li>
<li>数据链路层<br>+ </li>
<li>网络层<br>+ </li>
<li>传输层<ul>
<li>TCP/IP</li>
</ul>
</li>
<li>会话层<br>+ </li>
<li>表示层<br>+ </li>
<li>应用层<ul>
<li>HTTP</li>
<li>Telnet</li>
<li>SMTP</li>
<li>POP3/IMAP</li>
<li>FTP</li>
<li>ssh</li>
<li>DNS</li>
<li>WebSocket</li>
<li>RTP</li>
</ul>
</li>
</ul>
<h3 id="浏览网页的全过程"><a href="#浏览网页的全过程" class="headerlink" title="浏览网页的全过程"></a>浏览网页的全过程</h3><ul>
<li>浏览器输入指定网页的url，例如tencent.com</li>
<li>浏览器通过DNS协议，获取域名对应的IP地址<ul>
<li>DNS流程：首先获取浏览器缓存</li>
<li>缓存中没有去host文件</li>
<li>然后网卡配置信息中可以是自动获取DNS服务器或者指定</li>
<li>我一般会指定谷歌的8.8.8.8DNS服务器或者腾讯的119.29.29.29 或者阿里云的223.5.5.5、223.6.6.6</li>
</ul>
</li>
<li>紧接着浏览器根据IP地址和端口号，向目标服务器发送一个TCP连接请求</li>
<li>浏览器在tcp连接上，向服务器发送一个HTTP请求报文，请求获取网页内容，</li>
<li>服务器收到http请求报文后，服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到http响应报文后，解析响应体中的html代码，同时根据html中其他资源的url，再次发起http请求，获取这些资源，直到网页加载显示。</li>
<li>浏览器在不需要和服务器通信的时候，可以主动关闭tcp连接或者等待服务器关闭连接。</li>
</ul>
<h3 id="介绍下TCP-UDP的区别"><a href="#介绍下TCP-UDP的区别" class="headerlink" title="介绍下TCP UDP的区别"></a>介绍下TCP UDP的区别</h3><ol>
<li><strong>连接性</strong>：<ul>
<li>TCP 是面向连接的协议，通信双方在传输数据之前需要先建立连接，然后进行可靠的数据传输，最后再释放连接；而 UDP 是无连接的协议，通信双方之间直接发送数据包，不需要建立连接，也不保证数据传输的可靠性。</li>
</ul>
</li>
<li><strong>数据可靠性</strong>：<ul>
<li>TCP 提供可靠的数据传输服务，通过序号、确认和重传机制来保证数据的可靠性，确保数据不会丢失、损坏或者乱序；而 UDP 不提供数据传输的可靠性保证，发送方发送的数据包有可能丢失、重复或者乱序。</li>
</ul>
</li>
<li><strong>通信效率</strong>：<ul>
<li>TCP 的通信效率相对较低，因为它需要建立连接、维护状态、进行数据确认和重传等操作，而且因为可靠性保证的需要可能引入较大的延迟；而 UDP 的通信效率相对较高，因为它是无连接的，不需要进行连接建立和状态维护，也不需要数据确认和重传操作。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>TCP 适用于对数据传输可靠性要求较高的场景，如网页浏览、文件传输、电子邮件等应用；而 UDP 适用于对实时性要求较高、但数据传输可靠性要求较低的场景，如音频、视频、在线游戏等应用。</li>
</ul>
</li>
</ol>
<p>总的来说，TCP 提供了可靠的、面向连接的数据传输服务，适用于对数据完整性和顺序性要求较高的场景；而 UDP 提供了高效的、无连接的数据传输服务，适用于对实时性要求较高、但数据传输可靠性要求较低的场景。选择 TCP 还是 UDP 取决于具体的应用需求和场景。</p>
<ul>
<li><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2></li>
</ul>
<p><img src="./images/image-20240323151955474.png" alt="image-20240323151955474"></p>
<h3 id="单例bean是线程安全的吗？"><a href="#单例bean是线程安全的吗？" class="headerlink" title="单例bean是线程安全的吗？"></a>单例bean是线程安全的吗？</h3><p>不是线程安全的</p>
<p><img src="./images/image-20240327132555253.png" alt="image-20240327132555253"></p>
<p><img src="./images/image-20240327132604435.png" alt="image-20240327132604435"></p>
<h3 id="什么是AOP，你们项目中有没有使用到AOP"><a href="#什么是AOP，你们项目中有没有使用到AOP" class="headerlink" title="什么是AOP，你们项目中有没有使用到AOP"></a>什么是AOP，你们项目中有没有使用到AOP</h3><p>对AOP的理解，有没有真的使用过AOP</p>
<p>AOP被称为面向切片编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的木块，这个模块被命名为“切面”，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>常见AOP使用场景：</p>
<ul>
<li>记录操作日志</li>
</ul>
<p>使用aop提供的环绕通知，@Around(“pointcut”)</p>
<ul>
<li>缓存处理</li>
</ul>
<p><img src="./images/image-20240327140804403.png" alt="image-20240327140804403"></p>
<h3 id="谈谈你对AOP的理解？"><a href="#谈谈你对AOP的理解？" class="headerlink" title="谈谈你对AOP的理解？"></a>谈谈你对AOP的理解？</h3><p><img src="./images/image-20240401143914385.png" alt="image-20240401143914385"></p>
<h3 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h3><h3 id="Spring事务是如何实现的"><a href="#Spring事务是如何实现的" class="headerlink" title="Spring事务是如何实现的"></a>Spring事务是如何实现的</h3><h3 id="Springboot启动原理"><a href="#Springboot启动原理" class="headerlink" title="Springboot启动原理"></a>Springboot启动原理</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032218548.png" alt="image-20240403221800539"></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Java中单例模式可以通过多种方式实现，其中比较常见的包括懒汉式和饿汉式。</p>
<ul>
<li>懒汉式单例模式：在需要的时候才创建实例</li>
<li>饿汉式单例模式：在类加载的时候就创建实例</li>
</ul>
<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403241939683.png" alt="image-20240324193927834"></p>
<ul>
<li><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4></li>
</ul>
<p>开闭原则：对扩展开放，对修改关闭</p>
<p>通过个工厂类来实现对应对象的创建，只需要传递对应的对象名即可</p>
<ul>
<li><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032146159.png" alt="image-20240403214614690"></p>
<p><strong>抽象工厂：</strong>提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</p>
<p><strong>具体工厂：</strong>主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</p>
<p><strong>抽象产品：</strong>定义了产品的规范，描述了产品的主要特性和功能。</p>
<p><strong>具体产品：</strong>实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可以得到所要的产品，无需知道产品的具体创建过程；</li>
<li>在系统增加新的产品时，只需要添加具体产品类和对应的具体工厂类，无需对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>缺点：</strong>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</p>
<ul>
<li><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4></li>
</ul>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可以生产多个产品等级的产品。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032111095.png" alt="image-20240324195451354"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032111017.png" alt="image-20240324195736322"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403242000815.png" alt="image-20240324200003970"></p>
<p>工厂模式最大的目的就是为了解耦，Spring底层就大量用到了工厂模式</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响使用算法的客户</p>
<p>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不冉的对象对这些算法进行管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403242005371.png" alt="image-20240324200235590"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403242005701.png" alt="image-20240324200523384"></p>
<p>举例：</p>
<p>登录案例（工厂模式+策略模式）</p>
<p>例如<code>gitee</code>的登录方式，有很多中（账号、密码、QQ、微博、微信、钉钉等）</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常见的负载均衡算法有哪些？"><a href="#常见的负载均衡算法有哪些？" class="headerlink" title="常见的负载均衡算法有哪些？"></a>常见的负载均衡算法有哪些？</h3><ul>
<li><p>轮询</p>
</li>
<li><p>指定权重</p>
</li>
<li><p>IP绑定 ip_hash</p>
</li>
<li></li>
<li><p>轮询</p>
</li>
<li><p>加权轮询</p>
</li>
<li><p>随机</p>
</li>
<li><p>加权随机</p>
</li>
<li><p>最少连接</p>
</li>
<li><p>IP Hash</p>
</li>
<li><p>一致性哈希</p>
</li>
</ul>
<ol>
<li>客户端发送请求到Nginx服务器</li>
<li>Nginx服务器收到请求后，使用一定的负载均衡算法（如轮询、IP哈希、最少连接数等）</li>
<li>Nginx将请求转发给选中后的后端服务器</li>
<li>后端服务器处理请求并返回响应给Nginx</li>
<li>Nginx将响应返回给客户端</li>
</ol>
<h2 id="常见技术场景"><a href="#常见技术场景" class="headerlink" title="常见技术场景"></a>常见技术场景</h2><h3 id="单点登录这块是如何实现的？"><a href="#单点登录这块是如何实现的？" class="headerlink" title="单点登录这块是如何实现的？"></a>单点登录这块是如何实现的？</h3><p>单点登录叫做SSO（Single Sign On），只需要登录一次，就可以访问所有信任的应用系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404032112646.png" alt="image-20240324203150147"></p>
<ol>
<li>解释什么是单点登录</li>
<li>介绍自己项目中涉及到的单点登录（即使没涉及也要说明思路）</li>
<li>介绍单点登录的解决方案，以JWT为例</li>
</ol>
<ul>
<li>用户访问其他系统，会在网关判断token是否有效</li>
<li>如果token无效则会返回401（认证失败）前端跳转到登录页面</li>
<li>用户发送登录请求，返回浏览器一个Token，浏览器把token保存到cookie</li>
<li>再去访问其他服务的时候都需要携带token，由网关统一验证后路由到目标服务</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403242039130.png" alt="image-20240324203914412"></p>
<h3 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a>权限认证是如何实现的？</h3><p>后台管理系统，更注重权限控制，最常见的就是RBAC模型来指导实现权限</p>
<p>RBAC（Role-Based Access Control）基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：用户、角色、权限</li>
<li>具体实现<ul>
<li><strong>5张表（用户表、角色表、权限表、用户角色中间表、角色权限中间表）</strong></li>
<li>7张表（用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表）</li>
</ul>
</li>
</ul>
<p><img src="./images/image-20240324204153301.png" alt="image-20240324204153301"></p>
<p>张三登录系统—-&gt;查询张三拥有的角色列表—-&gt;在根据角色查询拥有的权限</p>
<p>结合权限框架：</p>
<ul>
<li>Apache shiro</li>
<li>Spring Security【推荐】</li>
</ul>
<h3 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a>上传数据的安全性你们怎么控制？</h3><p>使用非对称加密（或对称加密），给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据。</p>
<h3 id="你负责项目的时候遇到哪些棘手的问题？怎么解决？"><a href="#你负责项目的时候遇到哪些棘手的问题？怎么解决？" class="headerlink" title="你负责项目的时候遇到哪些棘手的问题？怎么解决？"></a>你负责项目的时候遇到哪些棘手的问题？怎么解决？</h3><ul>
<li>设计模式?<ul>
<li>登录功能【使用工厂模式和策略模式】解决了增加登录方式所导致的经常修改代码的问题</li>
</ul>
</li>
<li>线上bug</li>
<li>调优</li>
<li>组件封装</li>
</ul>
<p><img src="./images/image-20240324205108984.png" alt="image-20240324205108984"></p>
<h3 id="生产环境中问题如何排查"><a href="#生产环境中问题如何排查" class="headerlink" title="生产环境中问题如何排查"></a>生产环境中问题如何排查</h3><ul>
<li>先分析日志</li>
<li>远程debug</li>
<li></li>
</ul>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="项目1：博世实习"><a href="#项目1：博世实习" class="headerlink" title="项目1：博世实习"></a>项目1：博世实习</h2><h3 id="如何实现的单点登录"><a href="#如何实现的单点登录" class="headerlink" title="如何实现的单点登录?"></a>如何实现的单点登录?</h3><p>简单介绍一下单点登录的原理</p>
<h3 id="SpringSecurity的认证流程？"><a href="#SpringSecurity的认证流程？" class="headerlink" title="SpringSecurity的认证流程？"></a>SpringSecurity的认证流程？</h3><p>密码加密的过程</p>
<p>原有的md5加密【位数为32位】的方法 是一种信息摘要算法，他可以通过彩虹表和哈希碰撞来进行破解，网上也有很多的在线解密平台，可以直接将密码破解出来。因此我们密码加密采用的是BCryptPasswordEncoder()，这可以有效的防止彩虹表和碰撞攻击，这个方法每一次生成的密码都是不一致的，然后在进行校验的时候是调用match()方法，如果新旧密码是一致的，则返回true。</p>
<p>自动产生了一个随机盐加入到原密码中，这样如果a用户和b用户的密码一样，但是算出来的加密值是不一样的，并在在反运算的时候会自动将盐提取出来，然后得出正确的密码。</p>
<p>它的存储位数是<strong>【60】</strong>位字段</p>
<h3 id="双Token如何实现无感刷新机制？"><a href="#双Token如何实现无感刷新机制？" class="headerlink" title="双Token如何实现无感刷新机制？"></a>双Token如何实现无感刷新机制？</h3><p>续约token在我们的项目中是有设计过的，恰好也是我做的。当时产品经理给到的需求是用户可以保持一个长期登录或者自动登录的效果，避免用户状态频繁的过期，给用户带来不便。</p>
<p>我当时就使用了双Token的方式进行设计，这个方案的提出后来经过mentor的评估，他也认为没有问题，于是我就这么做了。</p>
<p>我给您说一下大概的思路：</p>
<p>首先是登录，在登录的时候，无论任何方式认证，最后都是返回Toekn到前端。</p>
<p>在返回Token的时候，是生成两个Toekn：</p>
<ul>
<li>一个是Access Token，我管他叫访问令牌。我出于安全考虑，比如防止令牌被恶意使用，给他设置的有效期为6 个小时，每次请求资源时携带这个令牌</li>
<li>另一个是RefreshToekn，我管他叫刷新令牌，这个令牌不能用来访问资源，只能用来刷新访问令牌，就是每当访问令牌过期，前端携带这个RefreshToken获取新的Access Token，这个刷新Toekn的有效期我设置为7天，当然这个也时间的设置是需要根据项目的需求来的，也是写在配置文件中的。</li>
</ul>
<h3 id="RabbitMQ如何去实现"><a href="#RabbitMQ如何去实现" class="headerlink" title="RabbitMQ如何去实现"></a>RabbitMQ如何去实现</h3><ul>
<li>创建消息队列<ul>
<li>在RabbitMQ中创建一个消息队列，用于存储要发送的异步消息</li>
</ul>
</li>
<li>发送消息<ul>
<li>在我们的应用中，如果员工在修改了自己的信息或者项目经理修改了员工所在项目状态的时候，就会将变更发布到消息队列当中，</li>
</ul>
</li>
<li>消息消费者<ul>
<li>我们编写了一个消息消费者的应用程序，该应用程序连接到RabbitMQ并监听特定的消息队列。一旦有新消息到达队列，消费者就会接收到消息并进行相应的逻辑处理</li>
</ul>
</li>
<li>异步处理</li>
</ul>
<h3 id="如何让一个用户强制下线"><a href="#如何让一个用户强制下线" class="headerlink" title="如何让一个用户强制下线"></a>如何让一个用户强制下线</h3><p>在我们的项目中使用的是jwt，所以要在后台实现让用户强制下线的操作可以按照下面的步骤进行：</p>
<ul>
<li>维护Token的黑名单</li>
<li>实现登出接口</li>
<li>Token验证时候检查黑名单</li>
<li>Token过期机制<ul>
<li>可以通过将用户的token过期时间设置为当前时间，从而在用户下次进行需要进行权限操作的时候token失效而退出</li>
</ul>
</li>
</ul>
<h2 id="项目2：智能简历解析系统"><a href="#项目2：智能简历解析系统" class="headerlink" title="项目2：智能简历解析系统"></a>项目2：智能简历解析系统</h2><h2 id="回答话术"><a href="#回答话术" class="headerlink" title="回答话术"></a>回答话术</h2><h3 id="ThreadLocal在项目中有使用过吗？"><a href="#ThreadLocal在项目中有使用过吗？" class="headerlink" title="ThreadLocal在项目中有使用过吗？"></a>ThreadLocal在项目中有使用过吗？</h3><p>有的，我们是使用ThreadLocal保存用户的状态信息，这样就可以随时随地获取到用户的信息了。实际项目流程是这样设计的：</p>
<ul>
<li>首先请求到网关，我在网关这边设计了一个全局过滤器。</li>
<li>当他拦截下来请求后，将请求进行解析，从请求头中拿到用户的访问Token，这个Token进行解密后，转为JWT格式的Token，并校验签名是否正确以及Token是否过期，如果没有问题就获取到用户账号，并且将账号信息写到请求头中，转发给后面的业务服务。</li>
</ul>
<p>ThreadLocal主要解决的问题是：</p>
<ul>
<li>线程安全性，通过为每个线程提供独立的变量副本，避免了多线程之间的竞争和相互干扰，从而保证了数据的线程安全性</li>
<li>数据隔离性：</li>
<li>避免线程间传递参数</li>
</ul>
<p>方法</p>
<ul>
<li><code>get()</code></li>
<li><code>set(value)</code></li>
<li><code>remove()</code></li>
<li><code>initialValue()</code></li>
</ul>
<h3 id="前端项目是怎么部署的？"><a href="#前端项目是怎么部署的？" class="headerlink" title="前端项目是怎么部署的？"></a>前端项目是怎么部署的？</h3><p>我们采用Nginx作为前端项目的部署服务器，前端采用vue编写的，前端写完会使用webpack进行编译构建，把vue文件转为编译后的js、css、html之类的静态资源，然后把这些静态资源打包发布到nginx服务器。</p>
<p>部署的方式也很简单，将静态资源更新到nginx的html目录下，然后修改nginx配置文件，将root目录指定到项目路径，这样前端请求域名根路径下的静态资源时，直接在nginx端进行响应了。</p>
<h3 id="前后端交互式怎么配合的？"><a href="#前后端交互式怎么配合的？" class="headerlink" title="前后端交互式怎么配合的？"></a>前后端交互式怎么配合的？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403072119579.png" alt="image-20240307211942776"></p>
<h3 id="登录时手机验证码做过限流吗？"><a href="#登录时手机验证码做过限流吗？" class="headerlink" title="登录时手机验证码做过限流吗？"></a>登录时手机验证码做过限流吗？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117183.png" alt="image-20240307214050576"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117087.png" alt="image-20240307214557292"></p>
<p>有的，这个必须要做限流，我们是利用Redis的zset结合时间窗口限流算法进行实现的。</p>
<p>我是这样考虑的，用户有很多行为是无意义或者非法的，比如频繁发送短信、频繁修改个人信息等行为，都应该进行限流。</p>
<p>所以我就针对这些频繁的行为进行限流，设计了一个通用的限流接口。思路上是使用时间窗口限流算法，具体实现我是利用redis的zset实现的。</p>
<p>比如用户五分钟内只能发送三条验证码，或者10分钟内只能发送8个验证码，于是我就将用户的发短信行为设计为redis的key，格式是场景:行为:用户唯一标识，score分数值是时间戳，value也是时间戳。</p>
<p>具体流程为：</p>
<ul>
<li>用户每次发生限流行为，都会记录这个行为以Redis的zset的方式进行记录</li>
<li>在业务处理流程中，使用java api进行查询判断，其本质就是调用了redis的zcount命令，这个命令可以传入起始分值和结束分值。我当前时间戳作为结束分值，然后用当前时间戳减去限流时间，比如5分钟的毫秒值，求出来5分钟前的时间戳，于是根据这两个时间戳作为分值，范围查询zset中出现的次数，就得到用户在5分钟内，这个行为一共触发了几次。</li>
<li>后续的业务，就是不同的场景中，根据不同的需求进行校验。</li>
</ul>
<p>利用redis的zset进行实现</p>
<p>时间窗口限流</p>
<p>key的格式：【场景:行为:用户唯一标识:(手机号、用户名)】</p>
<p>score：时间戳</p>
<p>value：时间戳</p>
<p>key: COMMON:LOGIN:PHONE:15061131871</p>
<p>redis的命令：ZOUNT key min max</p>
<p>返回指定分值范围内的成员数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117040.png" alt="image-20240307213937989"></p>
<p>Java：</p>
<ul>
<li>记录限流行为（将内容存到redis中）</li>
<li>查询用户行为在指定时间段的行为</li>
<li>java业务代码自行根据需求判断是否进行限流</li>
</ul>
<h3 id="续约Token是怎么设计的"><a href="#续约Token是怎么设计的" class="headerlink" title="续约Token是怎么设计的"></a>续约Token是怎么设计的</h3><p>避免用户</p>
<h3 id="Token无感刷新"><a href="#Token无感刷新" class="headerlink" title="Token无感刷新"></a>Token无感刷新</h3><h3 id="你们项目的数据库是怎么设计的？分了几个库和表，你负责设计过那些数据库？"><a href="#你们项目的数据库是怎么设计的？分了几个库和表，你负责设计过那些数据库？" class="headerlink" title="你们项目的数据库是怎么设计的？分了几个库和表，你负责设计过那些数据库？"></a>你们项目的数据库是怎么设计的？分了几个库和表，你负责设计过那些数据库？</h3><p>数据库设计是在项目初期阶段完成的。当时我们先确定了基本需求以及采用的架构后，围绕业务涉及数据库表结构。</p>
<p>我们一共分了6个数据库，分别是：权限管理、系统管理、用户管理</p>
<p>我当时主要负责权限管理、</p>
<p>我们设计数据库的思路就是，围绕业务进行设计。</p>
<p>首先我们是拆分出来有哪些业务模块，优先梳理出核心的业务，围绕核心业务设计数据库表，这部分工作主要是产品经理完成的，他会先给出初期的需求文档。</p>
<p>然后我围绕我负责的几个模块，分析相关的业务流程，每一个流程的业务设计到哪些实体，整个业务流程围绕这几个实体是怎么运转的，当我把这个想明白后，我直接使用powerdesigner绘制物理数据模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222117046.png" alt="image-20240308104629421"></p>
<h3 id="登录是怎么做的？"><a href="#登录是怎么做的？" class="headerlink" title="登录是怎么做的？"></a>登录是怎么做的？</h3><p><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403222118633.png" alt="image-20240308125059208"></p>
<p>Redis的时间窗口限流算法</p>
<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><blockquote>
<p>2024年3月14日</p>
<p>腾讯会议半小时</p>
</blockquote>
<p>流程</p>
<p>自我介绍</p>
<p>收获</p>
<ul>
<li>自我介绍改进<ul>
<li>不合理的自我介绍可能会带来一定的坑 注意！！！</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="常见的攻击手段或者可以利用的漏洞有哪些？"><a href="#常见的攻击手段或者可以利用的漏洞有哪些？" class="headerlink" title="常见的攻击手段或者可以利用的漏洞有哪些？"></a>常见的攻击手段或者可以利用的漏洞有哪些？</h3><ol>
<li><strong>SQL注入（SQL Injection）</strong>：通过在用户输入中注入恶意的SQL代码，从而执行未经授权的数据库操作。</li>
<li><strong>跨站脚本（Cross-Site Scripting，XSS）</strong>：通过在网页中插入恶意的脚本代码，利用用户对网站的信任执行恶意操作。</li>
<li><strong>跨站请求伪造（Cross-Site Request Forgery，CSRF）</strong>：利用受害者已经登录的身份，在不知情的情况下发送恶意请求，以执行某些操作。</li>
<li><strong>文件包含漏洞</strong>：通过未经正确验证的用户输入，将恶意文件包含到网站中，导致执行恶意代码。</li>
<li><strong>未经授权访问漏洞</strong>：未正确验证用户身份或权限的情况下，允许用户访问受限资源或执行受限操作。</li>
<li><strong>身份验证漏洞</strong>：例如弱密码、密码重置漏洞、会话劫持等，可以导致攻击者获取未授权的访问权限。</li>
<li><strong>不安全的文件上传</strong>：允许用户上传任意文件，但未正确验证文件类型、大小和内容，导致恶意文件上传和执行。</li>
<li><strong>XML外部实体注入（XML External Entity Injection，XXE）</strong>：利用XML解析器解析恶意的外部实体或远程文件，从而获取敏感信息或执行恶意操作。</li>
<li><strong>服务端请求伪造（Server-Side Request Forgery，SSRF）</strong>：利用服务端发起的HTTP请求执行恶意操作，例如访问内部系统、绕过防火墙等。</li>
<li><strong>缓冲区溢出漏洞</strong>：通过向缓冲区输入超出其容量的数据，覆盖其他内存区域，从而执行恶意代码。</li>
</ol>
<h3 id="http1-1和http2-0的区别"><a href="#http1-1和http2-0的区别" class="headerlink" title="http1.1和http2.0的区别"></a>http1.1和http2.0的区别</h3><ol>
<li>多路复用</li>
<li>头部压缩</li>
<li>服务器推送</li>
<li>流量优先级</li>
<li>二进制协议</li>
<li>连接复用</li>
</ol>
<h3 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h3><ol>
<li>攻击者在恶意网站中放置恶意代码，该代码会向受害者的浏览器发送带有伪造请求的http请求</li>
<li>受害者在登录过某个网站并保留会话状态时，访问了包含恶意外码的网站</li>
<li>受害者的浏览器执行了恶意代码，向目标网站发送了伪造的http请求，由于浏览器会自动发送已登录的用户凭证，因此目标网站会误以为请求是合法的。</li>
<li>目标网站收到请求后，会按照受害者的权限执行请求，导致攻击者攻击者所期望的恶意行为发生，比如修改用户资料等</li>
</ol>
<h3 id="单索引和联合索引的区别？会用在什么场景？"><a href="#单索引和联合索引的区别？会用在什么场景？" class="headerlink" title="单索引和联合索引的区别？会用在什么场景？"></a>单索引和联合索引的区别？会用在什么场景？</h3><h3 id="索引如果过多会发生什么"><a href="#索引如果过多会发生什么" class="headerlink" title="索引如果过多会发生什么"></a>索引如果过多会发生什么</h3><ul>
<li>存储空间占用增加</li>
<li>写操作性能下降</li>
<li>查询性能下降</li>
<li>维护成本增加</li>
<li>内存占用增加</li>
</ul>
<h3 id="java对象是怎么回收的？"><a href="#java对象是怎么回收的？" class="headerlink" title="java对象是怎么回收的？"></a>java对象是怎么回收的？</h3><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><blockquote>
<p>2024年3月25日 一面</p>
<p>岗位：后端开发</p>
<p>2024年4月2日 二面</p>
<p>基础研发平台-企业平台研发部</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Clay_Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://guoxiansen.github.io/2023/03/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%872024/">https://guoxiansen.github.io/2023/03/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%872024/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mytag/">mytag</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/11/CloudSim%20Installation/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310112103086.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">CloudSim Installation</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/21/PROM1014-%E7%BA%A7%E6%95%B0%E6%B1%82%E5%92%8C/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202310181255837.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">PROM1014-级数求和</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Clay_Guo</div><div class="author-info__description">生活可以忙忙碌碌随大流，思想偷偷摸摸求上进</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">47</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GuoXianSen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GuoXianSen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guoyinzhi@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">这是我的博客，欢迎关注！博客还在不断的完善中，敬请期待...<br>QQ:775741842<br>微信:Clay_Guo<br></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">个人技能部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaSE"><span class="toc-number">2.1.</span> <span class="toc-text">JavaSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">ArrayList底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">ArrayList扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">ArrayList和LinkedList的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">HashMap扩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="toc-number">2.3.</span> <span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.1.</span> <span class="toc-text">线程和进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.2.</span> <span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">创建线程的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.4.</span> <span class="toc-text">线程池相关面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">2.3.5.</span> <span class="toc-text">线程池中有哪些常见的阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.6.</span> <span class="toc-text">实现Runnable接口和Callable接口有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.7.</span> <span class="toc-text">线程的run()和start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.8.</span> <span class="toc-text">线程包括哪些状态，状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BAT1%E3%80%81T2%E3%80%81T3%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%96%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.3.9.</span> <span class="toc-text">新建T1、T2、T3三个线程，如何保证他们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.10.</span> <span class="toc-text">notify()和notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%92%8Csleep-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.3.11.</span> <span class="toc-text">wait()和sleep()方法有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.12.</span> <span class="toc-text">如何停止一个正在运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.13.</span> <span class="toc-text">synchronized关键字的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.14.</span> <span class="toc-text">synchronized和ReentrantLock有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.15.</span> <span class="toc-text">ReentrantLock底层原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%E5%B1%9E%E4%BA%8E%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E9%94%81%E5%8D%87%E7%BA%A7%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.16.</span> <span class="toc-text">Monitor属于重量级锁，你了解锁升级吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E4%B8%80%E8%81%8AconcurrentHashMap"><span class="toc-number">2.3.17.</span> <span class="toc-text">聊一聊concurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="toc-number">2.3.18.</span> <span class="toc-text">Java内存模型JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.19.</span> <span class="toc-text">CAS你知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.20.</span> <span class="toc-text">CAS底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.21.</span> <span class="toc-text">CAS存在什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%AE%97%E6%B3%95%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.3.22.</span> <span class="toc-text">CAS算法存在哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.3.23.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">2.3.24.</span> <span class="toc-text">如何实现乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.25.</span> <span class="toc-text">谈谈你对Volatile关键字的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">2.3.26.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">2.3.27.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB%EF%BC%89"><span class="toc-number">2.3.28.</span> <span class="toc-text">多线程实际开发中的实际场景（数据汇总）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.29.</span> <span class="toc-text">谈谈对ThreadLocal的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.30.</span> <span class="toc-text">ThreadLocal内存泄漏问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">2.4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">什么是程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E7%BB%99%E6%88%91%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8DJava%E7%9A%84%E5%A0%86%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">你能给我详细介绍Java的堆吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.4.3.</span> <span class="toc-text">什么是虚拟机栈?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E6%B6%89%E5%8F%8A%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">垃圾回收是否涉及栈内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">栈内存分配的越大越好吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">方法内的局部变量是否安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">栈内存溢出情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">栈堆的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.4.4.</span> <span class="toc-text">能不能解释一下方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%90%AC%E8%BF%87%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.5.</span> <span class="toc-text">你听过直接内存吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.4.6.</span> <span class="toc-text">什么是类加载器，类加载器有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">类加载器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%EF%BC%88-%EF%BC%89"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">什么是双亲委派模型？（*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.4.6.4.</span> <span class="toc-text">JVM为什么采用双亲委派机制？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.7.</span> <span class="toc-text">类装载的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.7.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.7.6.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.4.7.7.</span> <span class="toc-text">卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94"><span class="toc-number">2.4.7.8.</span> <span class="toc-text">回答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9B%9E%E6%94%B6%EF%BC%88-%EF%BC%89"><span class="toc-number">2.4.8.</span> <span class="toc-text">对象什么时候可以被垃圾回收器回收（*）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%B0%E6%95%B0%E6%B3%95"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">引用记数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.8.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%EF%BC%9F"><span class="toc-number">2.4.8.3.</span> <span class="toc-text">哪些对象可以作为GC Root？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.4.9.</span> <span class="toc-text">JVM垃圾回收算法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">复制算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.4.10.</span> <span class="toc-text">JVM中的分代回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.10.1.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.10.2.</span> <span class="toc-text">工作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC%E3%80%81Mixed-GC%E3%80%81Full-GC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.11.</span> <span class="toc-text">Minor GC、Mixed GC、Full GC的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88-%EF%BC%89"><span class="toc-number">2.4.12.</span> <span class="toc-text">JVM有哪些垃圾回收器（*）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.12.1.</span> <span class="toc-text">串行垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%BE%88%E5%A4%9Ajdk%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E7%9A%84%EF%BC%89"><span class="toc-number">2.4.12.2.</span> <span class="toc-text">并行垃圾回收器（很多jdk版本默认的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%88%E5%B9%B6%E5%8F%91%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.12.3.</span> <span class="toc-text">CMS（并发）垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88-%EF%BC%89"><span class="toc-number">2.4.13.</span> <span class="toc-text">详细聊一下G1垃圾回收器（*）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Yong-GC%EF%BC%88%E5%B9%B4%E8%BD%BB-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">2.4.13.1.</span> <span class="toc-text">Yong GC（年轻&#x2F;新生代垃圾回收）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Yong-GC-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.13.2.</span> <span class="toc-text">Yong GC+并发标记阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.13.3.</span> <span class="toc-text">混合收集阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.14.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.14.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.14.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.14.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.14.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-number">2.5.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%BF%87%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%88%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">了解过索引吗（什么是索引？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.2.</span> <span class="toc-text">索引的底层的数据结构了解过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">什么是聚簇索引和非聚簇索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">什么是回表？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">2.5.4.</span> <span class="toc-text">什么是覆盖索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">MySQL超大分页处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.5.5.</span> <span class="toc-text">索引的创建原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">2.5.6.</span> <span class="toc-text">什么情况下索引会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9sql%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-number">2.5.7.</span> <span class="toc-text">谈谈你对sql优化的经验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">表的设计的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">SQL语句优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">主从复制、读写分离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.5.8.</span> <span class="toc-text">事务的特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E5%8E%BB%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9FMySQL%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">2.5.9.</span> <span class="toc-text">并发事务会带来哪些问题？怎么去解决这些问题？MySQL默认的隔离级别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">2.5.10.</span> <span class="toc-text">如何解决这些并发事务产生的问题呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E5%92%8Cundo-log%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%EF%BC%89"><span class="toc-number">2.5.11.</span> <span class="toc-text">redo log和undo log的区别？（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E5%92%8Cbinlog%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%EF%BC%89"><span class="toc-number">2.5.12.</span> <span class="toc-text">redo log和binlog有什么区别？（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84%EF%BC%9F%EF%BC%88-%EF%BC%89"><span class="toc-number">2.5.13.</span> <span class="toc-text">事务的隔离性是如何保证的？（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.14.</span> <span class="toc-text">MySQL的主从同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E7%94%A8%E8%BF%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.15.</span> <span class="toc-text">你们项目用过分库分表吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5"><span class="toc-number">2.5.15.1.</span> <span class="toc-text">拆分策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.5.16.</span> <span class="toc-text">MySQL中如何定位慢查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%951%EF%BC%9A%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.5.16.1.</span> <span class="toc-text">解决方法1：开源工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%EF%BC%9AMySQL%E8%87%AA%E5%B8%A6%E7%9A%84%E6%85%A2%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.5.16.2.</span> <span class="toc-text">解决方法2：MySQL自带的慢日志查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BE%88%E6%85%A2%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.5.17.</span> <span class="toc-text">一条SQL执行的很慢，是如何进行分析的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.5.18.</span> <span class="toc-text">怎么看项目里慢查询语句有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E6%85%A2sql%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.5.19.</span> <span class="toc-text">怎么优化慢sql？举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.20.</span> <span class="toc-text">MySQL索引是怎么实现的，你有了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84mylsam%E5%92%8CinnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">2.5.21.</span> <span class="toc-text">MySQL的mylsam和innoDB存储引擎有什么区别？怎么选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8CRedis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%A1%B9%E7%9B%AE%E9%87%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.5.22.</span> <span class="toc-text">RabbitMQ消息队列和Redis消息队列有什么区别？项目里应该怎么选型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="toc-number">2.5.23.</span> <span class="toc-text">MySQL三大日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">2.5.24.</span> <span class="toc-text">MySQL基础架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.5.25.</span> <span class="toc-text">MySQL存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1MySQL%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.5.26.</span> <span class="toc-text">设计MySQL的表结构要考虑什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84char%E5%92%8Cvarchar%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.5.27.</span> <span class="toc-text">MySQL的char和varchar有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">2.6.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.1.</span> <span class="toc-text">Redis使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.6.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">2.6.4.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%EF%BC%9A%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">解决方案1：互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E8%AE%BE%E7%BD%AE%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">解决方案2：设置逻辑过期时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.6.5.</span> <span class="toc-text">双写一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E7%9F%AD%E6%9A%82%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">允许短暂的不一致</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.6.6.</span> <span class="toc-text">zset的底层原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.6.6.2.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.6.7.</span> <span class="toc-text">Redis的持久化方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%97%A5%E5%BF%97%EF%BC%88Append-Only-File%EF%BC%89%E8%BF%BD%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.7.1.</span> <span class="toc-text">AOF日志（Append Only File）追加文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%BF%AB%E7%85%A7%EF%BC%88Redis-Database-Backup-file%EF%BC%89redis%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.7.2.</span> <span class="toc-text">RDB快照（Redis Database Backup file）redis数据备份文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.7.3.</span> <span class="toc-text">RDB的执行原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">2.6.8.</span> <span class="toc-text">Redis数据过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">2.6.8.2.</span> <span class="toc-text">定期删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.6.9.</span> <span class="toc-text">Redis数据淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">2.6.10.</span> <span class="toc-text">Redis是单线程还是多线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A4%A7key%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.6.11.</span> <span class="toc-text">Redis大key会有什么问题？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">2.6.12.</span> <span class="toc-text">Redis为什么快？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.7.</span> <span class="toc-text">消息队列中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">2.7.1.</span> <span class="toc-text">RabbitMQ如何保证消息不丢失？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">生产者确认机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">消息持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">消费者确认</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">RabbitMQ消息的重复问题是如何解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E4%B8%AD%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%88%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%89"><span class="toc-number">2.7.3.</span> <span class="toc-text">RabbitMQ中死信交换机（延迟队列了解过吗）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.7.4.</span> <span class="toc-text">如何解决消息堆积问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRabbitMQ"><span class="toc-number">2.7.5.</span> <span class="toc-text">什么是RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.6.</span> <span class="toc-text">RabbitMQ的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.7.</span> <span class="toc-text">生产者消费者模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">2.8.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">浏览网页的全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BTCP-UDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.3.</span> <span class="toc-text">介绍下TCP UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">2.9.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.9.1.</span> <span class="toc-text">单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E5%88%B0AOP"><span class="toc-number">2.9.2.</span> <span class="toc-text">什么是AOP，你们项目中有没有使用到AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.9.3.</span> <span class="toc-text">谈谈你对AOP的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.9.4.</span> <span class="toc-text">谈谈你对IOC的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.9.5.</span> <span class="toc-text">Spring事务是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Springboot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.6.</span> <span class="toc-text">Springboot启动原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.2.</span> <span class="toc-text">工厂设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.2.3.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.3.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.4.</span> <span class="toc-text">责任链模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-number">2.11.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.11.1.</span> <span class="toc-text">常见的负载均衡算法有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF"><span class="toc-number">2.12.</span> <span class="toc-text">常见技术场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.12.1.</span> <span class="toc-text">单点登录这块是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.12.2.</span> <span class="toc-text">权限认证是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">2.12.3.</span> <span class="toc-text">上传数据的安全性你们怎么控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%B4%9F%E8%B4%A3%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.12.4.</span> <span class="toc-text">你负责项目的时候遇到哪些棘手的问题？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="toc-number">2.12.5.</span> <span class="toc-text">生产环境中问题如何排查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE1%EF%BC%9A%E5%8D%9A%E4%B8%96%E5%AE%9E%E4%B9%A0"><span class="toc-number">3.1.</span> <span class="toc-text">项目1：博世实习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何实现的单点登录?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringSecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">SpringSecurity的认证流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8CToken%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">双Token如何实现无感刷新机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E5%8E%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">RabbitMQ如何去实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%BC%BA%E5%88%B6%E4%B8%8B%E7%BA%BF"><span class="toc-number">3.1.5.</span> <span class="toc-text">如何让一个用户强制下线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%99%BA%E8%83%BD%E7%AE%80%E5%8E%86%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">项目2：智能简历解析系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E8%AF%9D%E6%9C%AF"><span class="toc-number">3.3.</span> <span class="toc-text">回答话术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">ThreadLocal在项目中有使用过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E7%9A%84%EF%BC%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">前端项目是怎么部署的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%80%8E%E4%B9%88%E9%85%8D%E5%90%88%E7%9A%84%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">前后端交互式怎么配合的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%97%B6%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%81%9A%E8%BF%87%E9%99%90%E6%B5%81%E5%90%97%EF%BC%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">登录时手机验证码做过限流吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%AD%E7%BA%A6Token%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="toc-number">3.3.5.</span> <span class="toc-text">续约Token是怎么设计的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0"><span class="toc-number">3.3.6.</span> <span class="toc-text">Token无感刷新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F%E5%88%86%E4%BA%86%E5%87%A0%E4%B8%AA%E5%BA%93%E5%92%8C%E8%A1%A8%EF%BC%8C%E4%BD%A0%E8%B4%9F%E8%B4%A3%E8%AE%BE%E8%AE%A1%E8%BF%87%E9%82%A3%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">3.3.7.</span> <span class="toc-text">你们项目的数据库是怎么设计的？分了几个库和表，你负责设计过那些数据库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">3.3.8.</span> <span class="toc-text">登录是怎么做的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">4.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF"><span class="toc-number">4.1.</span> <span class="toc-text">腾讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E6%88%96%E8%80%85%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">常见的攻击手段或者可以利用的漏洞有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-1%E5%92%8Chttp2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.</span> <span class="toc-text">http1.1和http2.0的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">CSRF的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%9A%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">单索引和联合索引的区别？会用在什么场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E6%9E%9C%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.5.</span> <span class="toc-text">索引如果过多会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%E7%9A%84%EF%BC%9F"><span class="toc-number">4.1.6.</span> <span class="toc-text">java对象是怎么回收的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2"><span class="toc-number">4.2.</span> <span class="toc-text">美团</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/11/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/" title="SpringBoot项目快速搭建"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404112204639.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot项目快速搭建"/></a><div class="content"><a class="title" href="/2024/04/11/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/" title="SpringBoot项目快速搭建">SpringBoot项目快速搭建</a><time datetime="2024-04-11T14:04:12.000Z" title="Created 2024-04-11 22:04:12">2024-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/11/Java%E4%B8%8EPython%E5%AF%B9%E6%AF%94/" title="Java与Python对比"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java与Python对比"/></a><div class="content"><a class="title" href="/2024/04/11/Java%E4%B8%8EPython%E5%AF%B9%E6%AF%94/" title="Java与Python对比">Java与Python对比</a><time datetime="2024-04-11T08:14:20.000Z" title="Created 2024-04-11 16:14:20">2024-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/Centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySQL/" title="Centos服务器安装MySQL"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404052219181.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Centos服务器安装MySQL"/></a><div class="content"><a class="title" href="/2024/04/05/Centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySQL/" title="Centos服务器安装MySQL">Centos服务器安装MySQL</a><time datetime="2024-04-05T08:25:43.000Z" title="Created 2024-04-05 16:25:43">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Springboot学习笔记"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202404052217478.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot学习笔记"/></a><div class="content"><a class="title" href="/2024/04/05/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Springboot学习笔记">Springboot学习笔记</a><time datetime="2024-04-05T05:22:11.000Z" title="Created 2024-04-05 13:22:11">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="三次握手与四次挥手"><img src="https://cdn.jsdelivr.net/gh/GuoXianSen/pic-bed@main/imgs/202403261106023.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三次握手与四次挥手"/></a><div class="content"><a class="title" href="/2024/03/26/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="三次握手与四次挥手">三次握手与四次挥手</a><time datetime="2024-03-26T03:05:56.000Z" title="Created 2024-03-26 11:05:56">2024-03-26</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Clay_Guo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>